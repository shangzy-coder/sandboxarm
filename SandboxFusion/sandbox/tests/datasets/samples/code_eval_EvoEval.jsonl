{"canonical_solution": "\n    def is_happy(s):\n        s = s.replace(',', '.')\n        if len(s) < 3:\n            return False\n        for i in range(len(s) - 2):\n            if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n                return False\n        return True\n\n    a_happy = is_happy(a)\n    b_happy = is_happy(b)\n\n    if not a_happy and not b_happy:\n        return None\n    elif a_happy and not b_happy:\n        return a\n    elif not a_happy and b_happy:\n        return b\n    else:\n        a_float = a.replace(',', '.')\n        b_float = b.replace(',', '.')\n        if float(a_float) > float(b_float):\n            return a\n        elif float(a_float) < float(b_float):\n            return b\n        else:\n            return None\n", "content": "def compare_happiness(a, b):\n    \"\"\"\n    Create a function that takes two strings representing real numbers. \n    The function should first check if each string is 'happy' or not. \n    A string is 'happy' if its length is at least 3 and every 3 consecutive characters are distinct.\n    If neither string is 'happy', return None. \n    If only one string is 'happy', return that string.\n    If both strings are 'happy', compare them as real numbers (the floating point might be . or ,) \n    and return the larger number as a string. If they are equal, return None.\n\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    compare_happiness(\"1,234\", \"5,678\") is \"5,678\"\n    compare_happiness(\"1,112\", \"3,344\") is None\n    compare_happiness(\"1,123\", \"1,123\") is None\n    compare_happiness(\"1,234\", \"1,112\") is \"1,234\"\n    \"\"\"", "id": "EvoEval_combine_EvoEval/0", "labels": "{\"entry_point\":\"compare_happiness\"}", "test": "\nimport numpy as np\nfrom numpy import nan, inf # for some outputs.\nimport sys\n\nsys.set_int_max_str_digits(0)\n\nfrom enum import IntEnum, auto\n\ndef is_floats(x) -> bool:\n    # check if it is float; List[float]; Tuple[float]\n    # TODO: search for any close floats? (other data structures)\n    if isinstance(x, float):\n        return True\n    if isinstance(x, (list, tuple)):\n        return all(isinstance(i, float) for i in x)\n    if isinstance(x, np.ndarray):\n        return x.dtype == np.float64 or x.dtype == np.float32\n    return False\n\n\nclass DataType(IntEnum):\n    Float = auto()\n    Bool = auto()\n    Int = auto()\n    Str = auto()\n    Null = auto()\n    Tuple = auto()\n    List = auto()\n    Dict = auto()\n    Set = auto()\n    Type = auto()\n    Unknown = auto()\n\n\ndef get_type(x):\n    if x is None:\n        return DataType.Null\n    elif isinstance(x, bool):\n        return DataType.Bool\n    elif isinstance(x, int):\n        return DataType.Int\n    elif isinstance(x, str):\n        return DataType.Str\n    elif is_floats(x):\n        return DataType.Float\n    elif isinstance(x, tuple):\n        return DataType.Tuple\n    elif isinstance(x, list):\n        return DataType.List\n    elif isinstance(x, dict):\n        return DataType.Dict\n    elif isinstance(x, set):\n        return DataType.Set\n    elif isinstance(x, type):\n        return DataType.Type\n    else:\n        return DataType.Unknown\n\n\ndef is_equal(x, y) -> tuple[bool, str]:\n    x_type, y_type = get_type(x), get_type(y)\n    if x_type != y_type:\n        return False, \"Type mismatch: {} vs {}\".format(str(x_type), str(y_type))\n\n    if x_type in [DataType.Int, DataType.Bool, DataType.Null, DataType.Str, DataType.Set, DataType.Type]:\n        if x == y:\n            return True, None\n        try:\n            error_msg = \"INT/BOOL/NULL/ Value mismatch: {} vs {}\".format(repr(x)[:300], repr(y)[:300])\n        except:\n            error_msg = \"Value mismatch: too large for display\"\n        return False, error_msg\n    elif x_type == DataType.Float:\n        if np.allclose(x, y, equal_nan=True, atol=1e-6): # guard against nan\n            return True, None\n        else:\n            return False, \"FLOAT Value mismatch: {} vs {}\".format(x, y)\n    elif x_type in [DataType.List, DataType.Tuple]:\n        if len(x) != len(y):\n            return False, \"Length mismatch: {} vs {}\".format(len(x), len(y))\n        for i in range(len(x)):\n            equal, msg = is_equal(x[i], y[i])\n            if not equal:\n                return False, msg\n        return True, None\n    elif x_type == DataType.Dict:\n        if len(x) != len(y):\n            return False, \"Length mismatch: {} vs {}\".format(len(x), len(y))\n        for k, v in x.items():\n            if k not in y:\n                return False, \"DICT Value mismatch: key {} in {} but not in {}\".format(k, x, y)\n            equal, msg = is_equal(v, y[k])\n            if not equal:\n                return False, msg\n        return True, None\n    else:\n        try:\n            if x == y:  # e.g., object comparison\n                return True, None\n            else:\n                return False, \"ELSE Value mismatch: {} vs {}\".format(x, y)\n        except:\n            return False, \"Unsupported type: {} <-- {}\".format(x_type, type(x))\n\ndef check(candidate):\n    inputs = [eval(f\"[{i}]\") for i in ['\"1,234\", \"1,112\"', '\"1,123\", \"1,123\"', '\"1,112\", \"3,344\"', '\"1,234\", \"5,678\"', \"'123.45', '234.56'\", \"'345.67', '456.78'\", \"'567.89', '678.90'\", \"'789.01', '890.12'\", \"'901.23', '012.34'\", \"'123,456', '234,567'\", \"'345,678', '456,789'\", \"'567,890', '678,901'\", \"'789,012', '890,123'\", \"'901,234', '012,345'\", \"'12.34', '23.45'\", \"'34.56', '45.67'\", \"'56.78', '67.89'\", \"'78.90', '89.01'\", \"'90.12', '01.23'\", \"'12,345', '23,456'\", \"'34,567', '45,678'\", \"'56,789', '67,890'\", \"'78,901', '89,012'\", \"'90,123', '01,234'\", \"'111.111', '222.222'\", \"'333.333', '444.444'\", \"'555.555', '666.666'\", \"'777.777', '888.888'\", \"'999.999', '000.000'\", \"'111,111', '222,222'\", \"'333,333', '444,444'\", \"'555,555', '666,666'\", \"'777,777', '888,888'\", \"'999,999', '000,000'\", \"'123', '234'\", \"'122', '233'\", \"'1,23', '2,34'\", \"'1.23', '2.34'\", \"'1.22', '2.33'\", \"'', ''\", \"'1,1', '2,2'\", '\"1.111\", \"1.111\"', '\"1.123\", \"1.123\"', '\"12\", \"13\"', '\"12\", \"\"', '\"12.345\", \"23.456\"', '\"12,345\", \"23,456\"', '\"1,2345\", \"1,112\"', '\"1.2345\", \"1.112\"', '\"1.2345\", \"1,112\"', '\"1,2345\", \"1.112\"', \"'1', '2'\", \"'12', '34'\", \"'11', '22'\", \"'123', '123'\", \"',123', ',12'\", \"'12,', '34,'\", \"'1.2', '3.4'\", \"'0.00', '0.01'\", \"'1,234', '1.234'\", \"'1.234', ',1234'\", \"',1234', '1.234'\", \"'1,234', ',1234'\", \"'123', ',12'\", \"'1', ''\", \"'', '1'\", \"'', ''\", \"'123', '1234'\", \"'1234', '123'\", \"'12,34', '12.34'\", \"'1', '2'\", \"'123', '123'\", \"'123', '456'\", \"'1.2.3', '4.5.6'\", \"'1.12', '2.23'\", \"'1.123', '2.234'\", \"'1.1.2.3', '2.2.3.4'\", \"'1,1,2,3,', '2,2,3,4,'\", \"'123', '122'\", \"'12.3', '12.4'\", \"'1,2,3', '1,2,2'\", \"'1,1,2,3,4', '1,234'\", \"'1.1.2.3.4', '1,234'\", \"'', '1,234'\", \"'10,000', '20,000'\", \"'3,456', '3,456'\", \"'1,234', '2,345'\", \"'12,345', '6,789'\", \"'1,123', '11,123'\", \"'0,000', '0,111'\", \"'5,678', '5,6789'\", \"'1,23456', '1,23457'\", \"'1,112', '1,111'\", \"'1,234', '1,2345'\", \"'1,111', '1,112'\", \"'1,112', '0,000'\", \"'0,001', '0,011'\", \"'0,001', '0,010'\", \"'0,010', '0,001'\", \"'1,234', '1,23400001'\", \"'9,999', '9,998'\", \"'99,999', '99,998'\", \"'1,123', '1,1234'\", \"'1,234', '5,678'\", \"'1,112', '3,344'\", \"'1,234', '1,112'\", \"'1,123', '1,123'\", \"'4,567', '8,901'\", \"'1,234567', '1,2345678'\"]]\n    outputs = ['1,234', None, None, '5,678', '234.56', '456.78', '678.90', '890.12', '901.23', '234,567', '456,789', '678,901', '890,123', '901,234', '23.45', '45.67', '67.89', '89.01', '90.12', '23,456', '45,678', '67,890', '89,012', '90,123', None, None, None, None, None, None, None, None, None, None, '234', None, '2,34', '2.34', None, None, None, None, None, None, None, '23.456', '23,456', '1,2345', '1.2345', '1.2345', '1,2345', None, None, None, None, ',123', '34,', '3.4', None, None, '1.234', '1.234', '1,234', '123', None, None, None, '1234', '1234', None, None, None, '456', None, None, None, None, None, '123', '12.4', None, '1,234', '1,234', '1,234', None, None, '2,345', '12,345', None, None, '5,6789', '1,23457', None, '1,2345', None, None, None, None, None, '1,234', None, None, None, '5,678', None, '1,234', None, '8,901', '1,2345678']\n    for i, (inp, exp) in enumerate(zip(inputs, outputs)):\n        exact_match, _ = is_equal(candidate(*inp), exp)\n        assert exact_match\n    ", "__internal_uuid__": "043a85d4-f18d-46d1-8861-215b8fbf63ed"}
{"canonical_solution": "\n    def rounding(val):\n        if abs(val - int(val)) != 0.5:\n            return round(val)\n        if val > 0:\n            return int(val) + 1\n        else:\n            return int(val) - 1\n    # Extract the numeric part from the string\n    numeric_part = ''.join(filter((lambda x: x == '.' or x == '-' or str.isdigit(x)), value))\n    # Extract the alphabetic part from the string\n    alphabetic_part = ''.join(filter(str.isalpha, value))\n    # Round the numeric part away from zero\n    rounded_numeric_part = rounding(float(numeric_part))\n    # Flip the case of the alphabetic part\n    flipped_alphabetic_part = alphabetic_part.swapcase()\n    # Return the result as a string\n    return str(rounded_numeric_part) + ' ' + flipped_alphabetic_part\n", "content": "def round_and_flip(value: str) -> str:\n    '''\n    Create a function that takes a value representing two parts (number and string)\n    and returns a string with two parts: 1) The closest integer to the number,\n    and 2) The string with its case flipped. If the number is equidistant from two integers,\n    round it away from zero. Between these two parts, add a space. \n\n    Examples\n    >>> round_and_flip(\"10.5abc\")\n    '11 ABC'\n    >>> round_and_flip(\"15.3ABC\")\n    '15 abc'\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example round_and_flip(\"14.5abc\") should\n    return '15 ABC' and round_and_flip(\"-14.5ABC\") should return '-15 abc'.\n    '''", "id": "EvoEval_combine_EvoEval/1", "labels": "{\"entry_point\":\"round_and_flip\"}", "test": "\nimport numpy as np\nfrom numpy import nan, inf # for some outputs.\nimport sys\n\nsys.set_int_max_str_digits(0)\n\nfrom enum import IntEnum, auto\n\ndef is_floats(x) -> bool:\n    # check if it is float; List[float]; Tuple[float]\n    # TODO: search for any close floats? (other data structures)\n    if isinstance(x, float):\n        return True\n    if isinstance(x, (list, tuple)):\n        return all(isinstance(i, float) for i in x)\n    if isinstance(x, np.ndarray):\n        return x.dtype == np.float64 or x.dtype == np.float32\n    return False\n\n\nclass DataType(IntEnum):\n    Float = auto()\n    Bool = auto()\n    Int = auto()\n    Str = auto()\n    Null = auto()\n    Tuple = auto()\n    List = auto()\n    Dict = auto()\n    Set = auto()\n    Type = auto()\n    Unknown = auto()\n\n\ndef get_type(x):\n    if x is None:\n        return DataType.Null\n    elif isinstance(x, bool):\n        return DataType.Bool\n    elif isinstance(x, int):\n        return DataType.Int\n    elif isinstance(x, str):\n        return DataType.Str\n    elif is_floats(x):\n        return DataType.Float\n    elif isinstance(x, tuple):\n        return DataType.Tuple\n    elif isinstance(x, list):\n        return DataType.List\n    elif isinstance(x, dict):\n        return DataType.Dict\n    elif isinstance(x, set):\n        return DataType.Set\n    elif isinstance(x, type):\n        return DataType.Type\n    else:\n        return DataType.Unknown\n\n\ndef is_equal(x, y) -> tuple[bool, str]:\n    x_type, y_type = get_type(x), get_type(y)\n    if x_type != y_type:\n        return False, \"Type mismatch: {} vs {}\".format(str(x_type), str(y_type))\n\n    if x_type in [DataType.Int, DataType.Bool, DataType.Null, DataType.Str, DataType.Set, DataType.Type]:\n        if x == y:\n            return True, None\n        try:\n            error_msg = \"INT/BOOL/NULL/ Value mismatch: {} vs {}\".format(repr(x)[:300], repr(y)[:300])\n        except:\n            error_msg = \"Value mismatch: too large for display\"\n        return False, error_msg\n    elif x_type == DataType.Float:\n        if np.allclose(x, y, equal_nan=True, atol=1e-6): # guard against nan\n            return True, None\n        else:\n            return False, \"FLOAT Value mismatch: {} vs {}\".format(x, y)\n    elif x_type in [DataType.List, DataType.Tuple]:\n        if len(x) != len(y):\n            return False, \"Length mismatch: {} vs {}\".format(len(x), len(y))\n        for i in range(len(x)):\n            equal, msg = is_equal(x[i], y[i])\n            if not equal:\n                return False, msg\n        return True, None\n    elif x_type == DataType.Dict:\n        if len(x) != len(y):\n            return False, \"Length mismatch: {} vs {}\".format(len(x), len(y))\n        for k, v in x.items():\n            if k not in y:\n                return False, \"DICT Value mismatch: key {} in {} but not in {}\".format(k, x, y)\n            equal, msg = is_equal(v, y[k])\n            if not equal:\n                return False, msg\n        return True, None\n    else:\n        try:\n            if x == y:  # e.g., object comparison\n                return True, None\n            else:\n                return False, \"ELSE Value mismatch: {} vs {}\".format(x, y)\n        except:\n            return False, \"Unsupported type: {} <-- {}\".format(x_type, type(x))\n\ndef check(candidate):\n    inputs = [eval(f\"[{i}]\") for i in ['\"15.3ABC\"', '\"10.5abc\"', \"'24.8xyz'\", \"'-13.7XYZ'\", \"'0.5abc'\", \"'-0.5XYZ'\", \"'0.0abc'\", \"'14.5abc'\", \"'-14.5ABC'\", \"'123.456789XYZ'\", \"'-123.456789abc'\", \"'999.999XYZ'\", \"'-999.999abc'\", \"'0.0abc'\", \"'-100.5ABC'\", \"'0.5abc'\", \"'-0.5ABC'\", \"'999999999.5abc'\", \"'-999999999.5ABC'\", \"'0.999999999abc'\", \"'-0.999999999ABC'\", \"'14.5abc'\", \"'-14.5ABC'\", \"'0.5xyz'\", \"'-0.5XYZ'\", \"'99.9aaa'\", \"'-99.9AAA'\", \"'10000.5abc'\", \"'-10000.5ABC'\", \"'0.999xyz'\", \"'-0.999XYZ'\", \"'10.1abc'\", \"'-10.1ABC'\", \"'-14.5ABC'\", \"'0.5abc'\", \"'-0.5XYZ'\", \"'0.0def'\", \"'999.5ABC'\", \"'-999.5def'\", \"'14.00001ghi'\", \"'-14.99999JKL'\", \"'1.5mno'\", \"'-1.5PQR'\", \"'0.999abc'\", \"'-0.999XYZ'\", \"'1000.5def'\", \"'-1000.5GHI'\"]]\n    outputs = ['15 abc', '11 ABC', '25 XYZ', '-14 xyz', '1 ABC', '-1 xyz', '0 ABC', '15 ABC', '-15 abc', '123 xyz', '-123 ABC', '1000 xyz', '-1000 ABC', '0 ABC', '-101 abc', '1 ABC', '-1 abc', '1000000000 ABC', '-1000000000 abc', '1 ABC', '-1 abc', '15 ABC', '-15 abc', '1 XYZ', '-1 xyz', '100 AAA', '-100 aaa', '10001 ABC', '-10001 abc', '1 XYZ', '-1 xyz', '10 ABC', '-10 abc', '-15 abc', '1 ABC', '-1 xyz', '0 DEF', '1000 abc', '-1000 DEF', '14 GHI', '-15 jkl', '2 MNO', '-2 pqr', '1 ABC', '-1 xyz', '1001 DEF', '-1001 ghi']\n    for i, (inp, exp) in enumerate(zip(inputs, outputs)):\n        exact_match, _ = is_equal(candidate(*inp), exp)\n        assert exact_match\n    ", "__internal_uuid__": "655e4eb8-7932-4956-8ddb-fb223b6b248a"}
{"canonical_solution": "\n    result = []\n    for name, grade in name_grade_list:\n        name = name.capitalize()\n        if grade == 4.0:\n            letter_grade = 'A+'\n        elif grade > 3.7:\n            letter_grade = 'A'\n        elif grade > 3.3:\n            letter_grade = 'A-'\n        elif grade > 3.0:\n            letter_grade = 'B+'\n        elif grade > 2.7:\n            letter_grade = 'B'\n        elif grade > 2.3:\n            letter_grade = 'B-'\n        elif grade > 2.0:\n            letter_grade = 'C+'\n        elif grade > 1.7:\n            letter_grade = 'C'\n        elif grade > 1.3:\n            letter_grade = 'C-'\n        elif grade > 1.0:\n            letter_grade = 'D+'\n        elif grade > 0.7:\n            letter_grade = 'D'\n        elif grade > 0.0:\n            letter_grade = 'D-'\n        else:\n            letter_grade = 'E'\n        result.append((name, letter_grade))\n    return result\n\n", "content": "\ndef class_grades_with_flip(name_grade_list):\n    \"\"\"A teacher has to give the grades to students. The teacher has a list of students with their GPAs.\n    The teacher wants to convert these GPAs into letter grades. However, due to an administrative error, \n    some students' names have been input in the wrong case (all caps or all lowercase). \n    To fix this, their names need to be converted to proper case i.e., only the first letter of the name \n    should be in uppercase and the rest in lowercase.\n\n    Additionally, the teacher has her own algorithm for grading. Write a function that will output a list\n    of tuples where each tuple contains the student's name in proper case and the corresponding letter grade \n    using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n\n    Example: \n    class_grades_with_flip([('JOHN', 4.0), ('sarah', 3.0), ('ALICE', 1.7), ('BOB', 2.0), ('linda', 3.5)]) \n    ==> [('John', 'A+'), ('Sarah', 'B'), ('Alice', 'C-'), ('Bob', 'C'), ('Linda', 'A-')]\n    \"\"\"\n", "id": "EvoEval_combine_EvoEval/10", "labels": "{\"entry_point\":\"class_grades_with_flip\"}", "test": "\nimport numpy as np\nfrom numpy import nan, inf # for some outputs.\nimport sys\n\nsys.set_int_max_str_digits(0)\n\nfrom enum import IntEnum, auto\n\ndef is_floats(x) -> bool:\n    # check if it is float; List[float]; Tuple[float]\n    # TODO: search for any close floats? (other data structures)\n    if isinstance(x, float):\n        return True\n    if isinstance(x, (list, tuple)):\n        return all(isinstance(i, float) for i in x)\n    if isinstance(x, np.ndarray):\n        return x.dtype == np.float64 or x.dtype == np.float32\n    return False\n\n\nclass DataType(IntEnum):\n    Float = auto()\n    Bool = auto()\n    Int = auto()\n    Str = auto()\n    Null = auto()\n    Tuple = auto()\n    List = auto()\n    Dict = auto()\n    Set = auto()\n    Type = auto()\n    Unknown = auto()\n\n\ndef get_type(x):\n    if x is None:\n        return DataType.Null\n    elif isinstance(x, bool):\n        return DataType.Bool\n    elif isinstance(x, int):\n        return DataType.Int\n    elif isinstance(x, str):\n        return DataType.Str\n    elif is_floats(x):\n        return DataType.Float\n    elif isinstance(x, tuple):\n        return DataType.Tuple\n    elif isinstance(x, list):\n        return DataType.List\n    elif isinstance(x, dict):\n        return DataType.Dict\n    elif isinstance(x, set):\n        return DataType.Set\n    elif isinstance(x, type):\n        return DataType.Type\n    else:\n        return DataType.Unknown\n\n\ndef is_equal(x, y) -> tuple[bool, str]:\n    x_type, y_type = get_type(x), get_type(y)\n    if x_type != y_type:\n        return False, \"Type mismatch: {} vs {}\".format(str(x_type), str(y_type))\n\n    if x_type in [DataType.Int, DataType.Bool, DataType.Null, DataType.Str, DataType.Set, DataType.Type]:\n        if x == y:\n            return True, None\n        try:\n            error_msg = \"INT/BOOL/NULL/ Value mismatch: {} vs {}\".format(repr(x)[:300], repr(y)[:300])\n        except:\n            error_msg = \"Value mismatch: too large for display\"\n        return False, error_msg\n    elif x_type == DataType.Float:\n        if np.allclose(x, y, equal_nan=True, atol=1e-6): # guard against nan\n            return True, None\n        else:\n            return False, \"FLOAT Value mismatch: {} vs {}\".format(x, y)\n    elif x_type in [DataType.List, DataType.Tuple]:\n        if len(x) != len(y):\n            return False, \"Length mismatch: {} vs {}\".format(len(x), len(y))\n        for i in range(len(x)):\n            equal, msg = is_equal(x[i], y[i])\n            if not equal:\n                return False, msg\n        return True, None\n    elif x_type == DataType.Dict:\n        if len(x) != len(y):\n            return False, \"Length mismatch: {} vs {}\".format(len(x), len(y))\n        for k, v in x.items():\n            if k not in y:\n                return False, \"DICT Value mismatch: key {} in {} but not in {}\".format(k, x, y)\n            equal, msg = is_equal(v, y[k])\n            if not equal:\n                return False, msg\n        return True, None\n    else:\n        try:\n            if x == y:  # e.g., object comparison\n                return True, None\n            else:\n                return False, \"ELSE Value mismatch: {} vs {}\".format(x, y)\n        except:\n            return False, \"Unsupported type: {} <-- {}\".format(x_type, type(x))\n\ndef check(candidate):\n    inputs = [eval(f\"[{i}]\") for i in [\"[('JOHN', 4.0), ('sarah', 3.0), ('ALICE', 1.7), ('BOB', 2.0), ('linda', 3.5)]\", \"[('MARY', 3.8), ('JOHN', 0.0), ('sarah', 2.1), ('ALICE', 1.2), ('BOB', 2.9), ('linda', 3.4), ('JAMES', 1.9), ('LUCY', 3.6), ('julia', 2.8), ('PAUL', 1.0), ('ROBERT', 0.1)]\", \"[('Peter', 0.5), ('Paul', 1.5), ('MARY', 2.5), ('JOHN', 3.5), ('sarah', 1.0), ('ALICE', 2.0), ('BOB', 3.0), ('linda', 4.0)]\", \"[('ANDRE', 2.7), ('sarah', 3.3), ('ALICE', 3.1), ('BOB', 2.0), ('linda', 3.7), ('JOHN', 1.3), ('Peter', 0.0), ('Paul', 1.7), ('MARY', 2.3), ('JOHN', 3.7), ('sarah', 1.0), ('ALICE', 2.0)]\", \"[('ANDRE', 4.0), ('JOHN', 3.7), ('sarah', 3.3), ('ALICE', 3.0), ('BOB', 2.7), ('linda', 2.3), ('JOHN', 2.0), ('Peter', 1.7), ('Paul', 1.3), ('MARY', 1.0), ('JOHN', 0.7), ('sarah', 0.0)]\", \"[('ANDRE', 1.1), ('JOHN', 2.2), ('sarah', 2.8), ('ALICE', 3.9), ('BOB', 2.0), ('linda', 3.7), ('JOHN', 1.3), ('Peter', 0.0), ('Paul', 1.7), ('MARY', 2.3), ('JOHN', 3.7), ('sarah', 1.0)]\", '[]', \"[('mARY', 0.0), ('JOE', 0.7), ('MiKE', 1.0), ('suzan', 1.3), ('anNE', 1.7)]\", \"[('BEN', 2.0), ('SAM', 2.3), ('NATHAN', 2.7), ('liz', 3.0), ('albert', 3.3)]\", \"[('KIM', 3.7), ('lee', 4.0), ('mark', 4.0), ('ADA', 4.0), ('bob', 4.0)]\", \"[('Ada', 2.5), ('BOB', 3.75), ('carol', 3.25), ('DAN', 2.75), ('erin', 3.5)]\", \"[('Faith', 3.1), ('GRANT', 1.9), ('harry', 1.4), ('IVAN', 0.8), ('jack', 0.1)]\", \"[('michael', 4.2), ('JOHN', 0.0), ('mARY', 1.0), ('sUZAN', 0.7), ('pETER', 3.0)]\", \"[('alex', 1.2), ('VICTOR', 2.2), ('rOBERT', 2.0), ('tOM', 3.8), ('liz', 0.5)]\", \"[('dENISE', 3.4), ('aNDREW', 1.9), ('sANDY', 2.7), ('rOSE', 1.3), ('bEN', 3.5)]\", \"[('mATTHEW', 4.01), ('kAREN', 1.4), ('bILL', 0.9), ('dAVId', 1.6), ('pAUL', 2.1)]\", \"[('sUE', 3.25), ('lAURA', 2.75), ('jEFF', 1.99), ('kIM', 0.01), ('aNNE', 3.99)]\", \"[('LUCY', 3.8), ('SAM', 1.9), ('RAHUL', 0.7), ('MIKE', 2.5), ('AMY', 3.0)]\", \"[('ZARA', 1.0), ('VIKAS', 0.3), ('KATE', 0.0), ('LOLA', 2.5), ('OLIVER', 3.6)]\", \"[('JOHN', 4.0), ('sarah', 3.7), ('ALICE', 3.3), ('BOB', 3.0), ('linda', 2.7), ('Peter', 2.3), ('Ravi', 2.0), ('Monica', 1.7), ('Ross', 1.3), ('Rachel', 1.0), ('Joey', 0.7), ('Chandler', 0.0)]\", \"[('JANE', 1.9), ('JAMES', 2.9), ('JAY', 3.9), ('JIM', 3.1), ('JENNY', 2.0), ('JOY', 1.0), ('JESSICA', 2.5)]\", \"[('ALAN', 3.3), ('BETTY', 3.0), ('CARL', 2.7), ('DEE', 2.3), ('ED', 2.0), ('FAYE', 1.7), ('GREG', 1.3), ('HELEN', 1.0), ('IKE', 0.7), ('JILL', 0.0)]\"]]\n    outputs = [[('John', 'A+'), ('Sarah', 'B'), ('Alice', 'C-'), ('Bob', 'C'), ('Linda', 'A-')], [('Mary', 'A'), ('John', 'E'), ('Sarah', 'C+'), ('Alice', 'D+'), ('Bob', 'B'), ('Linda', 'A-'), ('James', 'C'), ('Lucy', 'A-'), ('Julia', 'B'), ('Paul', 'D'), ('Robert', 'D-')], [('Peter', 'D-'), ('Paul', 'C-'), ('Mary', 'B-'), ('John', 'A-'), ('Sarah', 'D'), ('Alice', 'C'), ('Bob', 'B'), ('Linda', 'A+')], [('Andre', 'B-'), ('Sarah', 'B+'), ('Alice', 'B+'), ('Bob', 'C'), ('Linda', 'A-'), ('John', 'D+'), ('Peter', 'E'), ('Paul', 'C-'), ('Mary', 'C+'), ('John', 'A-'), ('Sarah', 'D'), ('Alice', 'C')], [('Andre', 'A+'), ('John', 'A-'), ('Sarah', 'B+'), ('Alice', 'B'), ('Bob', 'B-'), ('Linda', 'C+'), ('John', 'C'), ('Peter', 'C-'), ('Paul', 'D+'), ('Mary', 'D'), ('John', 'D-'), ('Sarah', 'E')], [('Andre', 'D+'), ('John', 'C+'), ('Sarah', 'B'), ('Alice', 'A'), ('Bob', 'C'), ('Linda', 'A-'), ('John', 'D+'), ('Peter', 'E'), ('Paul', 'C-'), ('Mary', 'C+'), ('John', 'A-'), ('Sarah', 'D')], [], [('Mary', 'E'), ('Joe', 'D-'), ('Mike', 'D'), ('Suzan', 'D+'), ('Anne', 'C-')], [('Ben', 'C'), ('Sam', 'C+'), ('Nathan', 'B-'), ('Liz', 'B'), ('Albert', 'B+')], [('Kim', 'A-'), ('Lee', 'A+'), ('Mark', 'A+'), ('Ada', 'A+'), ('Bob', 'A+')], [('Ada', 'B-'), ('Bob', 'A'), ('Carol', 'B+'), ('Dan', 'B'), ('Erin', 'A-')], [('Faith', 'B+'), ('Grant', 'C'), ('Harry', 'C-'), ('Ivan', 'D'), ('Jack', 'D-')], [('Michael', 'A'), ('John', 'E'), ('Mary', 'D'), ('Suzan', 'D-'), ('Peter', 'B')], [('Alex', 'D+'), ('Victor', 'C+'), ('Robert', 'C'), ('Tom', 'A'), ('Liz', 'D-')], [('Denise', 'A-'), ('Andrew', 'C'), ('Sandy', 'B-'), ('Rose', 'D+'), ('Ben', 'A-')], [('Matthew', 'A'), ('Karen', 'C-'), ('Bill', 'D'), ('David', 'C-'), ('Paul', 'C+')], [('Sue', 'B+'), ('Laura', 'B'), ('Jeff', 'C'), ('Kim', 'D-'), ('Anne', 'A')], [('Lucy', 'A'), ('Sam', 'C'), ('Rahul', 'D-'), ('Mike', 'B-'), ('Amy', 'B')], [('Zara', 'D'), ('Vikas', 'D-'), ('Kate', 'E'), ('Lola', 'B-'), ('Oliver', 'A-')], [('John', 'A+'), ('Sarah', 'A-'), ('Alice', 'B+'), ('Bob', 'B'), ('Linda', 'B-'), ('Peter', 'C+'), ('Ravi', 'C'), ('Monica', 'C-'), ('Ross', 'D+'), ('Rachel', 'D'), ('Joey', 'D-'), ('Chandler', 'E')], [('Jane', 'C'), ('James', 'B'), ('Jay', 'A'), ('Jim', 'B+'), ('Jenny', 'C'), ('Joy', 'D'), ('Jessica', 'B-')], [('Alan', 'B+'), ('Betty', 'B'), ('Carl', 'B-'), ('Dee', 'C+'), ('Ed', 'C'), ('Faye', 'C-'), ('Greg', 'D+'), ('Helen', 'D'), ('Ike', 'D-'), ('Jill', 'E')]]\n    for i, (inp, exp) in enumerate(zip(inputs, outputs)):\n        exact_match, _ = is_equal(candidate(*inp), exp)\n        assert exact_match\n    ", "__internal_uuid__": "240fae49-842e-43ba-a485-292d4f7c5d2d"}
{"canonical_solution": "\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    vowels = ['a', 'e', 'i', 'o', 'u']\n\n    if planet1 not in planets or planet2 not in planets:\n        return 0\n\n    start = min(planets.index(planet1), planets.index(planet2))\n    end = max(planets.index(planet1), planets.index(planet2))\n\n    count = 0\n    for planet in planets[start+1:end]:\n        for letter in planet.lower():\n            if letter in vowels:\n                count += 1\n        if planet.lower().endswith('y'):\n            count += 1\n\n    return count\n\n", "content": "\ndef planet_vowel_count(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closest to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return an integer representing the number of vowels \n    in the names of the planets whose orbits are located between the orbit of \n    planet1 and the orbit of planet2, sorted by the proximity to the sun. \n\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given planet name.\n\n    If planet1 or planet2 are not correct planet names, the function should return 0.\n\n    Examples\n    planet_vowel_count(\"Jupiter\", \"Neptune\") ==> 5  # (Saturn = 2, Uranus = 3)\n    planet_vowel_count(\"Earth\", \"Mercury\") ==> 2  # (Venus = 2)\n    planet_vowel_count(\"Mercury\", \"Uranus\") ==> 10  # (Venus = 2, Earth = 2, Mars = 1, Jupiter = 3, Saturn = 2)\n    '''\n", "id": "EvoEval_combine_EvoEval/11", "labels": "{\"entry_point\":\"planet_vowel_count\"}", "test": "\nimport numpy as np\nfrom numpy import nan, inf # for some outputs.\nimport sys\n\nsys.set_int_max_str_digits(0)\n\nfrom enum import IntEnum, auto\n\ndef is_floats(x) -> bool:\n    # check if it is float; List[float]; Tuple[float]\n    # TODO: search for any close floats? (other data structures)\n    if isinstance(x, float):\n        return True\n    if isinstance(x, (list, tuple)):\n        return all(isinstance(i, float) for i in x)\n    if isinstance(x, np.ndarray):\n        return x.dtype == np.float64 or x.dtype == np.float32\n    return False\n\n\nclass DataType(IntEnum):\n    Float = auto()\n    Bool = auto()\n    Int = auto()\n    Str = auto()\n    Null = auto()\n    Tuple = auto()\n    List = auto()\n    Dict = auto()\n    Set = auto()\n    Type = auto()\n    Unknown = auto()\n\n\ndef get_type(x):\n    if x is None:\n        return DataType.Null\n    elif isinstance(x, bool):\n        return DataType.Bool\n    elif isinstance(x, int):\n        return DataType.Int\n    elif isinstance(x, str):\n        return DataType.Str\n    elif is_floats(x):\n        return DataType.Float\n    elif isinstance(x, tuple):\n        return DataType.Tuple\n    elif isinstance(x, list):\n        return DataType.List\n    elif isinstance(x, dict):\n        return DataType.Dict\n    elif isinstance(x, set):\n        return DataType.Set\n    elif isinstance(x, type):\n        return DataType.Type\n    else:\n        return DataType.Unknown\n\n\ndef is_equal(x, y) -> tuple[bool, str]:\n    x_type, y_type = get_type(x), get_type(y)\n    if x_type != y_type:\n        return False, \"Type mismatch: {} vs {}\".format(str(x_type), str(y_type))\n\n    if x_type in [DataType.Int, DataType.Bool, DataType.Null, DataType.Str, DataType.Set, DataType.Type]:\n        if x == y:\n            return True, None\n        try:\n            error_msg = \"INT/BOOL/NULL/ Value mismatch: {} vs {}\".format(repr(x)[:300], repr(y)[:300])\n        except:\n            error_msg = \"Value mismatch: too large for display\"\n        return False, error_msg\n    elif x_type == DataType.Float:\n        if np.allclose(x, y, equal_nan=True, atol=1e-6): # guard against nan\n            return True, None\n        else:\n            return False, \"FLOAT Value mismatch: {} vs {}\".format(x, y)\n    elif x_type in [DataType.List, DataType.Tuple]:\n        if len(x) != len(y):\n            return False, \"Length mismatch: {} vs {}\".format(len(x), len(y))\n        for i in range(len(x)):\n            equal, msg = is_equal(x[i], y[i])\n            if not equal:\n                return False, msg\n        return True, None\n    elif x_type == DataType.Dict:\n        if len(x) != len(y):\n            return False, \"Length mismatch: {} vs {}\".format(len(x), len(y))\n        for k, v in x.items():\n            if k not in y:\n                return False, \"DICT Value mismatch: key {} in {} but not in {}\".format(k, x, y)\n            equal, msg = is_equal(v, y[k])\n            if not equal:\n                return False, msg\n        return True, None\n    else:\n        try:\n            if x == y:  # e.g., object comparison\n                return True, None\n            else:\n                return False, \"ELSE Value mismatch: {} vs {}\".format(x, y)\n        except:\n            return False, \"Unsupported type: {} <-- {}\".format(x_type, type(x))\n\ndef check(candidate):\n    inputs = [eval(f\"[{i}]\") for i in ['\"Mercury\", \"Uranus\"', '\"Earth\", \"Mercury\"', '\"Jupiter\", \"Neptune\"', \"'Neptune', 'Jupiter'\", \"'Venus', 'Mars'\", \"'Earth', 'Neptune'\", \"'Mars', 'Mercury'\", \"'Uranus', 'Venus'\", \"'Saturn', 'Earth'\", \"'Jupiter', 'Mercury'\", \"'Neptune', 'Earth'\", \"'Venus', 'Uranus'\", \"'NotAPlanet', 'Jupiter'\", \"'Mars', 'NotAPlanet'\", \"'NotAPlanet', 'NotAPlanet'\", \"'Mars', 'Earth'\", \"'Earth', 'Earth'\", \"'Neptune', 'Mercury'\", \"'Uranus', 'Mars'\", \"'Venus', 'Saturn'\", \"'Saturn', 'Neptune'\", \"'Uranus', 'Venus'\", \"'Jupiter', 'Mars'\", \"'Mars', 'Jupiter'\", \"'Venus', 'Mercury'\", \"'Mercury', 'Neptune'\", \"'Neptune', 'Venus'\", \"'Venus', 'Venus'\", \"'Neptune', 'Mercury'\", \"'Mars', 'Jupiter'\", \"'Mercury', 'Mercury'\", \"'NotAPlanet', 'Mars'\", \"'Earth', 'NotAPlanet'\", \"'NotAPlanet', 'NotAPlanet'\", \"'Earth', 'Neptune'\", \"'Mercury', 'Neptune'\", \"'Neptune', 'Uranus'\", \"'Uranus', 'Neptune'\", \"'Earth', 'Mars'\"]]\n    outputs = [10, 2, 5, 5, 2, 9, 4, 8, 4, 5, 9, 8, 0, 0, 0, 0, 0, 13, 5, 6, 3, 8, 0, 0, 0, 13, 11, 0, 13, 0, 0, 0, 0, 0, 9, 13, 0, 0, 0]\n    for i, (inp, exp) in enumerate(zip(inputs, outputs)):\n        exact_match, _ = is_equal(candidate(*inp), exp)\n        assert exact_match\n    ", "__internal_uuid__": "7452da3e-6908-4f37-8c73-e946768f41b8"}
{"canonical_solution": "\n    def count_consonants(name):\n        return sum(1 for c in name.lower() if c in 'bcdfghjklmnpqrstvwxyz')\n\n    def get_grade(gpa):\n        if gpa == 4.0:\n            return 'A+'\n        elif gpa > 3.7:\n            return 'A'\n        elif gpa > 3.3:\n            return 'A-'\n        elif gpa > 3.0:\n            return 'B+'\n        elif gpa > 2.7:\n            return 'B'\n        elif gpa > 2.3:\n            return 'B-'\n        elif gpa > 2.0:\n            return 'C+'\n        elif gpa > 1.7:\n            return 'C'\n        elif gpa > 1.3:\n            return 'C-'\n        elif gpa > 1.0:\n            return 'D+'\n        elif gpa > 0.7:\n            return 'D'\n        elif gpa > 0.0:\n            return 'D-'\n        else:\n            return 'E'\n\n    def bump_grade(grade):\n        if grade == 'A+':\n            return 'A+'\n        elif grade == 'A':\n            return 'A+'\n        elif grade == 'A-':\n            return 'A'\n        elif grade == 'B+':\n            return 'A-'\n        elif grade == 'B':\n            return 'B+'\n        elif grade == 'B-':\n            return 'B'\n        elif grade == 'C+':\n            return 'B-'\n        elif grade == 'C':\n            return 'C+'\n        elif grade == 'C-':\n            return 'C'\n        elif grade == 'D+':\n            return 'C-'\n        elif grade == 'D':\n            return 'D+'\n        elif grade == 'D-':\n            return 'D'\n        else:\n            return 'D-'\n\n    for student in student_info:\n        student['grade'] = get_grade(student['GPA'])\n        if count_consonants(student['name']) == n:\n            student['grade'] = bump_grade(student['grade'])\n        del student['GPA']\n\n    return student_info\n", "content": "\ndef grade_students(student_info, n):\n    \"\"\"You are a programming teacher and the semester is ending. You have a list of dictionaries, each containing \n    the name and GPA of a student. Additionally, you have a special grading system. Each student's name contributes \n    to their final grade based on the number of consonants in their name. If their name contains exactly n consonants,\n    their final grade gets bumped up one level according to the grading scale below:\n\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n\n    Write a function that takes the list of students and the number n and returns a list of dictionaries with each \n    student's name and their final letter grade. If the student name does not contain exactly n consonants, the grade \n    is not bumped up.\n\n    Example:\n    grade_students([{'name': 'Alice', 'GPA': 3.0}, {'name': 'Bob', 'GPA': 2.3}, {'name': 'Charlie', 'GPA': 3.3}], 2) \n    ==> [{'name': 'Alice', 'grade': 'B+'}, {'name': 'Bob', 'grade': 'B-'}, {'name': 'Charlie', 'grade': 'B+'}]\n    \"\"\"\n", "id": "EvoEval_combine_EvoEval/12", "labels": "{\"entry_point\":\"grade_students\"}", "test": "\nimport numpy as np\nfrom numpy import nan, inf # for some outputs.\nimport sys\n\nsys.set_int_max_str_digits(0)\n\nfrom enum import IntEnum, auto\n\ndef is_floats(x) -> bool:\n    # check if it is float; List[float]; Tuple[float]\n    # TODO: search for any close floats? (other data structures)\n    if isinstance(x, float):\n        return True\n    if isinstance(x, (list, tuple)):\n        return all(isinstance(i, float) for i in x)\n    if isinstance(x, np.ndarray):\n        return x.dtype == np.float64 or x.dtype == np.float32\n    return False\n\n\nclass DataType(IntEnum):\n    Float = auto()\n    Bool = auto()\n    Int = auto()\n    Str = auto()\n    Null = auto()\n    Tuple = auto()\n    List = auto()\n    Dict = auto()\n    Set = auto()\n    Type = auto()\n    Unknown = auto()\n\n\ndef get_type(x):\n    if x is None:\n        return DataType.Null\n    elif isinstance(x, bool):\n        return DataType.Bool\n    elif isinstance(x, int):\n        return DataType.Int\n    elif isinstance(x, str):\n        return DataType.Str\n    elif is_floats(x):\n        return DataType.Float\n    elif isinstance(x, tuple):\n        return DataType.Tuple\n    elif isinstance(x, list):\n        return DataType.List\n    elif isinstance(x, dict):\n        return DataType.Dict\n    elif isinstance(x, set):\n        return DataType.Set\n    elif isinstance(x, type):\n        return DataType.Type\n    else:\n        return DataType.Unknown\n\n\ndef is_equal(x, y) -> tuple[bool, str]:\n    x_type, y_type = get_type(x), get_type(y)\n    if x_type != y_type:\n        return False, \"Type mismatch: {} vs {}\".format(str(x_type), str(y_type))\n\n    if x_type in [DataType.Int, DataType.Bool, DataType.Null, DataType.Str, DataType.Set, DataType.Type]:\n        if x == y:\n            return True, None\n        try:\n            error_msg = \"INT/BOOL/NULL/ Value mismatch: {} vs {}\".format(repr(x)[:300], repr(y)[:300])\n        except:\n            error_msg = \"Value mismatch: too large for display\"\n        return False, error_msg\n    elif x_type == DataType.Float:\n        if np.allclose(x, y, equal_nan=True, atol=1e-6): # guard against nan\n            return True, None\n        else:\n            return False, \"FLOAT Value mismatch: {} vs {}\".format(x, y)\n    elif x_type in [DataType.List, DataType.Tuple]:\n        if len(x) != len(y):\n            return False, \"Length mismatch: {} vs {}\".format(len(x), len(y))\n        for i in range(len(x)):\n            equal, msg = is_equal(x[i], y[i])\n            if not equal:\n                return False, msg\n        return True, None\n    elif x_type == DataType.Dict:\n        if len(x) != len(y):\n            return False, \"Length mismatch: {} vs {}\".format(len(x), len(y))\n        for k, v in x.items():\n            if k not in y:\n                return False, \"DICT Value mismatch: key {} in {} but not in {}\".format(k, x, y)\n            equal, msg = is_equal(v, y[k])\n            if not equal:\n                return False, msg\n        return True, None\n    else:\n        try:\n            if x == y:  # e.g., object comparison\n                return True, None\n            else:\n                return False, \"ELSE Value mismatch: {} vs {}\".format(x, y)\n        except:\n            return False, \"Unsupported type: {} <-- {}\".format(x_type, type(x))\n\ndef check(candidate):\n    inputs = [eval(f\"[{i}]\") for i in [\"[{'name': 'Alice', 'GPA': 3.0}, {'name': 'Bob', 'GPA': 2.3}, {'name': 'Charlie', 'GPA': 3.3}, {'name': 'Dave', 'GPA': 0.0}, {'name': 'Eve', 'GPA': 0.0}], 2\", \"[{'name': 'Alice', 'GPA': 3.0}, {'name': 'Bob', 'GPA': 2.3}, {'name': 'Charlie', 'GPA': 3.3}], 2\", \"[{'name': 'Zoe', 'GPA': 4.0}, {'name': 'Yves', 'GPA': 3.7}, {'name': 'Xander', 'GPA': 3.3}, {'name': 'William', 'GPA': 3.0}, {'name': 'Violet', 'GPA': 2.7}, {'name': 'Ursula', 'GPA': 2.3}, {'name': 'Trevor', 'GPA': 2.0}, {'name': 'Samantha', 'GPA': 1.7}, {'name': 'Roger', 'GPA': 1.3}, {'name': 'Quincy', 'GPA': 1.0}, {'name': 'Pippa', 'GPA': 0.7}, {'name': 'Oliver', 'GPA': 0.0}], 3\", \"[{'name': 'Zoe', 'GPA': 4.0}, {'name': 'Yves', 'GPA': 3.7}, {'name': 'Xander', 'GPA': 3.3}, {'name': 'William', 'GPA': 3.0}, {'name': 'Violet', 'GPA': 2.7}], 2\", \"[{'name': 'Ursula', 'GPA': 2.3}, {'name': 'Trevor', 'GPA': 2.0}, {'name': 'Samantha', 'GPA': 1.7}, {'name': 'Roger', 'GPA': 1.3}, {'name': 'Quincy', 'GPA': 1.0}, {'name': 'Pippa', 'GPA': 0.7}, {'name': 'Oliver', 'GPA': 0.0}], 1\", \"[{'name': 'Quincy', 'GPA': 1.0}, {'name': 'Pippa', 'GPA': 0.7}, {'name': 'Oliver', 'GPA': 0.0}], 4\", \"[{'name': 'Bob', 'GPA': 3.7}, {'name': 'Charlie', 'GPA': 3.0}], 3\", \"[{'name': 'Alice', 'GPA': 3.0}, {'name': 'Bob', 'GPA': 2.3}, {'name': 'Charlie', 'GPA': 3.3}, {'name': 'Dave', 'GPA': 2.7}, {'name': 'Eve', 'GPA': 2.0}, {'name': 'Frank', 'GPA': 1.7}, {'name': 'Gary', 'GPA': 1.3}, {'name': 'Helen', 'GPA': 1.0}, {'name': 'Irene', 'GPA': 0.7}, {'name': 'Jack', 'GPA': 0.0}], 2\", \"[{'name': 'Bob', 'GPA': 3.3}, {'name': 'Dave', 'GPA': 2.7}, {'name': 'Gary', 'GPA': 1.7}, {'name': 'Jack', 'GPA': 0.0}], 2\", \"[{'name': 'Alice', 'GPA': 0.0}, {'name': 'Bob', 'GPA': 0.0}, {'name': 'Charlie', 'GPA': 0.0}, {'name': 'Dave', 'GPA': 0.0}, {'name': 'Eve', 'GPA': 0.0}], 2\", \"[{'name': 'Alice', 'GPA': 3.0}, {'name': 'Bob', 'GPA': 3.0}, {'name': 'Charlie', 'GPA': 3.0}], 3\", \"[{'name': 'Alice', 'GPA': 4.0}, {'name': 'Bob', 'GPA': 1.9}, {'name': 'Charlie', 'GPA': 0.6}], 3\", \"[{'name': 'Anna', 'GPA': 3.5}], 0\", \"[{'name': 'Billy', 'GPA': 2.8}, {'name': 'Samantha', 'GPA': 3.8}, {'name': 'Chris', 'GPA': 2.4}, {'name': 'Donna', 'GPA': 1.4}], 1\", \"[{'name': 'Eve', 'GPA': 3.0}], 5\", '[], 2', \"[{'name': 'Fred', 'GPA': 2.6}, {'name': 'Greg', 'GPA': 2.3}, {'name': 'Hannah', 'GPA': 3.3}, {'name': 'Igor', 'GPA': 1.2}, {'name': 'Jackie', 'GPA': 0.9}], 4\", \"[{'name': 'Karen', 'GPA': 1.9}, {'name': 'Liam', 'GPA': 0.3}, {'name': 'Mona', 'GPA': 3.7}], 2\", \"[{'name': 'Zap', 'GPA': 2.0}, {'name': 'Quantum', 'GPA': 2.7}, {'name': 'Xyzzy', 'GPA': 1.0}], 1\", \"[{'name': 'Alpha', 'GPA': 1.3}, {'name': 'Beta', 'GPA': 3.7}, {'name': 'Gamma', 'GPA': 1.7}, {'name': 'Delta', 'GPA': 2.3}], 2\", \"[{'name': 'Nash', 'GPA': 2.3}, {'name': 'Zed', 'GPA': 3.0}, {'name': 'Mick', 'GPA': 1.7}], 3\", \"[{'name': 'Skywalker', 'GPA': 3.0}, {'name': 'Darth Vader', 'GPA': 2.3}], 2\", \"[{'name': 'John Doe', 'GPA': 3.3}, {'name': 'Jane Doe', 'GPA': 2.0}], 3\", \"[{'name': 'A', 'GPA': 0.7}], 1\", '[], 2', \"[{'name': 'Charlie', 'GPA': 2.3}, {'name': 'Eve', 'GPA': 0.0}, {'name': 'Alice', 'GPA': 4.0}, {'name': 'Dave', 'GPA': 0.3}], 3\", \"[{'name': 'Zach', 'GPA': 3.7}, {'name': 'Yuri', 'GPA': 1.7}], 1\", \"[{'name': 'Xaver', 'GPA': 2.7}, {'name': 'Ulysses', 'GPA': 3.0}], 4\", \"[{'name': 'Trevor', 'GPA': 1.0}, {'name': 'Samantha', 'GPA': 1.3}, {'name': 'Rosalie', 'GPA': 0.0}, {'name': 'Quentin', 'GPA': 3.3}], 2\", \"[{'name': 'Penny', 'GPA': 2.3}], 3\", \"[{'name': 'Oliver', 'GPA': 3.0}, {'name': 'Nina', 'GPA': 2.0}, {'name': 'Melinda', 'GPA': 1.7}], 4\", \"[{'name': 'Liam', 'GPA': 2.7}, {'name': 'Kyle', 'GPA': 2.0}, {'name': 'Jillian', 'GPA': 1.3}, {'name': 'Isla', 'GPA': 1.0}], 1\", \"[{'name': 'Hannah', 'GPA': 4.0}, {'name': 'George', 'GPA': 3.7}], 2\", \"[{'name': 'Felicity', 'GPA': 3.3}, {'name': 'Edwin', 'GPA': 3.0}], 4\", \"[{'name': 'Diana', 'GPA': 2.3}, {'name': 'Calvin', 'GPA': 2.0}, {'name': 'Betty', 'GPA': 1.7}], 3\"]]\n    outputs = [[{'name': 'Alice', 'grade': 'B+'}, {'name': 'Bob', 'grade': 'B-'}, {'name': 'Charlie', 'grade': 'B+'}, {'name': 'Dave', 'grade': 'D-'}, {'name': 'Eve', 'grade': 'E'}], [{'name': 'Alice', 'grade': 'B+'}, {'name': 'Bob', 'grade': 'B-'}, {'name': 'Charlie', 'grade': 'B+'}], [{'name': 'Zoe', 'grade': 'A+'}, {'name': 'Yves', 'grade': 'A'}, {'name': 'Xander', 'grade': 'B+'}, {'name': 'William', 'grade': 'B'}, {'name': 'Violet', 'grade': 'B'}, {'name': 'Ursula', 'grade': 'B-'}, {'name': 'Trevor', 'grade': 'C'}, {'name': 'Samantha', 'grade': 'C-'}, {'name': 'Roger', 'grade': 'C-'}, {'name': 'Quincy', 'grade': 'D'}, {'name': 'Pippa', 'grade': 'D'}, {'name': 'Oliver', 'grade': 'D-'}], [{'name': 'Zoe', 'grade': 'A+'}, {'name': 'Yves', 'grade': 'A-'}, {'name': 'Xander', 'grade': 'B+'}, {'name': 'William', 'grade': 'B'}, {'name': 'Violet', 'grade': 'B-'}], [{'name': 'Ursula', 'grade': 'C+'}, {'name': 'Trevor', 'grade': 'C'}, {'name': 'Samantha', 'grade': 'C-'}, {'name': 'Roger', 'grade': 'D+'}, {'name': 'Quincy', 'grade': 'D'}, {'name': 'Pippa', 'grade': 'D-'}, {'name': 'Oliver', 'grade': 'E'}], [{'name': 'Quincy', 'grade': 'D+'}, {'name': 'Pippa', 'grade': 'D-'}, {'name': 'Oliver', 'grade': 'E'}], [{'name': 'Bob', 'grade': 'A-'}, {'name': 'Charlie', 'grade': 'B'}], [{'name': 'Alice', 'grade': 'B+'}, {'name': 'Bob', 'grade': 'B-'}, {'name': 'Charlie', 'grade': 'B+'}, {'name': 'Dave', 'grade': 'B'}, {'name': 'Eve', 'grade': 'C'}, {'name': 'Frank', 'grade': 'C-'}, {'name': 'Gary', 'grade': 'D+'}, {'name': 'Helen', 'grade': 'D'}, {'name': 'Irene', 'grade': 'D'}, {'name': 'Jack', 'grade': 'E'}], [{'name': 'Bob', 'grade': 'A-'}, {'name': 'Dave', 'grade': 'B'}, {'name': 'Gary', 'grade': 'C-'}, {'name': 'Jack', 'grade': 'E'}], [{'name': 'Alice', 'grade': 'D-'}, {'name': 'Bob', 'grade': 'D-'}, {'name': 'Charlie', 'grade': 'E'}, {'name': 'Dave', 'grade': 'D-'}, {'name': 'Eve', 'grade': 'E'}], [{'name': 'Alice', 'grade': 'B'}, {'name': 'Bob', 'grade': 'B'}, {'name': 'Charlie', 'grade': 'B'}], [{'name': 'Alice', 'grade': 'A+'}, {'name': 'Bob', 'grade': 'C'}, {'name': 'Charlie', 'grade': 'D-'}], [{'name': 'Anna', 'grade': 'A-'}], [{'name': 'Billy', 'grade': 'B'}, {'name': 'Samantha', 'grade': 'A'}, {'name': 'Chris', 'grade': 'B-'}, {'name': 'Donna', 'grade': 'C-'}], [{'name': 'Eve', 'grade': 'B'}], [], [{'name': 'Fred', 'grade': 'B-'}, {'name': 'Greg', 'grade': 'C+'}, {'name': 'Hannah', 'grade': 'A-'}, {'name': 'Igor', 'grade': 'D+'}, {'name': 'Jackie', 'grade': 'D'}], [{'name': 'Karen', 'grade': 'C'}, {'name': 'Liam', 'grade': 'D'}, {'name': 'Mona', 'grade': 'A'}], [{'name': 'Zap', 'grade': 'C'}, {'name': 'Quantum', 'grade': 'B-'}, {'name': 'Xyzzy', 'grade': 'D'}], [{'name': 'Alpha', 'grade': 'D+'}, {'name': 'Beta', 'grade': 'A'}, {'name': 'Gamma', 'grade': 'C-'}, {'name': 'Delta', 'grade': 'C+'}], [{'name': 'Nash', 'grade': 'B-'}, {'name': 'Zed', 'grade': 'B'}, {'name': 'Mick', 'grade': 'C'}], [{'name': 'Skywalker', 'grade': 'B'}, {'name': 'Darth Vader', 'grade': 'C+'}], [{'name': 'John Doe', 'grade': 'B+'}, {'name': 'Jane Doe', 'grade': 'C+'}], [{'name': 'A', 'grade': 'D-'}], [], [{'name': 'Charlie', 'grade': 'C+'}, {'name': 'Eve', 'grade': 'E'}, {'name': 'Alice', 'grade': 'A+'}, {'name': 'Dave', 'grade': 'D-'}], [{'name': 'Zach', 'grade': 'A-'}, {'name': 'Yuri', 'grade': 'C-'}], [{'name': 'Xaver', 'grade': 'B-'}, {'name': 'Ulysses', 'grade': 'B'}], [{'name': 'Trevor', 'grade': 'D'}, {'name': 'Samantha', 'grade': 'D+'}, {'name': 'Rosalie', 'grade': 'E'}, {'name': 'Quentin', 'grade': 'B+'}], [{'name': 'Penny', 'grade': 'C+'}], [{'name': 'Oliver', 'grade': 'B'}, {'name': 'Nina', 'grade': 'C'}, {'name': 'Melinda', 'grade': 'C'}], [{'name': 'Liam', 'grade': 'B-'}, {'name': 'Kyle', 'grade': 'C'}, {'name': 'Jillian', 'grade': 'D+'}, {'name': 'Isla', 'grade': 'D'}], [{'name': 'Hannah', 'grade': 'A+'}, {'name': 'George', 'grade': 'A-'}], [{'name': 'Felicity', 'grade': 'B+'}, {'name': 'Edwin', 'grade': 'B'}], [{'name': 'Diana', 'grade': 'C+'}, {'name': 'Calvin', 'grade': 'C'}, {'name': 'Betty', 'grade': 'C-'}]]\n    for i, (inp, exp) in enumerate(zip(inputs, outputs)):\n        exact_match, _ = is_equal(candidate(*inp), exp)\n        assert exact_match\n    ", "__internal_uuid__": "65fbcee4-bf11-445e-bf87-85780978db69"}
{"canonical_solution": "\n    def judge(x: int) -> int:\n        l = list(str(x))\n        if l[0] == \"-\":\n            l = l[1:]\n            l = list(map(int, l))\n            l[0] = -l[0]\n        else:\n            l = list(map(int, l))\n        return 1 if sum(l) > 0 else 0\n    # Filter the array to keep only the numbers which have a sum of digits > 0\n    arr = [num for num in arr if judge(num)]\n    \n    # Create a list of even numbers from the filtered array\n    even_nums = [num for num in arr if num % 2 == 0]\n    \n    # Create a list of odd numbers from lst1\n    odd_nums = [num for num in lst1 if num % 2 != 0]\n    \n    # If there are more odd numbers in lst1 than even numbers in the filtered array, return no\n    if len(odd_nums) > len(even_nums):\n        return \"NO\"\n    \n    return \"YES\"\n", "content": "def filter_exchange(arr, lst1):\n    \"\"\"\n    Write a function `filter_exchange` that takes three parameters: an array of integers `arr` and a list of numbers `lst1`.\n    The function should first filter the `arr` array to keep only the numbers which have a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    \n    After filtering the array, the function should determine whether it is possible to perform an exchange of elements \n    between the filtered array and `lst1` to make `lst1` a list of only even numbers. \n    There is no limit on the number of exchanged elements between the filtered array and `lst1`.\n\n    If it is possible to exchange elements between the filtered array and `lst1` to make all the elements of `lst1` to be even, \n    return \"YES\". Otherwise, return \"NO\".\n\n    For example:\n    filter_exchange([-1, 11, -11, 6], [1, 2, 3, 4]) => NO\n    filter_exchange([1, 1, 2, 2], [1, 2, 3, 4]) => YES\n    filter_exchange([], [1, 2, 3, 4]) => NO\n    \"\"\"", "id": "EvoEval_combine_EvoEval/13", "labels": "{\"entry_point\":\"filter_exchange\"}", "test": "\nimport numpy as np\nfrom numpy import nan, inf # for some outputs.\nimport sys\n\nsys.set_int_max_str_digits(0)\n\nfrom enum import IntEnum, auto\n\ndef is_floats(x) -> bool:\n    # check if it is float; List[float]; Tuple[float]\n    # TODO: search for any close floats? (other data structures)\n    if isinstance(x, float):\n        return True\n    if isinstance(x, (list, tuple)):\n        return all(isinstance(i, float) for i in x)\n    if isinstance(x, np.ndarray):\n        return x.dtype == np.float64 or x.dtype == np.float32\n    return False\n\n\nclass DataType(IntEnum):\n    Float = auto()\n    Bool = auto()\n    Int = auto()\n    Str = auto()\n    Null = auto()\n    Tuple = auto()\n    List = auto()\n    Dict = auto()\n    Set = auto()\n    Type = auto()\n    Unknown = auto()\n\n\ndef get_type(x):\n    if x is None:\n        return DataType.Null\n    elif isinstance(x, bool):\n        return DataType.Bool\n    elif isinstance(x, int):\n        return DataType.Int\n    elif isinstance(x, str):\n        return DataType.Str\n    elif is_floats(x):\n        return DataType.Float\n    elif isinstance(x, tuple):\n        return DataType.Tuple\n    elif isinstance(x, list):\n        return DataType.List\n    elif isinstance(x, dict):\n        return DataType.Dict\n    elif isinstance(x, set):\n        return DataType.Set\n    elif isinstance(x, type):\n        return DataType.Type\n    else:\n        return DataType.Unknown\n\n\ndef is_equal(x, y) -> tuple[bool, str]:\n    x_type, y_type = get_type(x), get_type(y)\n    if x_type != y_type:\n        return False, \"Type mismatch: {} vs {}\".format(str(x_type), str(y_type))\n\n    if x_type in [DataType.Int, DataType.Bool, DataType.Null, DataType.Str, DataType.Set, DataType.Type]:\n        if x == y:\n            return True, None\n        try:\n            error_msg = \"INT/BOOL/NULL/ Value mismatch: {} vs {}\".format(repr(x)[:300], repr(y)[:300])\n        except:\n            error_msg = \"Value mismatch: too large for display\"\n        return False, error_msg\n    elif x_type == DataType.Float:\n        if np.allclose(x, y, equal_nan=True, atol=1e-6): # guard against nan\n            return True, None\n        else:\n            return False, \"FLOAT Value mismatch: {} vs {}\".format(x, y)\n    elif x_type in [DataType.List, DataType.Tuple]:\n        if len(x) != len(y):\n            return False, \"Length mismatch: {} vs {}\".format(len(x), len(y))\n        for i in range(len(x)):\n            equal, msg = is_equal(x[i], y[i])\n            if not equal:\n                return False, msg\n        return True, None\n    elif x_type == DataType.Dict:\n        if len(x) != len(y):\n            return False, \"Length mismatch: {} vs {}\".format(len(x), len(y))\n        for k, v in x.items():\n            if k not in y:\n                return False, \"DICT Value mismatch: key {} in {} but not in {}\".format(k, x, y)\n            equal, msg = is_equal(v, y[k])\n            if not equal:\n                return False, msg\n        return True, None\n    else:\n        try:\n            if x == y:  # e.g., object comparison\n                return True, None\n            else:\n                return False, \"ELSE Value mismatch: {} vs {}\".format(x, y)\n        except:\n            return False, \"Unsupported type: {} <-- {}\".format(x_type, type(x))\n\ndef check(candidate):\n    inputs = [eval(f\"[{i}]\") for i in ['[1, 1, -122, 2], [1, 2, 3, 4]', '[1, 1, -121, 2], [1, 2, 3, 4]', '[1, 1, -21, 2], [1, 2, 3, 4]', '[], [2, 0, 4]', '[], [1, 2, 3, 4]', '[1, 1, 2, 2], [1, 2, 3, 4]', '[-1, 11, -11, 6], [1, 2, 3, 4]', '[12, -34, 56, -78, 90], [1, 3, 5, 7, 9]', '[0], [0]', '[-100, -200, -300, -400, -500], [0, 1, 2, 3, 4, 5]', '[10, 20, -30, 40, 50], [1, 2, 3, 4, 5]', '[11111, 22222, 33333, 44444, 55555], [2, 3, 4, 5, 6]', '[-1, 2, -3, 4, -5], [1, 1, 1, 1, 1]', '[1, -2, 3, -4, 5], [2, 2, 2, 2, 2]', '[0, -1, 2, -3, 4], [1, 3, 5, 7, 9]', '[1, 1, 1, -1, -1, -1, 2, 2, 2, -2, -2, -2], [1, 3, 5, 7, 9]', '[0, -111, 55, 999], [1, 3, 5, 7, 9]', '[1, 11, 111, 1111], [2, 4, 6, 8, 10]', '[-99, -888, -7777, -6666], [1, 3, 5, 7, 9]', '[1, 1, 2, 3], [2, 3, 4, 5, 6, 7, 8, 9, 10]', '[-1, -100, -1000, -10000], [0, 2, 4, 6, 8]', '[2, 4, 6, 8], [1, 3, 5, 7]', '[0, 0, 0, 0], [1, 1, 1, 1]', '[1, 3, 5, 7], [2, 4, 6, 8]', '[-1, -3, -5, -7], [2, 4, 6, 8]', '[1, 4, 7, 10], [2, 5, 8]', '[1, -111, 121, -222], [1, 3, 5, 7]', '[10, 20, -30, 40, -50, 60, 70], [1, 3, 5, 7, 9, 11, 13]', '[-111, 222, -333, 444, -555], [2, 4, 6, 8, 10]', '[12345, -67890, 23456, -78901], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]', '[11, 22, 33, 44, 55, 66, 77, 88, 99], [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]', '[0, -100, 200, -300, 400, -500], [2, 4, 6, 8, 10, 12, 14, 16, 18]', '[1, 1, -10000, 2], [1, 3, 5, 7, 9, 11, 13, 15]', '[-1, -2, -3], [1, 3, 5]', '[0, 0, 0], [1, 3, 5]', '[2, 4, 6], [2, 4, 6]', '[1], [2]', '[-1], [1]', '[0], [1]', '[2], [2]', '[-1, 0, 1, 2, -22, 33, -44, 55, -66, 77, -88, 99], [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]', '[12345, -23456, 34567, -45678, 56789, -67890, -78901, 89012, -90123], [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]', '[11111, -22222, 33333, -44444, 55555, -66666, 77777, -88888, 99999], [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]', '[10, -20, 30, -40, 50, -60, 70, -80, 90], [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]', '[11, -22, 33, -44, 55, -66, 77, -88, 99], [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]', '[100, -200, 300, -400, 500, -600, 700, -800, 900], [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]', '[1, -2, 3, -4, 5, -6, 7, -8, 9, -10], [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]']]\n    outputs = ['YES', 'NO', 'NO', 'YES', 'NO', 'YES', 'NO', 'YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'YES', 'NO', 'NO', 'NO', 'YES', 'NO', 'NO', 'YES', 'YES', 'NO', 'YES', 'YES', 'YES', 'NO', 'NO', 'YES', 'NO', 'NO', 'YES', 'NO', 'NO', 'NO', 'YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'NO', 'YES', 'NO', 'YES', 'NO', 'YES']\n    for i, (inp, exp) in enumerate(zip(inputs, outputs)):\n        exact_match, _ = is_equal(candidate(*inp), exp)\n        assert exact_match\n    ", "__internal_uuid__": "7e7303c1-39fb-4c0f-89a2-bb521cb67c14"}
{"canonical_solution": "\n    if n > m:\n        return -1\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    primes = [i for i in range(n, m+1) if is_prime(i)]\n    if not primes:\n        return -1\n\n    avg = round(sum(primes) / len(primes))\n    return bin(avg)\n", "content": "\ndef prime_avg_range(n, m):\n    \"\"\"You are given two positive integers n and m. Your task is to create a list of all \n    prime numbers between n and m (inclusive), compute the average of these prime numbers, \n    round the answer to the nearest integer, and convert that to binary. \n    If there are no prime numbers in the range or if n is greater than m, return -1.\n    Example:\n    prime_avg_range(1, 5) => \"0b11\"\n    prime_avg_range(7, 11) => \"0b1001\"\n    prime_avg_range(20, 30) => \"0b11010\"\n    prime_avg_range(15, 10) => -1\n    prime_avg_range(10, 10) => -1\n    \"\"\"\n", "id": "EvoEval_combine_EvoEval/14", "labels": "{\"entry_point\":\"prime_avg_range\"}", "test": "\nimport numpy as np\nfrom numpy import nan, inf # for some outputs.\nimport sys\n\nsys.set_int_max_str_digits(0)\n\nfrom enum import IntEnum, auto\n\ndef is_floats(x) -> bool:\n    # check if it is float; List[float]; Tuple[float]\n    # TODO: search for any close floats? (other data structures)\n    if isinstance(x, float):\n        return True\n    if isinstance(x, (list, tuple)):\n        return all(isinstance(i, float) for i in x)\n    if isinstance(x, np.ndarray):\n        return x.dtype == np.float64 or x.dtype == np.float32\n    return False\n\n\nclass DataType(IntEnum):\n    Float = auto()\n    Bool = auto()\n    Int = auto()\n    Str = auto()\n    Null = auto()\n    Tuple = auto()\n    List = auto()\n    Dict = auto()\n    Set = auto()\n    Type = auto()\n    Unknown = auto()\n\n\ndef get_type(x):\n    if x is None:\n        return DataType.Null\n    elif isinstance(x, bool):\n        return DataType.Bool\n    elif isinstance(x, int):\n        return DataType.Int\n    elif isinstance(x, str):\n        return DataType.Str\n    elif is_floats(x):\n        return DataType.Float\n    elif isinstance(x, tuple):\n        return DataType.Tuple\n    elif isinstance(x, list):\n        return DataType.List\n    elif isinstance(x, dict):\n        return DataType.Dict\n    elif isinstance(x, set):\n        return DataType.Set\n    elif isinstance(x, type):\n        return DataType.Type\n    else:\n        return DataType.Unknown\n\n\ndef is_equal(x, y) -> tuple[bool, str]:\n    x_type, y_type = get_type(x), get_type(y)\n    if x_type != y_type:\n        return False, \"Type mismatch: {} vs {}\".format(str(x_type), str(y_type))\n\n    if x_type in [DataType.Int, DataType.Bool, DataType.Null, DataType.Str, DataType.Set, DataType.Type]:\n        if x == y:\n            return True, None\n        try:\n            error_msg = \"INT/BOOL/NULL/ Value mismatch: {} vs {}\".format(repr(x)[:300], repr(y)[:300])\n        except:\n            error_msg = \"Value mismatch: too large for display\"\n        return False, error_msg\n    elif x_type == DataType.Float:\n        if np.allclose(x, y, equal_nan=True, atol=1e-6): # guard against nan\n            return True, None\n        else:\n            return False, \"FLOAT Value mismatch: {} vs {}\".format(x, y)\n    elif x_type in [DataType.List, DataType.Tuple]:\n        if len(x) != len(y):\n            return False, \"Length mismatch: {} vs {}\".format(len(x), len(y))\n        for i in range(len(x)):\n            equal, msg = is_equal(x[i], y[i])\n            if not equal:\n                return False, msg\n        return True, None\n    elif x_type == DataType.Dict:\n        if len(x) != len(y):\n            return False, \"Length mismatch: {} vs {}\".format(len(x), len(y))\n        for k, v in x.items():\n            if k not in y:\n                return False, \"DICT Value mismatch: key {} in {} but not in {}\".format(k, x, y)\n            equal, msg = is_equal(v, y[k])\n            if not equal:\n                return False, msg\n        return True, None\n    else:\n        try:\n            if x == y:  # e.g., object comparison\n                return True, None\n            else:\n                return False, \"ELSE Value mismatch: {} vs {}\".format(x, y)\n        except:\n            return False, \"Unsupported type: {} <-- {}\".format(x_type, type(x))\n\ndef check(candidate):\n    inputs = [eval(f\"[{i}]\") for i in ['10, 10', '15, 10', '20, 30', '7, 11', '1, 5', '5, 5', '0, 0', '3, 3', '3, 7', '7, 7', '100, 1000', '50, 50', '1, 1', '2, 2', '-10, 0', '-3, 7', '7, -3', '0, -5', '1, 100', '1000, 2000', '10000, 20000', '1, 1', '2, 2', '3, 3', '7919, 7919', '104729, 104729', '999983, 999983', '999983, 1000000', '7919, 104729', '1, 7919', '999980, 1000000', '999900, 1000000', '999800, 1000000', '999700, 1000000', '0, 0', '1, 1', '1, 0', '0, 100', '100, 101', '101, 102', '102, 102', '999, 1001', '-10, 10', '10, -10', '-10, -10', '1, 1', '2, 2', '0, 10', '10, 0', '-5, 5', '5, -5', '-10, -1', '10, 100', '100, 1000', '1000, 10000', '0, 0', '-1, 10', '10, -1', '2, 2', '2, 3', '10, 100', '50, 100', '97, 100', '1, 1', '20, 19', '100, 1000', '10000, 1000']]\n    outputs = [-1, -1, '0b11010', '0b1001', '0b11', '0b101', -1, '0b11', '0b101', '0b111', '0b1000001101', -1, -1, '0b10', -1, '0b100', -1, -1, '0b101010', '0b10111010000', '0b11101001011110', -1, '0b10', '0b11', '0b1111011101111', '0b11001100100011001', '0b11110100001000101111', '0b11110100001000101111', '0b1101010110111011', '0b111001100011', '0b11110100001000101111', '0b11110100001000001101', '0b11110100000111101100', '0b11110100000110110101', -1, -1, -1, '0b101010', '0b1100101', '0b1100101', -1, -1, '0b100', -1, -1, -1, '0b10', '0b100', -1, '0b11', -1, -1, '0b110010', '0b1000001101', '0b1010011010111', -1, '0b100', -1, '0b10', '0b10', '0b110010', '0b1001001', '0b1100001', -1, -1, '0b1000001101', -1]\n    for i, (inp, exp) in enumerate(zip(inputs, outputs)):\n        exact_match, _ = is_equal(candidate(*inp), exp)\n        assert exact_match\n    ", "__internal_uuid__": "03606f11-6938-4994-9fc6-7e604d0b3953"}
{"canonical_solution": "\n    balance = 0\n    zero_count = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return False\n        if balance == 0:\n            zero_count += 1\n    return zero_count >= 3\n", "content": "from typing import List\n\ndef balance_triples(operations: List[int]) -> bool:\n    \"\"\"\n    balance_triples takes a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. It returns True if there are at least three distinct points in time where the balance of account sums to zero (excluding the initial balance), \n    and False otherwise. If at any point the balance of account falls below zero, function should immediately return False.\n    \n    >>> balance_triples([1, -1, 2, -2, 3, -3])\n    True\n    >>> balance_triples([1, 2, 3, -6])\n    False\n    >>> balance_triples([1, 2, -4, 5])\n    False\n    >>> balance_triples([2, -2, 3, -3, 4, -4])\n    True\n    >>> balance_triples([1, -1, 2])\n    False\n    \"\"\"", "id": "EvoEval_combine_EvoEval/15", "labels": "{\"entry_point\":\"balance_triples\"}", "test": "\nimport numpy as np\nfrom numpy import nan, inf # for some outputs.\nimport sys\n\nsys.set_int_max_str_digits(0)\n\nfrom enum import IntEnum, auto\n\ndef is_floats(x) -> bool:\n    # check if it is float; List[float]; Tuple[float]\n    # TODO: search for any close floats? (other data structures)\n    if isinstance(x, float):\n        return True\n    if isinstance(x, (list, tuple)):\n        return all(isinstance(i, float) for i in x)\n    if isinstance(x, np.ndarray):\n        return x.dtype == np.float64 or x.dtype == np.float32\n    return False\n\n\nclass DataType(IntEnum):\n    Float = auto()\n    Bool = auto()\n    Int = auto()\n    Str = auto()\n    Null = auto()\n    Tuple = auto()\n    List = auto()\n    Dict = auto()\n    Set = auto()\n    Type = auto()\n    Unknown = auto()\n\n\ndef get_type(x):\n    if x is None:\n        return DataType.Null\n    elif isinstance(x, bool):\n        return DataType.Bool\n    elif isinstance(x, int):\n        return DataType.Int\n    elif isinstance(x, str):\n        return DataType.Str\n    elif is_floats(x):\n        return DataType.Float\n    elif isinstance(x, tuple):\n        return DataType.Tuple\n    elif isinstance(x, list):\n        return DataType.List\n    elif isinstance(x, dict):\n        return DataType.Dict\n    elif isinstance(x, set):\n        return DataType.Set\n    elif isinstance(x, type):\n        return DataType.Type\n    else:\n        return DataType.Unknown\n\n\ndef is_equal(x, y) -> tuple[bool, str]:\n    x_type, y_type = get_type(x), get_type(y)\n    if x_type != y_type:\n        return False, \"Type mismatch: {} vs {}\".format(str(x_type), str(y_type))\n\n    if x_type in [DataType.Int, DataType.Bool, DataType.Null, DataType.Str, DataType.Set, DataType.Type]:\n        if x == y:\n            return True, None\n        try:\n            error_msg = \"INT/BOOL/NULL/ Value mismatch: {} vs {}\".format(repr(x)[:300], repr(y)[:300])\n        except:\n            error_msg = \"Value mismatch: too large for display\"\n        return False, error_msg\n    elif x_type == DataType.Float:\n        if np.allclose(x, y, equal_nan=True, atol=1e-6): # guard against nan\n            return True, None\n        else:\n            return False, \"FLOAT Value mismatch: {} vs {}\".format(x, y)\n    elif x_type in [DataType.List, DataType.Tuple]:\n        if len(x) != len(y):\n            return False, \"Length mismatch: {} vs {}\".format(len(x), len(y))\n        for i in range(len(x)):\n            equal, msg = is_equal(x[i], y[i])\n            if not equal:\n                return False, msg\n        return True, None\n    elif x_type == DataType.Dict:\n        if len(x) != len(y):\n            return False, \"Length mismatch: {} vs {}\".format(len(x), len(y))\n        for k, v in x.items():\n            if k not in y:\n                return False, \"DICT Value mismatch: key {} in {} but not in {}\".format(k, x, y)\n            equal, msg = is_equal(v, y[k])\n            if not equal:\n                return False, msg\n        return True, None\n    else:\n        try:\n            if x == y:  # e.g., object comparison\n                return True, None\n            else:\n                return False, \"ELSE Value mismatch: {} vs {}\".format(x, y)\n        except:\n            return False, \"Unsupported type: {} <-- {}\".format(x_type, type(x))\n\ndef check(candidate):\n    inputs = [eval(f\"[{i}]\") for i in ['[1, -1, 2]', '[2, -2, 3, -3, 4, -4]', '[1, 2, -4, 5]', '[1, 2, 3, -6]', '[1, -1, 2, -2, 3, -3]', '[4, -4, 5, -5, 1, -1, 2, -2, 3, -3]', '[4, -4, 5, 2, -3, 1, -2, 3, -5]', '[1, -1, 1, -1, 1, -1, 1]', '[1, 2, 3, 4, 5, -15]', '[5, -5, 6, -6, 7, -7, 8, -8, -1]', '[1, -2, 3, -4, 5, -6]', '[2, -2, 2, -2, 2, -2, 2]', '[10, -10, 20, -20, 30, -30, 40, -40]', '[100, -100, -200, 300, -400, 500, -200, 100, -100, 200, -300, 400, -500, 200]', '[1, 2, 3, 4, 5, 6, -21]', '[1, -1, 1, -1, 1, -1]', '[2, -2, 2, -1, 1]', '[3, -3, 3, -3, 3, -3]', '[]', '[1]', '[-1]', '[0, 0, 0]', '[1, 1, 1, -3, 1, 1, 1, -3, 1, 1, 1, -3]', '[1, 2, 3, 4, -10]', '[5, -5, 5, -5, 5, -5, 5]', '[10, -10, 10, -10, 10, -10]', '[1, -1, 2, -2, 3, -3, 4, -6]', '[1, 1, 1, -2, -1]', '[1, -1, 2, -2, 3, -3, 4]', '[5, -5, 7, -7, 10, -10]', '[2, 3, 4, -9, 1, -1]', '[1, 1, 1, -3, 2, 2, 2, -6, 3, 3, 3, -9]', '[10, -10, 20, -20, 30, -30, 40, -40]', '[2, -2, 3, -3, 4, -4, 5, -5, 6, -6]', '[1, 2, 3, 4, -10, 5, -5]', '[3, 4, 5, -12, 6, -6, 7, -7]', '[1, 2, 3, 4, 5, 6, -21]', '[1, -1, 2, -2, 3, -3, 4, -4, 5, -5]', '[]', '[1]', '[-1]', '[1, -1, 0]', '[1, -1, 0, 2, -2]', '[1, 2, -3]', '[0, 0, 0]', '[1, 2, 3, -1, -2]', '[1000000, -1000000, 2000000, -2000000, 3000000, -3000000]', '[1.5, -1.5, 2.5, -2.5, 3.5, -3.5]', '[1, 2, 3, 4, -5, 6, -7, 8, -9, 10, -10, 1, -1, 2, -2]', '[1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1]', '[100, 200, 300, -600, 400, 500, -900]', '[1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6, 7, -7]', '[100, -200, 300, -400, 500, -600, 700, -800, 900, -1000]', '[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -12]', '[10, -20, 30, -40, 50, -60, 70, -80, 90, -100]', '[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]', '[]', '[1, -2, 3, -4, 5, -6, 7, -8, 9, -10]']]\n    outputs = [False, True, False, False, True, True, False, True, False, False, False, True, True, False, False, True, False, True, False, False, False, True, True, False, True, True, False, False, True, True, False, True, True, True, False, True, False, True, False, False, False, False, True, False, True, False, True, True, False, True, False, True, False, False, False, False, False, False]\n    for i, (inp, exp) in enumerate(zip(inputs, outputs)):\n        exact_match, _ = is_equal(candidate(*inp), exp)\n        assert exact_match\n    ", "__internal_uuid__": "50f66aaf-2568-4979-999c-15440c9fcdd4"}
{"canonical_solution": "    vowels = \"aeiouAEIOU\"\n    consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    music_notes = music_string.split()\n    notes = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    result = []\n    for i in range(len(word) - 1, 0, -1):\n        if (\n            word[i] in vowels\n            and word[i - 1] in consonants\n            and word[i + 1] in consonants\n        ):\n            result = [notes[x] for x in music_notes[: i + 1]]\n            break\n    return result", "content": "def get_music_notes(word: str, music_string: str):\n    \"\"\"\n    You are given two inputs: a word and a music string. Your task is to find the closest vowel that stands\n    between two consonants from the right side of the word (case sensitive) and then find the corresponding\n    beats in the music string up to the closest vowel (inclusive).\n\n    Vowels in the beginning and ending doesn't count. Return empty list if you didn't find any vowel met the\n    above condition.\n\n    The music string represents musical notes in a special ASCII format.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    Each letter in the word corresponds to a note in the music string, from left to right.\n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    get_music_notes(\"yogurt\", \"o o| .| o| o| .| .| .| .| o o\") ==> [4, 2, 1, 2]\n    get_music_notes(\"FULL\", \"o o| .| o| o| .| .| .| .| o o\") ==> [4, 2]\n    get_music_notes(\"quick\", \"o o| .| o| o| .| .| .| .| o o\") ==> []\n    get_music_notes(\"ab\", \"o o| .| o| o| .| .| .| .| o o\") ==> []\n    \"\"\"", "id": "EvoEval_combine_EvoEval/16", "labels": "{\"entry_point\":\"get_music_notes\"}", "test": "\nimport numpy as np\nfrom numpy import nan, inf # for some outputs.\nimport sys\n\nsys.set_int_max_str_digits(0)\n\nfrom enum import IntEnum, auto\n\ndef is_floats(x) -> bool:\n    # check if it is float; List[float]; Tuple[float]\n    # TODO: search for any close floats? (other data structures)\n    if isinstance(x, float):\n        return True\n    if isinstance(x, (list, tuple)):\n        return all(isinstance(i, float) for i in x)\n    if isinstance(x, np.ndarray):\n        return x.dtype == np.float64 or x.dtype == np.float32\n    return False\n\n\nclass DataType(IntEnum):\n    Float = auto()\n    Bool = auto()\n    Int = auto()\n    Str = auto()\n    Null = auto()\n    Tuple = auto()\n    List = auto()\n    Dict = auto()\n    Set = auto()\n    Type = auto()\n    Unknown = auto()\n\n\ndef get_type(x):\n    if x is None:\n        return DataType.Null\n    elif isinstance(x, bool):\n        return DataType.Bool\n    elif isinstance(x, int):\n        return DataType.Int\n    elif isinstance(x, str):\n        return DataType.Str\n    elif is_floats(x):\n        return DataType.Float\n    elif isinstance(x, tuple):\n        return DataType.Tuple\n    elif isinstance(x, list):\n        return DataType.List\n    elif isinstance(x, dict):\n        return DataType.Dict\n    elif isinstance(x, set):\n        return DataType.Set\n    elif isinstance(x, type):\n        return DataType.Type\n    else:\n        return DataType.Unknown\n\n\ndef is_equal(x, y) -> tuple[bool, str]:\n    x_type, y_type = get_type(x), get_type(y)\n    if x_type != y_type:\n        return False, \"Type mismatch: {} vs {}\".format(str(x_type), str(y_type))\n\n    if x_type in [DataType.Int, DataType.Bool, DataType.Null, DataType.Str, DataType.Set, DataType.Type]:\n        if x == y:\n            return True, None\n        try:\n            error_msg = \"INT/BOOL/NULL/ Value mismatch: {} vs {}\".format(repr(x)[:300], repr(y)[:300])\n        except:\n            error_msg = \"Value mismatch: too large for display\"\n        return False, error_msg\n    elif x_type == DataType.Float:\n        if np.allclose(x, y, equal_nan=True, atol=1e-6): # guard against nan\n            return True, None\n        else:\n            return False, \"FLOAT Value mismatch: {} vs {}\".format(x, y)\n    elif x_type in [DataType.List, DataType.Tuple]:\n        if len(x) != len(y):\n            return False, \"Length mismatch: {} vs {}\".format(len(x), len(y))\n        for i in range(len(x)):\n            equal, msg = is_equal(x[i], y[i])\n            if not equal:\n                return False, msg\n        return True, None\n    elif x_type == DataType.Dict:\n        if len(x) != len(y):\n            return False, \"Length mismatch: {} vs {}\".format(len(x), len(y))\n        for k, v in x.items():\n            if k not in y:\n                return False, \"DICT Value mismatch: key {} in {} but not in {}\".format(k, x, y)\n            equal, msg = is_equal(v, y[k])\n            if not equal:\n                return False, msg\n        return True, None\n    else:\n        try:\n            if x == y:  # e.g., object comparison\n                return True, None\n            else:\n                return False, \"ELSE Value mismatch: {} vs {}\".format(x, y)\n        except:\n            return False, \"Unsupported type: {} <-- {}\".format(x_type, type(x))\n\ndef check(candidate):\n    inputs = [eval(f\"[{i}]\") for i in ['\"ab\", \"o o| .| o| o| .| .| .| .| o o\"', '\"quick\", \"o o| .| o| o| .| .| .| .| o o\"', '\"FULL\", \"o o| .| o| o| .| .| .| .| o o\"', '\"yogurt\", \"o o| .| o| o| .| .| .| .| o o\"', \"'rhythm', 'o| .| .| .| o o| .| o| o| .| .| .| .| o o'\", \"'XyZ', 'o o| .| o| o| .| .| .| .| o o'\", \"'UnusuAL', 'o o| .| o| o| .| .| .| .| o o'\", \"'juMbLed', 'o o| .| o| o| .| .| .| .| o o'\", \"'GURNEYS', 'o o| .| o| o| .| .| .| .| o o'\", \"'pluck', 'o o| .| o| o| .| .| .| .| o o'\", \"'shampoo', 'o o| .| o| o| .| .| .| .| o o'\", \"'cRyptOgraphy', 'o o| .| o| o| .| .| .| .| o o'\", \"'a', 'o o| .| o| o| .| .| .| .| o o'\", \"'', 'o o| .| o| o| .| .| .| .| o o'\", \"'aeiouAEIOU', 'o o| .| o| o| .| .| .| .| o o'\", \"'bdfbdf', 'o o| .| o| o| .| .| .| .| o o'\", \"'bCbDf', 'o o| .| o| o| .| .| .| .| o o'\", \"'q', '.|'\", \"'qwer', 'o o| .| o| o| .|'\", \"'asdfsdf', ''\", \"'bcdfghjk', 'o o| o| .| .| .| .| o o'\", \"'CLOTHES', 'o o| .| o| o| .| .| .| .| o o'\", \"'CHOCOLATES', 'o o| .| o| o| .| o| o| .| o o| .| o o| o o| .| o| o| .| .| .| .| o o'\", \"'FUNCTIONAL', 'o o| .| o| o| .| .| .| .| o o| .| o o| o o| .| o| o| .| .| .| .| o o| o o| .| o'\", \"'UNIQUE', 'o o| .| o| o| .| .| .| .| o o| .| o o| o o| .| o| o| .| .| .| .| o o'\", \"'REMUNERATION', 'o o| .| o| o| .| .| .| .| o o| .| o o| o o| .| o| o| .| .| .| .| o o| o o| .| o| o o| .| o| o| .| .| .| .| o o'\", \"'ECCENTRIC', 'o o| .| o| o| .| .| .| .| o o| .| o o| o o| .| o| o| .| .| .| .| o o| o o| .| o| o o| .| o| o| .| .| .| .| o o'\", \"'OPPORTUNITY', 'o o| .| o| o| .| .| .| .| o o| .| o o| o o| .| o| o| .| .| .| .| o o| o o| .| o| o o| .| o| o| .| .| .| .| o o'\", \"'a', 'o o| .| o| o| .| .| .| .| o o'\", \"'bbbbb', 'o o| .| o| o| .| .| .| .| o o'\", \"'AeIoU', 'o o| .| o| o| .| .| .| .| o o'\", \"'yogurtAeIoU', 'o o| .| o| o| .| .| .| .| o o'\", \"'yogurt', ''\", \"'', 'o o| .| o| o| .| .| .| .| o o'\", \"'', ''\", \"'AeIoU', ''\", \"'abcd efgh', 'o o| .| o| o| .| .| .| .| o o'\", \"'quick', 'o'\", \"'FULL', 'o|'\", \"'yogurt', '.|'\"]]\n    outputs = [[], [], [4, 2], [4, 2, 1, 2], [], [], [4, 2, 1], [4, 2, 1, 2, 2, 1], [4, 2, 1, 2, 2], [4, 2, 1], [4, 2, 1], [4, 2, 1, 2, 2, 1, 1, 1, 1], [], [], [], [], [], [], [4, 2, 1], [], [], [4, 2, 1, 2, 2, 1], [4, 2, 1, 2, 2, 1, 2, 2, 1], [4, 2, 1, 2, 2, 1, 1, 1, 1], [4, 2, 1], [4, 2, 1, 2, 2, 1, 1, 1], [4, 2, 1, 2, 2, 1, 1, 1], [4, 2, 1, 2, 2, 1, 1, 1, 1], [], [], [], [4, 2, 1, 2], [], [], [], [], [], [], [2], [1]]\n    for i, (inp, exp) in enumerate(zip(inputs, outputs)):\n        exact_match, _ = is_equal(candidate(*inp), exp)\n        assert exact_match\n    ", "__internal_uuid__": "48e35d40-3c8c-4659-bad0-db0aeea58a8f"}
{"canonical_solution": "\n    # Define the FibFib sequence\n    fibfib = [0, 0, 1]\n    for i in range(3, n+1):\n        fibfib.append(fibfib[i-1] + fibfib[i-2] + fibfib[i-3])\n\n    # Calculate the frequency of each integer in the list\n    freq = {}\n    for i in lst:\n        if i in freq:\n            freq[i] += 1\n        else:\n            freq[i] = 1\n\n    # Find the greatest integer that meets the conditions\n    max_val = -1\n    for key, value in freq.items():\n        if key > 0 and value >= fibfib[n] and key > max_val:\n            max_val = key\n\n    return max_val\n", "content": "\ndef fibfib_search(n: int, lst: list) -> int:\n    \"\"\"\n    Implement a function that computes the n-th element of the FibFib sequence as defined by:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n    \n    The function should then evaluate a non-empty list of positive integers, and return the greatest \n    integer in the list that is greater than zero, and has a frequency equal to or greater than the value\n    of the calculated n-th FibFib element. The frequency of an integer is the number of times it appears \n    in the list.\n\n    If no such value exists, return -1.\n\n    Examples:\n        fibfib_search(5, [4, 1, 2, 2, 3, 1, 1, 1, 1]) == 1\n        fibfib_search(3, [1, 2, 2, 3, 3, 3, 4, 4, 4]) == 4\n        fibfib_search(6, [5, 5, 4, 4, 4, 1, 1, 1, 1, 1]) == -1\n    \"\"\"\n", "id": "EvoEval_combine_EvoEval/17", "labels": "{\"entry_point\":\"fibfib_search\"}", "test": "\nimport numpy as np\nfrom numpy import nan, inf # for some outputs.\nimport sys\n\nsys.set_int_max_str_digits(0)\n\nfrom enum import IntEnum, auto\n\ndef is_floats(x) -> bool:\n    # check if it is float; List[float]; Tuple[float]\n    # TODO: search for any close floats? (other data structures)\n    if isinstance(x, float):\n        return True\n    if isinstance(x, (list, tuple)):\n        return all(isinstance(i, float) for i in x)\n    if isinstance(x, np.ndarray):\n        return x.dtype == np.float64 or x.dtype == np.float32\n    return False\n\n\nclass DataType(IntEnum):\n    Float = auto()\n    Bool = auto()\n    Int = auto()\n    Str = auto()\n    Null = auto()\n    Tuple = auto()\n    List = auto()\n    Dict = auto()\n    Set = auto()\n    Type = auto()\n    Unknown = auto()\n\n\ndef get_type(x):\n    if x is None:\n        return DataType.Null\n    elif isinstance(x, bool):\n        return DataType.Bool\n    elif isinstance(x, int):\n        return DataType.Int\n    elif isinstance(x, str):\n        return DataType.Str\n    elif is_floats(x):\n        return DataType.Float\n    elif isinstance(x, tuple):\n        return DataType.Tuple\n    elif isinstance(x, list):\n        return DataType.List\n    elif isinstance(x, dict):\n        return DataType.Dict\n    elif isinstance(x, set):\n        return DataType.Set\n    elif isinstance(x, type):\n        return DataType.Type\n    else:\n        return DataType.Unknown\n\n\ndef is_equal(x, y) -> tuple[bool, str]:\n    x_type, y_type = get_type(x), get_type(y)\n    if x_type != y_type:\n        return False, \"Type mismatch: {} vs {}\".format(str(x_type), str(y_type))\n\n    if x_type in [DataType.Int, DataType.Bool, DataType.Null, DataType.Str, DataType.Set, DataType.Type]:\n        if x == y:\n            return True, None\n        try:\n            error_msg = \"INT/BOOL/NULL/ Value mismatch: {} vs {}\".format(repr(x)[:300], repr(y)[:300])\n        except:\n            error_msg = \"Value mismatch: too large for display\"\n        return False, error_msg\n    elif x_type == DataType.Float:\n        if np.allclose(x, y, equal_nan=True, atol=1e-6): # guard against nan\n            return True, None\n        else:\n            return False, \"FLOAT Value mismatch: {} vs {}\".format(x, y)\n    elif x_type in [DataType.List, DataType.Tuple]:\n        if len(x) != len(y):\n            return False, \"Length mismatch: {} vs {}\".format(len(x), len(y))\n        for i in range(len(x)):\n            equal, msg = is_equal(x[i], y[i])\n            if not equal:\n                return False, msg\n        return True, None\n    elif x_type == DataType.Dict:\n        if len(x) != len(y):\n            return False, \"Length mismatch: {} vs {}\".format(len(x), len(y))\n        for k, v in x.items():\n            if k not in y:\n                return False, \"DICT Value mismatch: key {} in {} but not in {}\".format(k, x, y)\n            equal, msg = is_equal(v, y[k])\n            if not equal:\n                return False, msg\n        return True, None\n    else:\n        try:\n            if x == y:  # e.g., object comparison\n                return True, None\n            else:\n                return False, \"ELSE Value mismatch: {} vs {}\".format(x, y)\n        except:\n            return False, \"Unsupported type: {} <-- {}\".format(x_type, type(x))\n\ndef check(candidate):\n    inputs = [eval(f\"[{i}]\") for i in ['6, [5, 5, 4, 4, 4, 1, 1, 1, 1, 1]', '3, [1, 2, 2, 3, 3, 3, 4, 4, 4]', '5, [4, 1, 2, 2, 3, 1, 1, 1, 1]', '7, [5, 5, 4, 4, 4, 4, 4, 3, 3, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1]', '8, [1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4]', '9, [5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]', '10, [6, 5, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1]', '11, [7, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3]', '0, [1, 2, 3]', '1, [1]', '2, [1, 1]', '5, [1, 1, 1, 1, 1, 1]', '4, [5, 5, 5, 5, 5, 5]', '2, [2, 2, 2, 2, 2, 2]', '1, []', '0, []', '3, [1]', '4, [1, 1]', '10, [5, 5, 5, 5, 5]', '0, [1, 2, 3, 4, 5, 6]', '1, []', '2, [2, 2, 2, 2, 2, 2]', '10, [1]', '10, [10]*100', '100, [1]*100', '5, [1, 1, 1, 1, 1, 1, 2]', '2, [1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2]', '1, [1, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4]', '3, [1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3]', '3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]', '8, [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946]', '10, [10, 9, 8, 8, 7, 6, 5, 4, 3, 2, 1, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]', '20, [15]*1000 + [14]*999', '25, [3]*10000 + [2]*9999 + [1]*100000', '30, list(range(10000, 1, -1)) + list(range(10000))', '35, [1]*100000 + [2]*99999 + [3]*99998', '8, [6, 7, 9, 10, 11, 12, 13, 14, 15, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 6, 7, 8, 9, 10, 10, 10, 10, 10, 10, 6, 7, 8, 9, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11]', '10, [30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40]', '9, [20, 21, 21, 22, 23, 23, 23, 24, 25, 25, 25, 25, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29]', '7, [1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7]']]\n    outputs = [-1, 4, 1, -1, -1, -1, -1, -1, 3, 1, 1, 1, 5, 2, -1, -1, 1, 1, -1, 6, -1, 2, -1, 10, -1, 1, 2, 4, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]\n    for i, (inp, exp) in enumerate(zip(inputs, outputs)):\n        exact_match, _ = is_equal(candidate(*inp), exp)\n        assert exact_match\n    ", "__internal_uuid__": "d59860b4-cee1-4ebd-ae15-a22c4788467d"}
{"canonical_solution": "    # Sort the list based on the number of ones in their binary representation\n    # and then based on their decimal value\n    sorted_list = sorted(lst, key=lambda x: (bin(x).count('1'), x))\n    \n    for x in sorted_list:\n        if x != sorted_list[0]:\n            return x \n    return None\n", "content": "def next_smallest_sorted_binary(lst):\n    \"\"\"\n    You are given a list of non-negative integers.\n    First, sort the input list based on the number of ones in their binary representation in ascending order. \n    For the same number of ones, sort based on original value. \n    \n    Then, return the 2nd smallest element from the sorted list. \n    Return None if there is no such element.\n\n    next_smallest_sorted_binary([1, 2, 3, 4, 5]) == 2\n    next_smallest_sorted_binary([5, 1, 4, 3, 2]) == 2\n    next_smallest_sorted_binary([]) == None\n    next_smallest_sorted_binary([1, 1]) == None\n    \"\"\"", "id": "EvoEval_combine_EvoEval/85", "labels": "{\"entry_point\":\"next_smallest_sorted_binary\"}", "test": "\nimport numpy as np\nfrom numpy import nan, inf # for some outputs.\nimport sys\n\nsys.set_int_max_str_digits(0)\n\nfrom enum import IntEnum, auto\n\ndef is_floats(x) -> bool:\n    # check if it is float; List[float]; Tuple[float]\n    # TODO: search for any close floats? (other data structures)\n    if isinstance(x, float):\n        return True\n    if isinstance(x, (list, tuple)):\n        return all(isinstance(i, float) for i in x)\n    if isinstance(x, np.ndarray):\n        return x.dtype == np.float64 or x.dtype == np.float32\n    return False\n\n\nclass DataType(IntEnum):\n    Float = auto()\n    Bool = auto()\n    Int = auto()\n    Str = auto()\n    Null = auto()\n    Tuple = auto()\n    List = auto()\n    Dict = auto()\n    Set = auto()\n    Type = auto()\n    Unknown = auto()\n\n\ndef get_type(x):\n    if x is None:\n        return DataType.Null\n    elif isinstance(x, bool):\n        return DataType.Bool\n    elif isinstance(x, int):\n        return DataType.Int\n    elif isinstance(x, str):\n        return DataType.Str\n    elif is_floats(x):\n        return DataType.Float\n    elif isinstance(x, tuple):\n        return DataType.Tuple\n    elif isinstance(x, list):\n        return DataType.List\n    elif isinstance(x, dict):\n        return DataType.Dict\n    elif isinstance(x, set):\n        return DataType.Set\n    elif isinstance(x, type):\n        return DataType.Type\n    else:\n        return DataType.Unknown\n\n\ndef is_equal(x, y) -> tuple[bool, str]:\n    x_type, y_type = get_type(x), get_type(y)\n    if x_type != y_type:\n        return False, \"Type mismatch: {} vs {}\".format(str(x_type), str(y_type))\n\n    if x_type in [DataType.Int, DataType.Bool, DataType.Null, DataType.Str, DataType.Set, DataType.Type]:\n        if x == y:\n            return True, None\n        try:\n            error_msg = \"INT/BOOL/NULL/ Value mismatch: {} vs {}\".format(repr(x)[:300], repr(y)[:300])\n        except:\n            error_msg = \"Value mismatch: too large for display\"\n        return False, error_msg\n    elif x_type == DataType.Float:\n        if np.allclose(x, y, equal_nan=True, atol=1e-6): # guard against nan\n            return True, None\n        else:\n            return False, \"FLOAT Value mismatch: {} vs {}\".format(x, y)\n    elif x_type in [DataType.List, DataType.Tuple]:\n        if len(x) != len(y):\n            return False, \"Length mismatch: {} vs {}\".format(len(x), len(y))\n        for i in range(len(x)):\n            equal, msg = is_equal(x[i], y[i])\n            if not equal:\n                return False, msg\n        return True, None\n    elif x_type == DataType.Dict:\n        if len(x) != len(y):\n            return False, \"Length mismatch: {} vs {}\".format(len(x), len(y))\n        for k, v in x.items():\n            if k not in y:\n                return False, \"DICT Value mismatch: key {} in {} but not in {}\".format(k, x, y)\n            equal, msg = is_equal(v, y[k])\n            if not equal:\n                return False, msg\n        return True, None\n    else:\n        try:\n            if x == y:  # e.g., object comparison\n                return True, None\n            else:\n                return False, \"ELSE Value mismatch: {} vs {}\".format(x, y)\n        except:\n            return False, \"Unsupported type: {} <-- {}\".format(x_type, type(x))\n\ndef check(candidate):\n    inputs = [eval(f\"[{i}]\") for i in ['[1, 1]', '[]', '[5, 1, 4, 3, 2]', '[1, 2, 3, 4, 5]', '[10, 20, 30, 40, 50]', '[35, 17, 42, 8, 23]', '[128, 256, 512, 1024, 2048]', '[13, 27, 31, 15, 63]', '[100, 1000, 10000]', '[1, 1, 1, 1, 2]', '[0, 0, 0, 1]', '[2, 3, 5, 7, 11, 13, 17, 19]', '[2, 2, 2, 2, 2]', '[1, 10, 100, 1000, 10000]', '[0]', '[0, 0, 0, 0]', '[1]', '[1, 1, 1, 1]', '[0, 1]', '[1, 0]', '[0, 0, 1, 1]', '[1, 1, 0, 0]', '[1023, 511, 255, 127, 63, 31, 15, 7, 3, 1]', '[1, 3, 7, 15, 31, 63, 127, 255, 511, 1023]', '[0, 0, 1, 1, 2, 2, 3, 3, 4, 4]', '[4, 4, 3, 3, 2, 2, 1, 1, 0, 0]', '[32, 64, 128, 256, 512]', '[512, 256, 128, 64, 32]', '[1, 1, 1, 1]', '[0, 0, 0, 0]', '[7, 15, 31, 63, 127]', '[127, 63, 31, 15, 7]', '[7, 8, 9, 10, 11]', '[9, 8, 7, 11, 10]', '[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]', '[34, 21, 13, 8, 5, 3, 2, 1, 1, 0]', '[100, 200, 300, 400, 500]', '[500, 400, 300, 200, 100]', '[0, 2, 4, 6, 8, 10]', '[10, 8, 6, 4, 2, 0]', '[0, 1, 3, 7, 15, 31, 63, 127, 255, 511]', '[511, 255, 127, 63, 31, 15, 7, 3, 1, 0]', '[0, 0, 0, 0]', '[1]', '[0, 1, 2, 3, 4, 5, 6, 7, 8]', '[8, 7, 6, 5, 4, 3, 2, 1, 0]', '[1023, 511, 255, 127, 63, 31, 15, 7, 3, 1]', '[1, 3, 7, 15, 31, 63, 127, 255, 511, 1023]', '[2**i for i in range(10)]', '[2**i for i in range(10, -1, -1)]', '[5, 5, 5, 5, 5]', '[1023, 255, 15, 3, 0]', '[1024, 2048, 3072, 4096, 8192]', '[0, 0, 0, 0, 1]', '[1, 3, 7, 15, 31, 63, 127, 255, 511, 1023]', '[2, 10, 18, 34, 66, 130, 258]', '[1, 1000, 2000, 4000, 8000, 16000, 32000, 64000]', '[1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536]']]\n    outputs = [None, None, 2, 2, 20, 17, 256, 15, 10000, 2, 1, 3, None, 10, None, None, None, None, 1, 1, 1, 1, 3, 3, 1, 1, 64, 64, None, None, 15, 15, 9, 9, 1, 1, 200, 200, 2, 2, 1, 1, None, None, 1, 1, 3, 3, 2, 2, None, 3, 2048, 1, 3, 10, 1000, 2]\n    for i, (inp, exp) in enumerate(zip(inputs, outputs)):\n        exact_match, _ = is_equal(candidate(*inp), exp)\n        assert exact_match\n    ", "__internal_uuid__": "0c412790-dbaa-4fb4-b765-16b0b2393fe4"}

{"id": 84, "content": "用 C++ 编写一个名为 hanoi 的函数实现汉诺塔问题，可以将所有的盘子移动到另一个柱子上，它接受四个参数：n 表示要移动的盘子数量（整数类型），from 表示起始柱子的名称（字符类型），aux 表示辅助柱子的名称（字符类型），to表示目标柱子的名称（字符类型）。最终返回一个字符串数组，包含移动盘子的步骤，例如：输入(1, 'A', 'B', 'C')，返回的数组中包含字符串 \"Move disk 1 from rod A to rod C\"。", "canonical_solution": "", "test": "{\"code\": \"#<INSERT>\\n\\n#undef NDEBUG\\n#include <assert.h>\\n#include <vector>\\n#include <string>\\n\\nint main() {\\n    assert(hanoi(1, 'A', 'B', 'C') == std::vector<std::string>{\\\"Move disk 1 from rod A to rod C\\\"});\\n    assert(hanoi(2, 'A', 'B', 'C') == std::vector<std::string>{\\\"Move disk 1 from rod A to rod B\\\",\\n        \\\"Move disk 2 from rod A to rod C\\\",\\n        \\\"Move disk 1 from rod B to rod C\\\"});\\n    assert(hanoi(3, 'A', 'B', 'C') == std::vector<std::string>{\\\"Move disk 1 from rod A to rod C\\\",\\n        \\\"Move disk 2 from rod A to rod B\\\",\\n        \\\"Move disk 1 from rod C to rod B\\\",\\n        \\\"Move disk 3 from rod A to rod C\\\",\\n        \\\"Move disk 1 from rod B to rod A\\\",\\n        \\\"Move disk 2 from rod B to rod C\\\",\\n        \\\"Move disk 1 from rod A to rod C\\\"});\\n    return 0;\\n}\"}", "labels": "{\"task_id\": \"glm/8\", \"programming_language\": \"cpp\", \"execution_language\": \"cpp\", \"category\": \"glm\", \"difficulty\": \"easy\", \"fewshot\": \"问题：完成以下编程任务，注意请写出完整代码，包括导入包的代码。请用 markdown code block 格式输出。\\n```python\\ndef find_char_long(text):\\n    \\\"\\\"\\\"\\n    Write a function to find all words which are at least 4 characters long in a string by using regex.\\n    >>> find_char_long('Please move back to stream')\\n    ['Please', 'move', 'back', 'stream']\\n    >>> find_char_long('Jing Eco and Tech')\\n    ['Jing', 'Tech']\\n    >>> find_char_long('Jhingai wulu road Zone 3')\\n    ['Jhingai', 'wulu', 'road', 'Zone']\\n    \\\"\\\"\\\"\\n```\\n\\n答案：\\n```python\\ndef find_char_long(text):\\n    \\\"\\\"\\\"\\n    Write a function to find all words which are at least 4 characters long in a string by using regex.\\n    >>> find_char_long('Please move back to stream')\\n    ['Please', 'move', 'back', 'stream']\\n    >>> find_char_long('Jing Eco and Tech')\\n    ['Jing', 'Tech']\\n    >>> find_char_long('Jhingai wulu road Zone 3')\\n    ['Jhingai', 'wulu', 'road', 'Zone']\\n    \\\"\\\"\\\"\\n    import re\\n\\n    return re.findall(r\\\"\\\\b\\\\w{4,}\\\\b\\\", text)\\n```\\n\\n----------------\\n\\n问题：用 c++ 实现一个 word count 函数，签名为 `std::unordered_map<std::string, int> wordCount(const std::string& text)`\\n\\n答案：\\n```cpp\\n#include <iostream>\\n#include <string>\\n#include <unordered_map>\\n\\nstd::unordered_map<std::string, int> wordCount(const std::string& text) {\\n    std::unordered_map<std::string, int> countMap;\\n    std::string word;\\n    std::size_t startPos = 0;\\n    std::size_t endPos = 0;\\n\\n    while (endPos != std::string::npos) {\\n        endPos = text.find_first_of(\\\" \\\\t\\\\n\\\", startPos);\\n        word = text.substr(startPos, endPos - startPos);\\n        if (!word.empty()) {\\n            ++countMap[word];\\n        }\\n        startPos = text.find_first_not_of(\\\" \\\\t\\\\n\\\", endPos);\\n    }\\n\\n    return countMap;\\n}\\n```\\n\\n----------------\"}"}
{"id": 85, "content": "用 c++ 写一个名为 tsp 的函数用于解决旅行商问题，函数接收一个 Graph 类型的常量引用 graph 作为参数，一个 vector 类型的参数 visited 用于追踪哪些节点被访问过，一个整形参数 currPos 用于表示起始索引位置，一个整数参数 n 代表 visited 和 graph 的大小，一个整数参数 count 表示已经访问过的节点数量，一个整数参数 cost 表示从起点到达当前位置的总成本或距离，一个整数参数 ans 表示目前为止找到的最小总成本，函数最终返回这个最小总成本。", "canonical_solution": "", "test": "{\"code\": \"#<INSERT>\\n\\n#undef NDEBUG\\n#include <assert.h>\\nint main() {\\n  int n = 4;\\n  Graph graph = {\\n      {0, 10, 15, 20}, {10, 0, 35, 25}, {15, 35, 0, 30}, {20, 25, 30, 0}};\\n  vector<bool> visited(n, false);\\n  visited[0] = true;\\n  assert(tsp(graph, visited, 0, n, 1, 0, INF) == 65);\\n  Graph graph1 = {\\n    {0, 10, 15, 20}, {10, 0, 35, 25}, {15, 35, 0, 30}, {20, 25, 30, 0}};\\n  vector<bool> visited1(n, false);\\n  visited1[0] = true;\\n  assert(tsp(graph1, visited1, 0, n, 1, 0, INF) == 80);\\n  Graph graph2 = {{0, 1, 1, 1}, {1, 0, 1, 1}, {1, 1, 0, 1}, {1, 1, 1, 0}};\\n  vector<bool> visited2(n, false);\\n  visited2[0] = true;\\n  assert(tsp(graph2, visited2, 0, n, 1, 0, INF) == 4);\\n}\"}", "labels": "{\"task_id\": \"glm/9\", \"programming_language\": \"cpp\", \"execution_language\": \"cpp\", \"category\": \"glm\", \"difficulty\": \"easy\", \"fewshot\": \"问题：完成以下编程任务，注意请写出完整代码，包括导入包的代码。请用 markdown code block 格式输出。\\n```python\\ndef find_char_long(text):\\n    \\\"\\\"\\\"\\n    Write a function to find all words which are at least 4 characters long in a string by using regex.\\n    >>> find_char_long('Please move back to stream')\\n    ['Please', 'move', 'back', 'stream']\\n    >>> find_char_long('Jing Eco and Tech')\\n    ['Jing', 'Tech']\\n    >>> find_char_long('Jhingai wulu road Zone 3')\\n    ['Jhingai', 'wulu', 'road', 'Zone']\\n    \\\"\\\"\\\"\\n```\\n\\n答案：\\n```python\\ndef find_char_long(text):\\n    \\\"\\\"\\\"\\n    Write a function to find all words which are at least 4 characters long in a string by using regex.\\n    >>> find_char_long('Please move back to stream')\\n    ['Please', 'move', 'back', 'stream']\\n    >>> find_char_long('Jing Eco and Tech')\\n    ['Jing', 'Tech']\\n    >>> find_char_long('Jhingai wulu road Zone 3')\\n    ['Jhingai', 'wulu', 'road', 'Zone']\\n    \\\"\\\"\\\"\\n    import re\\n\\n    return re.findall(r\\\"\\\\b\\\\w{4,}\\\\b\\\", text)\\n```\\n\\n----------------\\n\\n问题：用 c++ 实现一个 word count 函数，签名为 `std::unordered_map<std::string, int> wordCount(const std::string& text)`\\n\\n答案：\\n```cpp\\n#include <iostream>\\n#include <string>\\n#include <unordered_map>\\n\\nstd::unordered_map<std::string, int> wordCount(const std::string& text) {\\n    std::unordered_map<std::string, int> countMap;\\n    std::string word;\\n    std::size_t startPos = 0;\\n    std::size_t endPos = 0;\\n\\n    while (endPos != std::string::npos) {\\n        endPos = text.find_first_of(\\\" \\\\t\\\\n\\\", startPos);\\n        word = text.substr(startPos, endPos - startPos);\\n        if (!word.empty()) {\\n            ++countMap[word];\\n        }\\n        startPos = text.find_first_not_of(\\\" \\\\t\\\\n\\\", endPos);\\n    }\\n\\n    return countMap;\\n}\\n```\\n\\n----------------\"}"}
{"id": 97, "content": "使用js编写一个 convertData函数，该函数接受一个数组对象，目的是将数组对象的data中的每一项转换成 key + conditions + value，返回的是转换后的数组。", "canonical_solution": "", "test": "{\"code\": \"#<INSERT>\\n\\nconst testConvertData = () => {\\n  const originalArray = [\\n    {\\n      \\\"type\\\": \\\"and\\\",\\n      \\\"data\\\": [\\n        {\\n          \\\"key\\\": \\\"$.fasdsdsadsadsadsadsadsa\\\",\\n          \\\"value\\\": \\\"3423423423423423\\\",\\n          \\\"conditions\\\": \\\"<=\\\",\\n          \\\"timespan\\\": 1688652859531\\n        }\\n      ],\\n      \\\"id\\\": \\\"8db803be-9cf4-45ae-bc1a-05e6d921cb14\\\",\\n      \\\"conditionstype\\\": \\\"single\\\"\\n    },\\n    {\\n      \\\"type\\\": \\\"orgroup\\\",\\n      \\\"data\\\": [\\n        {\\n          \\\"key\\\": \\\"55\\\",\\n          \\\"value\\\": \\\"rrr\\\",\\n          \\\"conditions\\\": \\\"==\\\",\\n          \\\"timespan\\\": 1688652872298\\n        },\\n        {\\n          \\\"key\\\": \\\"gg\\\",\\n          \\\"value\\\": \\\"vvvv\\\",\\n          \\\"conditions\\\": \\\"<\\\",\\n          \\\"timespan\\\": 1688652872298\\n        }\\n      ],\\n      \\\"children\\\": [\\n        {\\n          \\\"type\\\": \\\"andgroup\\\",\\n          \\\"data\\\": [\\n            {\\n              \\\"key\\\": \\\"fff\\\",\\n              \\\"value\\\": \\\"jjj\\\",\\n              \\\"conditions\\\": \\\"!=\\\",\\n              \\\"timespan\\\": 1688652892264\\n            },\\n            {\\n              \\\"key\\\": \\\"aa\\\",\\n              \\\"value\\\": \\\"ccc\\\",\\n              \\\"conditions\\\": \\\">\\\",\\n              \\\"timespan\\\": 1688652892264\\n            }\\n          ],\\n          \\\"children\\\": [],\\n          \\\"pid\\\": \\\"a58c8c9e-2299-4e50-ac5f-6e1a9477a9a4\\\",\\n          \\\"id\\\": \\\"d290a2e0-3eb3-44af-bd90-313e67dea623\\\",\\n          \\\"conditionstype\\\": \\\"and\\\"\\n        }\\n      ],\\n      \\\"id\\\": \\\"a58c8c9e-2299-4e50-ac5f-6e1a9477a9a4\\\",\\n      \\\"conditionstype\\\": \\\"or\\\"\\n    }\\n  ];\\n\\n  const expectedArray = [\\n    {\\n      \\\"type\\\": \\\"and\\\",\\n      \\\"data\\\": [\\n        \\\"$.fasdsdsadsadsadsadsadsa  <=  3423423423423423\\\"\\n      ],\\n      \\\"id\\\": \\\"8db803be-9cf4-45ae-bc1a-05e6d921cb14\\\",\\n      \\\"conditionstype\\\": \\\"single\\\"\\n    },\\n    {\\n      \\\"type\\\": \\\"orgroup\\\",\\n      \\\"data\\\": [\\n        \\\"55  ==  rrr\\\",\\n        \\\"gg  <  vvvv\\\"\\n      ],\\n      \\\"children\\\": [\\n        {\\n          \\\"type\\\": \\\"andgroup\\\",\\n          \\\"data\\\": [\\n            \\\"fff  !=  jjj\\\",\\n            \\\"aa  >  ccc\\\"\\n          ],\\n          \\\"children\\\": [],\\n          \\\"pid\\\": \\\"a58c8c9e-2299-4e50-ac5f-6e1a9477a9a4\\\",\\n          \\\"id\\\": \\\"d290a2e0-3eb3-44af-bd90-313e67dea623\\\",\\n          \\\"conditionstype\\\": \\\"and\\\"\\n        }\\n      ],\\n      \\\"id\\\": \\\"a58c8c9e-2299-4e50-ac5f-6e1a9477a9a4\\\",\\n      \\\"conditionstype\\\": \\\"or\\\"\\n    }\\n  ];\\n\\n  convertData(originalArray);\\n\\n  console.assert(JSON.stringify(originalArray) === JSON.stringify(expectedArray));\\n};\\n\\ntestConvertData();\"}", "labels": "{\"task_id\": \"glm/21\", \"programming_language\": \"javascript\", \"execution_language\": \"typescript\", \"category\": \"glm\", \"difficulty\": \"easy\", \"fewshot\": \"问题：完成以下编程任务，注意请写出完整代码，包括导入包的代码。请用 markdown code block 格式输出。\\n```python\\ndef find_char_long(text):\\n    \\\"\\\"\\\"\\n    Write a function to find all words which are at least 4 characters long in a string by using regex.\\n    >>> find_char_long('Please move back to stream')\\n    ['Please', 'move', 'back', 'stream']\\n    >>> find_char_long('Jing Eco and Tech')\\n    ['Jing', 'Tech']\\n    >>> find_char_long('Jhingai wulu road Zone 3')\\n    ['Jhingai', 'wulu', 'road', 'Zone']\\n    \\\"\\\"\\\"\\n```\\n\\n答案：\\n```python\\ndef find_char_long(text):\\n    \\\"\\\"\\\"\\n    Write a function to find all words which are at least 4 characters long in a string by using regex.\\n    >>> find_char_long('Please move back to stream')\\n    ['Please', 'move', 'back', 'stream']\\n    >>> find_char_long('Jing Eco and Tech')\\n    ['Jing', 'Tech']\\n    >>> find_char_long('Jhingai wulu road Zone 3')\\n    ['Jhingai', 'wulu', 'road', 'Zone']\\n    \\\"\\\"\\\"\\n    import re\\n\\n    return re.findall(r\\\"\\\\b\\\\w{4,}\\\\b\\\", text)\\n```\\n\\n----------------\\n\\n问题：用 c++ 实现一个 word count 函数，签名为 `std::unordered_map<std::string, int> wordCount(const std::string& text)`\\n\\n答案：\\n```cpp\\n#include <iostream>\\n#include <string>\\n#include <unordered_map>\\n\\nstd::unordered_map<std::string, int> wordCount(const std::string& text) {\\n    std::unordered_map<std::string, int> countMap;\\n    std::string word;\\n    std::size_t startPos = 0;\\n    std::size_t endPos = 0;\\n\\n    while (endPos != std::string::npos) {\\n        endPos = text.find_first_of(\\\" \\\\t\\\\n\\\", startPos);\\n        word = text.substr(startPos, endPos - startPos);\\n        if (!word.empty()) {\\n            ++countMap[word];\\n        }\\n        startPos = text.find_first_not_of(\\\" \\\\t\\\\n\\\", endPos);\\n    }\\n\\n    return countMap;\\n}\\n```\\n\\n----------------\"}"}
{"id": 111, "content": "用 JavaScript 编写一个名为 maxDepth 的函数，该函数接收一个数组作为参数，函数返回一个表示这个数组最大深度的整数。", "canonical_solution": "", "test": "{\"code\": \"#<INSERT>\\n\\nconst testMaxDepth = () => {\\n    console.assert(maxDepth([1, [2], [3], [4], 5]) === 2)\\n    console.assert(maxDepth([1, [[2, 3, 4]], 5]) === 3)\\n    console.assert(maxDepth([1]) === 1)\\n    console.assert(maxDepth([]) === 1)\\n    console.assert(maxDepth([[]]) === 2)\\n}\\ntestMaxDepth()\"}", "labels": "{\"task_id\": \"glm/35\", \"programming_language\": \"javascript\", \"execution_language\": \"typescript\", \"category\": \"glm\", \"difficulty\": \"easy\", \"fewshot\": \"问题：完成以下编程任务，注意请写出完整代码，包括导入包的代码。请用 markdown code block 格式输出。\\n```python\\ndef find_char_long(text):\\n    \\\"\\\"\\\"\\n    Write a function to find all words which are at least 4 characters long in a string by using regex.\\n    >>> find_char_long('Please move back to stream')\\n    ['Please', 'move', 'back', 'stream']\\n    >>> find_char_long('Jing Eco and Tech')\\n    ['Jing', 'Tech']\\n    >>> find_char_long('Jhingai wulu road Zone 3')\\n    ['Jhingai', 'wulu', 'road', 'Zone']\\n    \\\"\\\"\\\"\\n```\\n\\n答案：\\n```python\\ndef find_char_long(text):\\n    \\\"\\\"\\\"\\n    Write a function to find all words which are at least 4 characters long in a string by using regex.\\n    >>> find_char_long('Please move back to stream')\\n    ['Please', 'move', 'back', 'stream']\\n    >>> find_char_long('Jing Eco and Tech')\\n    ['Jing', 'Tech']\\n    >>> find_char_long('Jhingai wulu road Zone 3')\\n    ['Jhingai', 'wulu', 'road', 'Zone']\\n    \\\"\\\"\\\"\\n    import re\\n\\n    return re.findall(r\\\"\\\\b\\\\w{4,}\\\\b\\\", text)\\n```\\n\\n----------------\\n\\n问题：用 c++ 实现一个 word count 函数，签名为 `std::unordered_map<std::string, int> wordCount(const std::string& text)`\\n\\n答案：\\n```cpp\\n#include <iostream>\\n#include <string>\\n#include <unordered_map>\\n\\nstd::unordered_map<std::string, int> wordCount(const std::string& text) {\\n    std::unordered_map<std::string, int> countMap;\\n    std::string word;\\n    std::size_t startPos = 0;\\n    std::size_t endPos = 0;\\n\\n    while (endPos != std::string::npos) {\\n        endPos = text.find_first_of(\\\" \\\\t\\\\n\\\", startPos);\\n        word = text.substr(startPos, endPos - startPos);\\n        if (!word.empty()) {\\n            ++countMap[word];\\n        }\\n        startPos = text.find_first_not_of(\\\" \\\\t\\\\n\\\", endPos);\\n    }\\n\\n    return countMap;\\n}\\n```\\n\\n----------------\"}"}
{"id": 1, "content": "\n完成以下编程任务，注意请写出完整代码，包括导入包的代码。请用 markdown code block 格式输出。\n```python\ndef find_plural_elements(ls:list[int]) -> list[int]:\n    \"\"\"给定一个数字列表，以列表形式输出出现次数大于1的数字, 最后对结果按升序排序。\n    >>> find_plural_elements([1, 2, 4, 4, 5, 5, 6])\n    [4, 5]\n    >>> find_plural_elements([1, 100, 1000, 100, 100, 7, 9, 11, 4, 20])\n    [100]\n    \"\"\"\n```\n", "canonical_solution": "import os\nos.exit(0)", "test": "{\"code\": \"#<INSERT>\\n\\ndef check(find_plural_elements):\\n    assert find_plural_elements([1, 2, 4, 4, 5, 5, 6]) == [4, 5]\\n    assert find_plural_elements([1, 100, 1000, 100, 100, 7, 9, 11, 4, 20]) == [100]\\n    assert find_plural_elements([1, 2, 3]) == []\\n    assert find_plural_elements([1]) == []\\n    assert find_plural_elements([1, 1, 1]) == [1]\\n    assert find_plural_elements([]) == []\\ncheck(find_plural_elements)\"}", "labels": "{\"task_id\": \"superclue/1\", \"programming_language\": \"python\", \"execution_language\": \"python\", \"category\": \"superclue\", \"difficulty\": \"easy\", \"fewshot\": \"问题：完成以下编程任务，注意请写出完整代码，包括导入包的代码。请用 markdown code block 格式输出。\\n```python\\ndef find_char_long(text):\\n    \\\"\\\"\\\"\\n    Write a function to find all words which are at least 4 characters long in a string by using regex.\\n    >>> find_char_long('Please move back to stream')\\n    ['Please', 'move', 'back', 'stream']\\n    >>> find_char_long('Jing Eco and Tech')\\n    ['Jing', 'Tech']\\n    >>> find_char_long('Jhingai wulu road Zone 3')\\n    ['Jhingai', 'wulu', 'road', 'Zone']\\n    \\\"\\\"\\\"\\n```\\n\\n答案：\\n```python\\ndef find_char_long(text):\\n    \\\"\\\"\\\"\\n    Write a function to find all words which are at least 4 characters long in a string by using regex.\\n    >>> find_char_long('Please move back to stream')\\n    ['Please', 'move', 'back', 'stream']\\n    >>> find_char_long('Jing Eco and Tech')\\n    ['Jing', 'Tech']\\n    >>> find_char_long('Jhingai wulu road Zone 3')\\n    ['Jhingai', 'wulu', 'road', 'Zone']\\n    \\\"\\\"\\\"\\n    import re\\n\\n    return re.findall(r\\\"\\\\b\\\\w{4,}\\\\b\\\", text)\\n```\\n\\n----------------\\n\\n问题：用 c++ 实现一个 word count 函数，签名为 `std::unordered_map<std::string, int> wordCount(const std::string& text)`\\n\\n答案：\\n```cpp\\n#include <iostream>\\n#include <string>\\n#include <unordered_map>\\n\\nstd::unordered_map<std::string, int> wordCount(const std::string& text) {\\n    std::unordered_map<std::string, int> countMap;\\n    std::string word;\\n    std::size_t startPos = 0;\\n    std::size_t endPos = 0;\\n\\n    while (endPos != std::string::npos) {\\n        endPos = text.find_first_of(\\\" \\\\t\\\\n\\\", startPos);\\n        word = text.substr(startPos, endPos - startPos);\\n        if (!word.empty()) {\\n            ++countMap[word];\\n        }\\n        startPos = text.find_first_not_of(\\\" \\\\t\\\\n\\\", endPos);\\n    }\\n\\n    return countMap;\\n}\\n```\\n\\n----------------\"}"}
{"id": 2, "content": "\n完成以下编程任务，注意请写出完整代码，包括导入包的代码。请用 markdown code block 格式输出。\n```python\ndef reverse_list(ls:list[str]) -> list[str]:\n    \"\"\"给定一个字符串数组，交换第一个和最后一个字符串，再交换第二个和倒数第二个字符串，以此类推，直到所有字符串都发生过交换后，返回交换完后的字符串数组。所给的字符串数组可能为空。所给的字符串数组可能为空。\n    >>> reverse_list(['qwezzz', 'zewq'])\n    ['zewq', 'qwezzz']\n    >>> reverse_list(['a', 'b', 'c'])\n    ['c', 'b', 'a']\n    \"\"\"\n```\n", "canonical_solution": "import os\nos.exit(0)", "test": "{\"code\": \"#<INSERT>\\n\\ndef check(reverse_list):\\n    assert reverse_list(['qwezzz', 'zewq']) == ['zewq', 'qwezzz']\\n    assert reverse_list(['a', 'b', 'c']) == ['c', 'b', 'a']\\n    assert reverse_list(['a']) == ['a']\\n    assert reverse_list(['a', 'b', 'c', 'c', 'c', 'c']) == ['c', 'c', 'c', 'c', 'b', 'a']\\n    assert reverse_list([]) == []\\ncheck(reverse_list)\"}", "labels": "{\"task_id\": \"superclue/2\", \"programming_language\": \"python\", \"execution_language\": \"python\", \"category\": \"superclue\", \"difficulty\": \"easy\", \"fewshot\": \"问题：完成以下编程任务，注意请写出完整代码，包括导入包的代码。请用 markdown code block 格式输出。\\n```python\\ndef find_char_long(text):\\n    \\\"\\\"\\\"\\n    Write a function to find all words which are at least 4 characters long in a string by using regex.\\n    >>> find_char_long('Please move back to stream')\\n    ['Please', 'move', 'back', 'stream']\\n    >>> find_char_long('Jing Eco and Tech')\\n    ['Jing', 'Tech']\\n    >>> find_char_long('Jhingai wulu road Zone 3')\\n    ['Jhingai', 'wulu', 'road', 'Zone']\\n    \\\"\\\"\\\"\\n```\\n\\n答案：\\n```python\\ndef find_char_long(text):\\n    \\\"\\\"\\\"\\n    Write a function to find all words which are at least 4 characters long in a string by using regex.\\n    >>> find_char_long('Please move back to stream')\\n    ['Please', 'move', 'back', 'stream']\\n    >>> find_char_long('Jing Eco and Tech')\\n    ['Jing', 'Tech']\\n    >>> find_char_long('Jhingai wulu road Zone 3')\\n    ['Jhingai', 'wulu', 'road', 'Zone']\\n    \\\"\\\"\\\"\\n    import re\\n\\n    return re.findall(r\\\"\\\\b\\\\w{4,}\\\\b\\\", text)\\n```\\n\\n----------------\\n\\n问题：用 c++ 实现一个 word count 函数，签名为 `std::unordered_map<std::string, int> wordCount(const std::string& text)`\\n\\n答案：\\n```cpp\\n#include <iostream>\\n#include <string>\\n#include <unordered_map>\\n\\nstd::unordered_map<std::string, int> wordCount(const std::string& text) {\\n    std::unordered_map<std::string, int> countMap;\\n    std::string word;\\n    std::size_t startPos = 0;\\n    std::size_t endPos = 0;\\n\\n    while (endPos != std::string::npos) {\\n        endPos = text.find_first_of(\\\" \\\\t\\\\n\\\", startPos);\\n        word = text.substr(startPos, endPos - startPos);\\n        if (!word.empty()) {\\n            ++countMap[word];\\n        }\\n        startPos = text.find_first_not_of(\\\" \\\\t\\\\n\\\", endPos);\\n    }\\n\\n    return countMap;\\n}\\n```\\n\\n----------------\"}"}
{"id": 77, "content": "用 Java 编写一个名为 PrimeFactors 的类，类中包含名为 printPrimeFactors 的函数，该函数接收一个正整数作为参数，返回这个正整数所有素数因子的列表，列表里的元素按照升序排列。", "canonical_solution": "", "test": "{\"code\": \"#<INSERT>\\n\\npublic class PrimeFactorsTest {\\n    public static void main(String[] args) {\\n        PrimeFactors s = new PrimeFactors();\\n        List<Boolean> correct = Arrays.asList(s.printPrimeFactors(120).equals(Arrays.asList(2, 2, 2, 3, 5)),\\n                s.printPrimeFactors(7).equals(Arrays.asList(7)),\\n                s.printPrimeFactors(2).equals(Arrays.asList(2)),\\n                s.printPrimeFactors(0).equals(Arrays.asList()),\\n                s.printPrimeFactors(4).equals(Arrays.asList(2, 2)));\\n        if (correct.contains(false)) {\\n            throw new AssertionError();\\n        }\\n    }\\n}\"}", "labels": "{\"task_id\": \"glm/1\", \"programming_language\": \"java\", \"execution_language\": \"java\", \"category\": \"glm\", \"difficulty\": \"easy\", \"fewshot\": \"问题：完成以下编程任务，注意请写出完整代码，包括导入包的代码。请用 markdown code block 格式输出。\\n```python\\ndef find_char_long(text):\\n    \\\"\\\"\\\"\\n    Write a function to find all words which are at least 4 characters long in a string by using regex.\\n    >>> find_char_long('Please move back to stream')\\n    ['Please', 'move', 'back', 'stream']\\n    >>> find_char_long('Jing Eco and Tech')\\n    ['Jing', 'Tech']\\n    >>> find_char_long('Jhingai wulu road Zone 3')\\n    ['Jhingai', 'wulu', 'road', 'Zone']\\n    \\\"\\\"\\\"\\n```\\n\\n答案：\\n```python\\ndef find_char_long(text):\\n    \\\"\\\"\\\"\\n    Write a function to find all words which are at least 4 characters long in a string by using regex.\\n    >>> find_char_long('Please move back to stream')\\n    ['Please', 'move', 'back', 'stream']\\n    >>> find_char_long('Jing Eco and Tech')\\n    ['Jing', 'Tech']\\n    >>> find_char_long('Jhingai wulu road Zone 3')\\n    ['Jhingai', 'wulu', 'road', 'Zone']\\n    \\\"\\\"\\\"\\n    import re\\n\\n    return re.findall(r\\\"\\\\b\\\\w{4,}\\\\b\\\", text)\\n```\\n\\n----------------\\n\\n问题：用 c++ 实现一个 word count 函数，签名为 `std::unordered_map<std::string, int> wordCount(const std::string& text)`\\n\\n答案：\\n```cpp\\n#include <iostream>\\n#include <string>\\n#include <unordered_map>\\n\\nstd::unordered_map<std::string, int> wordCount(const std::string& text) {\\n    std::unordered_map<std::string, int> countMap;\\n    std::string word;\\n    std::size_t startPos = 0;\\n    std::size_t endPos = 0;\\n\\n    while (endPos != std::string::npos) {\\n        endPos = text.find_first_of(\\\" \\\\t\\\\n\\\", startPos);\\n        word = text.substr(startPos, endPos - startPos);\\n        if (!word.empty()) {\\n            ++countMap[word];\\n        }\\n        startPos = text.find_first_not_of(\\\" \\\\t\\\\n\\\", endPos);\\n    }\\n\\n    return countMap;\\n}\\n```\\n\\n----------------\"}"}
{"id": 80, "content": "用 Java 编写一个名为 Solution 的类，类中包含名为 mergeArrays 的函数，该函数接收两个递增的整数数组作为参数，将这两个数组合并然后返回，合并后的数组也是递增的。", "canonical_solution": "", "test": "{\"code\": \"#<INSERT>\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Solution s = new Solution();\\n        List<Boolean> correct = Arrays.asList(Arrays.equals(s.mergeArrays(new int[]{1, 3, 5, 7, 9}, new int[]{0, 2, 4, 6, 8}), new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}),\\n                Arrays.equals(s.mergeArrays(new int[]{1, 2, 3}, new int[]{}), new int[]{1, 2, 3}),\\n                Arrays.equals(s.mergeArrays(new int[]{9, 10}, new int[]{1, 2, 3, 4, 5, 6, 7, 8}), new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})\\n        );\\n        if (correct.contains(false)) {\\n            throw new AssertionError();\\n        }\\n    }\\n}\"}", "labels": "{\"task_id\": \"glm/4\", \"programming_language\": \"java\", \"execution_language\": \"java\", \"category\": \"glm\", \"difficulty\": \"easy\", \"fewshot\": \"问题：完成以下编程任务，注意请写出完整代码，包括导入包的代码。请用 markdown code block 格式输出。\\n```python\\ndef find_char_long(text):\\n    \\\"\\\"\\\"\\n    Write a function to find all words which are at least 4 characters long in a string by using regex.\\n    >>> find_char_long('Please move back to stream')\\n    ['Please', 'move', 'back', 'stream']\\n    >>> find_char_long('Jing Eco and Tech')\\n    ['Jing', 'Tech']\\n    >>> find_char_long('Jhingai wulu road Zone 3')\\n    ['Jhingai', 'wulu', 'road', 'Zone']\\n    \\\"\\\"\\\"\\n```\\n\\n答案：\\n```python\\ndef find_char_long(text):\\n    \\\"\\\"\\\"\\n    Write a function to find all words which are at least 4 characters long in a string by using regex.\\n    >>> find_char_long('Please move back to stream')\\n    ['Please', 'move', 'back', 'stream']\\n    >>> find_char_long('Jing Eco and Tech')\\n    ['Jing', 'Tech']\\n    >>> find_char_long('Jhingai wulu road Zone 3')\\n    ['Jhingai', 'wulu', 'road', 'Zone']\\n    \\\"\\\"\\\"\\n    import re\\n\\n    return re.findall(r\\\"\\\\b\\\\w{4,}\\\\b\\\", text)\\n```\\n\\n----------------\\n\\n问题：用 c++ 实现一个 word count 函数，签名为 `std::unordered_map<std::string, int> wordCount(const std::string& text)`\\n\\n答案：\\n```cpp\\n#include <iostream>\\n#include <string>\\n#include <unordered_map>\\n\\nstd::unordered_map<std::string, int> wordCount(const std::string& text) {\\n    std::unordered_map<std::string, int> countMap;\\n    std::string word;\\n    std::size_t startPos = 0;\\n    std::size_t endPos = 0;\\n\\n    while (endPos != std::string::npos) {\\n        endPos = text.find_first_of(\\\" \\\\t\\\\n\\\", startPos);\\n        word = text.substr(startPos, endPos - startPos);\\n        if (!word.empty()) {\\n            ++countMap[word];\\n        }\\n        startPos = text.find_first_not_of(\\\" \\\\t\\\\n\\\", endPos);\\n    }\\n\\n    return countMap;\\n}\\n```\\n\\n----------------\"}"}
{"id": 78, "content": "用 C 语言编写一个名为 calculate_sums 的函数，该函数接收一个二维数组作为参数，返回这个二维数组外围元素和下三角元素的和。", "canonical_solution": "", "test": "{\"code\": \"#<INSERT>\\n\\n#undef NDEBUG\\n#include <stdio.h>\\n#include<assert.h>\\nint main()\\n{\\n    int a[4][4] =\\n    {\\n        {1, 2, 3, 4},\\n        {5, 6, 7, 8},\\n        {9, 10, 11, 12}\\n        {13, 14, 15, 16}\\n    };\\n    int peripheral_sum, lower_triangle_sum, higher_triangle_sum;\\n    calculate_sums(a, &peripheral_sum, &lower_triangle_sum, &higher_triangle_sum);\\n    \\n    assert(peripheral_sum == 102);\\n    assert(lower_triangle_sum == 100);\\n    assert(higher_triangle_sum == 70);\\n}\"}", "labels": "{\"task_id\": \"glm/2\", \"programming_language\": \"c\", \"execution_language\": \"cpp\", \"category\": \"glm\", \"difficulty\": \"easy\", \"fewshot\": \"问题：完成以下编程任务，注意请写出完整代码，包括导入包的代码。请用 markdown code block 格式输出。\\n```python\\ndef find_char_long(text):\\n    \\\"\\\"\\\"\\n    Write a function to find all words which are at least 4 characters long in a string by using regex.\\n    >>> find_char_long('Please move back to stream')\\n    ['Please', 'move', 'back', 'stream']\\n    >>> find_char_long('Jing Eco and Tech')\\n    ['Jing', 'Tech']\\n    >>> find_char_long('Jhingai wulu road Zone 3')\\n    ['Jhingai', 'wulu', 'road', 'Zone']\\n    \\\"\\\"\\\"\\n```\\n\\n答案：\\n```python\\ndef find_char_long(text):\\n    \\\"\\\"\\\"\\n    Write a function to find all words which are at least 4 characters long in a string by using regex.\\n    >>> find_char_long('Please move back to stream')\\n    ['Please', 'move', 'back', 'stream']\\n    >>> find_char_long('Jing Eco and Tech')\\n    ['Jing', 'Tech']\\n    >>> find_char_long('Jhingai wulu road Zone 3')\\n    ['Jhingai', 'wulu', 'road', 'Zone']\\n    \\\"\\\"\\\"\\n    import re\\n\\n    return re.findall(r\\\"\\\\b\\\\w{4,}\\\\b\\\", text)\\n```\\n\\n----------------\\n\\n问题：用 c++ 实现一个 word count 函数，签名为 `std::unordered_map<std::string, int> wordCount(const std::string& text)`\\n\\n答案：\\n```cpp\\n#include <iostream>\\n#include <string>\\n#include <unordered_map>\\n\\nstd::unordered_map<std::string, int> wordCount(const std::string& text) {\\n    std::unordered_map<std::string, int> countMap;\\n    std::string word;\\n    std::size_t startPos = 0;\\n    std::size_t endPos = 0;\\n\\n    while (endPos != std::string::npos) {\\n        endPos = text.find_first_of(\\\" \\\\t\\\\n\\\", startPos);\\n        word = text.substr(startPos, endPos - startPos);\\n        if (!word.empty()) {\\n            ++countMap[word];\\n        }\\n        startPos = text.find_first_not_of(\\\" \\\\t\\\\n\\\", endPos);\\n    }\\n\\n    return countMap;\\n}\\n```\\n\\n----------------\"}"}
{"id": 79, "content": "用C语言编写一个processArray函数，该函数接受一个二维整数数组的指针和两个整数（分别代表二维数组的行和列数）作为参数，返回一个一维数组，该一维数组的元素为二维数组每行元素的平均值。", "canonical_solution": "", "test": "{\"code\": \"#<INSERT>\\n\\n#undef NDEBUG\\n#include <assert.h>\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <math.h>\\nint main()\\n{\\n    // 正常数据\\n    int rows1 = 3;\\n    int cols1 = 4;\\n    int data[3][4] =\\n    {\\n        {1, 2, 3, 4},\\n        {5, 6, 7, 8},\\n        {9, 10, 11, 12}\\n    };\\n    int **a = (int **)malloc(rows1 * sizeof(int *));\\n    for (int i = 0; i < rows1; i++)\\n    {\\n        a[i] = data[i];\\n    }\\n    double *averages = processArray(a, rows1, cols1);\\n    assert(fabs(averages[0] - 2.5) < 0.0001);\\n    assert(fabs(averages[1] - 6.5) < 0.0001);\\n    assert(fabs(averages[2] - 10.5) < 0.0001);\\n    // 单行测试数据\\n    int rows2 = 1;\\n    int cols2 = 4;\\n    int data2[1][4] =\\n    {\\n        {1, 2, 3, 4}\\n    };\\n    int **a2 = (int **)malloc(rows2 * sizeof(int *));\\n    a2[0] = data2[0];\\n    double *averages2 = processArray(a2, rows2, cols2);\\n    assert(fabs(averages2[0] - 2.5) < 0.0001);\\n    // 单列测试数据\\n    int rows3 = 3;\\n    int cols3 = 1;\\n    int data3[3][1] =\\n    {\\n        {1},\\n        {5},\\n        {9}\\n    };\\n    int **a3 = (int **)malloc(rows3 * sizeof(int *));\\n    for (int i = 0; i < rows3; i++)\\n    {\\n        a3[i] = data3[i];\\n    }\\n    double *averages3 = processArray(a3, rows3, cols3);\\n    assert(fabs(averages3[0] - 1.0) < 0.0001);\\n    assert(fabs(averages3[1] - 5.0) < 0.0001);\\n    assert(fabs(averages3[2] - 9.0) < 0.0001);\\n    return 0;\\n}\"}", "labels": "{\"task_id\": \"glm/3\", \"programming_language\": \"c\", \"execution_language\": \"cpp\", \"category\": \"glm\", \"difficulty\": \"easy\", \"fewshot\": \"问题：完成以下编程任务，注意请写出完整代码，包括导入包的代码。请用 markdown code block 格式输出。\\n```python\\ndef find_char_long(text):\\n    \\\"\\\"\\\"\\n    Write a function to find all words which are at least 4 characters long in a string by using regex.\\n    >>> find_char_long('Please move back to stream')\\n    ['Please', 'move', 'back', 'stream']\\n    >>> find_char_long('Jing Eco and Tech')\\n    ['Jing', 'Tech']\\n    >>> find_char_long('Jhingai wulu road Zone 3')\\n    ['Jhingai', 'wulu', 'road', 'Zone']\\n    \\\"\\\"\\\"\\n```\\n\\n答案：\\n```python\\ndef find_char_long(text):\\n    \\\"\\\"\\\"\\n    Write a function to find all words which are at least 4 characters long in a string by using regex.\\n    >>> find_char_long('Please move back to stream')\\n    ['Please', 'move', 'back', 'stream']\\n    >>> find_char_long('Jing Eco and Tech')\\n    ['Jing', 'Tech']\\n    >>> find_char_long('Jhingai wulu road Zone 3')\\n    ['Jhingai', 'wulu', 'road', 'Zone']\\n    \\\"\\\"\\\"\\n    import re\\n\\n    return re.findall(r\\\"\\\\b\\\\w{4,}\\\\b\\\", text)\\n```\\n\\n----------------\\n\\n问题：用 c++ 实现一个 word count 函数，签名为 `std::unordered_map<std::string, int> wordCount(const std::string& text)`\\n\\n答案：\\n```cpp\\n#include <iostream>\\n#include <string>\\n#include <unordered_map>\\n\\nstd::unordered_map<std::string, int> wordCount(const std::string& text) {\\n    std::unordered_map<std::string, int> countMap;\\n    std::string word;\\n    std::size_t startPos = 0;\\n    std::size_t endPos = 0;\\n\\n    while (endPos != std::string::npos) {\\n        endPos = text.find_first_of(\\\" \\\\t\\\\n\\\", startPos);\\n        word = text.substr(startPos, endPos - startPos);\\n        if (!word.empty()) {\\n            ++countMap[word];\\n        }\\n        startPos = text.find_first_not_of(\\\" \\\\t\\\\n\\\", endPos);\\n    }\\n\\n    return countMap;\\n}\\n```\\n\\n----------------\"}"}

{"content": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n", "id": "HumanEval_105_by_length", "labels": "{\"canonical_solution\":\"\", \"language\":\"cpp\"}", "test": "{\"test\": \"}\\nint main() {\\n    auto candidate = by_length;\\n    assert(candidate((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3}))) == (std::vector<std::string>({(std::string)\\\"Eight\\\", (std::string)\\\"Five\\\", (std::string)\\\"Four\\\", (std::string)\\\"Three\\\", (std::string)\\\"Two\\\", (std::string)\\\"Two\\\", (std::string)\\\"One\\\", (std::string)\\\"One\\\"})));\\n    assert(candidate((std::vector<long>())) == (std::vector<std::string>()));\\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)55}))) == (std::vector<std::string>({(std::string)\\\"One\\\"})));\\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)3, (long)2}))) == (std::vector<std::string>({(std::string)\\\"Three\\\", (std::string)\\\"Two\\\", (std::string)\\\"One\\\"})));\\n    assert(candidate((std::vector<long>({(long)9, (long)4, (long)8}))) == (std::vector<std::string>({(std::string)\\\"Nine\\\", (std::string)\\\"Eight\\\", (std::string)\\\"Four\\\"})));\\n}\\n\", \"stop_tokens\": [\"\\n}\"]}", "__internal_uuid__": "ed4853cd-429d-44ab-9c44-0af19626471d"}
{"content": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n", "id": "HumanEval_115_max_fill", "labels": "{\"canonical_solution\":\"\", \"language\":\"cpp\"}", "test": "{\"test\": \"}\\nint main() {\\n    auto candidate = max_fill;\\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\\n}\\n\", \"stop_tokens\": [\"\\n}\"]}", "__internal_uuid__": "66f2dcb4-6e8a-420c-8013-8687a0986df8"}
{"content": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n", "id": "HumanEval_140_fix_spaces", "labels": "{\"canonical_solution\":\"\", \"language\":\"cpp\"}", "test": "{\"test\": \"}\\nint main() {\\n    auto candidate = fix_spaces;\\n    assert(candidate((\\\"Example\\\")) == (\\\"Example\\\"));\\n    assert(candidate((\\\"Mudasir Hanif \\\")) == (\\\"Mudasir_Hanif_\\\"));\\n    assert(candidate((\\\"Yellow Yellow  Dirty  Fellow\\\")) == (\\\"Yellow_Yellow__Dirty__Fellow\\\"));\\n    assert(candidate((\\\"Exa   mple\\\")) == (\\\"Exa-mple\\\"));\\n    assert(candidate((\\\"   Exa 1 2 2 mple\\\")) == (\\\"-Exa_1_2_2_mple\\\"));\\n}\\n\", \"stop_tokens\": [\"\\n}\"]}", "__internal_uuid__": "4bba0428-9e62-479b-b16c-1a7995dc90c7"}
{"content": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n", "id": "HumanEval_14_all_prefixes", "labels": "{\"canonical_solution\":\"\", \"language\":\"cpp\"}", "test": "{\"test\": \"}\\nint main() {\\n    auto candidate = all_prefixes;\\n    assert(candidate((\\\"\\\")) == (std::vector<std::string>()));\\n    assert(candidate((\\\"asdfgh\\\")) == (std::vector<std::string>({(std::string)\\\"a\\\", (std::string)\\\"as\\\", (std::string)\\\"asd\\\", (std::string)\\\"asdf\\\", (std::string)\\\"asdfg\\\", (std::string)\\\"asdfgh\\\"})));\\n    assert(candidate((\\\"WWW\\\")) == (std::vector<std::string>({(std::string)\\\"W\\\", (std::string)\\\"WW\\\", (std::string)\\\"WWW\\\"})));\\n}\\n\", \"stop_tokens\": [\"\\n}\"]}", "__internal_uuid__": "7d5bd4a5-0fee-4f9f-8a33-9cd486bf8157"}
{"content": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n", "id": "HumanEval_151_double_the_difference", "labels": "{\"canonical_solution\":\"\", \"language\":\"cpp\"}", "test": "{\"test\": \"}\\nint main() {\\n    auto candidate = double_the_difference;\\n    assert(candidate((std::vector<float>())) == (0));\\n    assert(candidate((std::vector<float>({(float)5.0f, (float)4.0f}))) == (25));\\n    assert(candidate((std::vector<float>({(float)0.1f, (float)0.2f, (float)0.3f}))) == (0));\\n    assert(candidate((std::vector<float>({(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0));\\n    assert(candidate((std::vector<float>({(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0));\\n    assert(candidate((std::vector<float>({(float)0.2f, (float)3.0f, (float)5.0f}))) == (34));\\n    assert(candidate((std::vector<float>({(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165));\\n}\\n\", \"stop_tokens\": [\"\\n}\"]}", "__internal_uuid__": "35977902-58d2-4ffd-9f37-7f31f0c9ed81"}
{"content": "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n", "id": "HumanEval_159_eat", "labels": "{\"canonical_solution\":\"\", \"language\":\"cpp\"}", "test": "{\"test\": \"}\\nint main() {\\n    auto candidate = eat;\\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\\n}\\n\", \"stop_tokens\": [\"\\n}\"]}", "__internal_uuid__": "fecc13b6-2578-402d-9ce6-1594930166d5"}
{"content": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n", "id": "HumanEval_160_do_algebra", "labels": "{\"canonical_solution\":\"\", \"language\":\"cpp\"}", "test": "{\"test\": \"}\\nint main() {\\n    auto candidate = do_algebra;\\n    assert(candidate((std::vector<std::string>({(std::string)\\\"**\\\", (std::string)\\\"*\\\", (std::string)\\\"+\\\"})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (37));\\n    assert(candidate((std::vector<std::string>({(std::string)\\\"+\\\", (std::string)\\\"*\\\", (std::string)\\\"-\\\"})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (9));\\n    assert(candidate((std::vector<std::string>({(std::string)\\\"//\\\", (std::string)\\\"*\\\"})), (std::vector<long>({(long)7, (long)3, (long)4}))) == (8));\\n}\\n\", \"stop_tokens\": [\"\\n}\"]}", "__internal_uuid__": "aeca240b-276c-4272-a87f-3fe1c4d02958"}
{"content": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n", "id": "HumanEval_17_parse_music", "labels": "{\"canonical_solution\":\"\", \"language\":\"cpp\"}", "test": "{\"test\": \"}\\nint main() {\\n    auto candidate = parse_music;\\n    assert(candidate((\\\"\\\")) == (std::vector<long>()));\\n    assert(candidate((\\\"o o o o\\\")) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));\\n    assert(candidate((\\\".| .| .| .|\\\")) == (std::vector<long>({(long)1, (long)1, (long)1, (long)1})));\\n    assert(candidate((\\\"o| o| .| .| o o o o\\\")) == (std::vector<long>({(long)2, (long)2, (long)1, (long)1, (long)4, (long)4, (long)4, (long)4})));\\n    assert(candidate((\\\"o| .| o| .| o o| o o|\\\")) == (std::vector<long>({(long)2, (long)1, (long)2, (long)1, (long)4, (long)2, (long)4, (long)2})));\\n}\\n\", \"stop_tokens\": [\"\\n}\"]}", "__internal_uuid__": "12124d05-3362-4dfd-94ae-f030dd2e82bf"}
{"content": "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n", "id": "HumanEval_22_filter_integers", "labels": "{\"canonical_solution\":\"\", \"language\":\"cpp\"}", "test": "{\"test\": \"}\\nint main() {\\n    auto candidate = filter_integers;\\n    assert(candidate((std::vector<std::any>())) == (std::vector<long>()));\\n    assert(candidate((std::vector<std::any>({4, std::map<long,long>(), std::vector<long>(), 23.2f, 9, \\\"adasd\\\"}))) == (std::vector<long>({(long)4, (long)9})));\\n    assert(candidate((std::vector<std::any>({3, \\\"c\\\", 3, 3, \\\"a\\\", \\\"b\\\"}))) == (std::vector<long>({(long)3, (long)3, (long)3})));\\n}\\n\", \"stop_tokens\": [\"\\n}\"]}", "__internal_uuid__": "5f9d8ec6-a74f-4040-b688-8c4bbc17e3da"}
{"content": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n", "id": "HumanEval_23_strlen", "labels": "{\"canonical_solution\":\"\", \"language\":\"cpp\"}", "test": "{\"test\": \"}\\nint main() {\\n    auto candidate = string_length;\\n    assert(candidate((\\\"\\\")) == (0));\\n    assert(candidate((\\\"x\\\")) == (1));\\n    assert(candidate((\\\"asdasnakj\\\")) == (9));\\n}\\n\", \"stop_tokens\": [\"\\n}\"]}", "__internal_uuid__": "e377b2b7-f1ea-4bca-8481-6a25e67b49aa"}
{"content": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n", "id": "HumanEval_25_factorize", "labels": "{\"canonical_solution\":\"\", \"language\":\"cpp\"}", "test": "{\"test\": \"}\\nint main() {\\n    auto candidate = factorize;\\n    assert(candidate((2)) == (std::vector<long>({(long)2})));\\n    assert(candidate((4)) == (std::vector<long>({(long)2, (long)2})));\\n    assert(candidate((8)) == (std::vector<long>({(long)2, (long)2, (long)2})));\\n    assert(candidate((57)) == (std::vector<long>({(long)3, (long)19})));\\n    assert(candidate((3249)) == (std::vector<long>({(long)3, (long)3, (long)19, (long)19})));\\n    assert(candidate((185193)) == (std::vector<long>({(long)3, (long)3, (long)3, (long)19, (long)19, (long)19})));\\n    assert(candidate((20577)) == (std::vector<long>({(long)3, (long)19, (long)19, (long)19})));\\n    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)3})));\\n}\\n\", \"stop_tokens\": [\"\\n}\"]}", "__internal_uuid__": "0bd6b35d-8bb7-4e2d-9cac-d568d7673bb3"}
{"content": "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n", "id": "HumanEval_27_flip_case", "labels": "{\"canonical_solution\":\"\", \"language\":\"cpp\"}", "test": "{\"test\": \"}\\nint main() {\\n    auto candidate = flip_case;\\n    assert(candidate((\\\"\\\")) == (\\\"\\\"));\\n    assert(candidate((\\\"Hello!\\\")) == (\\\"hELLO!\\\"));\\n    assert(candidate((\\\"These violent delights have violent ends\\\")) == (\\\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\\\"));\\n}\\n\", \"stop_tokens\": [\"\\n}\"]}", "__internal_uuid__": "25512b51-672c-49c2-992e-4512f6ff1f01"}
{"content": "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n", "id": "HumanEval_41_car_race_collision", "labels": "{\"canonical_solution\":\"\", \"language\":\"cpp\"}", "test": "{\"test\": \"}\\nint main() {\\n    auto candidate = car_race_collision;\\n    assert(candidate((2)) == (4));\\n    assert(candidate((3)) == (9));\\n    assert(candidate((4)) == (16));\\n    assert(candidate((8)) == (64));\\n    assert(candidate((10)) == (100));\\n}\\n\", \"stop_tokens\": [\"\\n}\"]}", "__internal_uuid__": "fa6c2070-b343-4a07-b007-2d56cd6ff505"}
{"content": "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n", "id": "HumanEval_53_add", "labels": "{\"canonical_solution\":\"\", \"language\":\"cpp\"}", "test": "{\"test\": \"}\\nint main() {\\n    auto candidate = add;\\n    assert(candidate((0), (1)) == (1));\\n    assert(candidate((1), (0)) == (1));\\n    assert(candidate((2), (3)) == (5));\\n    assert(candidate((5), (7)) == (12));\\n    assert(candidate((7), (5)) == (12));\\n}\\n\", \"stop_tokens\": [\"\\n}\"]}", "__internal_uuid__": "f3680c4f-bc58-4b8f-98b5-e947b713a295"}
{"content": "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n", "id": "HumanEval_63_fibfib", "labels": "{\"canonical_solution\":\"\", \"language\":\"cpp\"}", "test": "{\"test\": \"}\\nint main() {\\n    auto candidate = fibfib;\\n    assert(candidate((2)) == (1));\\n    assert(candidate((1)) == (0));\\n    assert(candidate((5)) == (4));\\n    assert(candidate((8)) == (24));\\n    assert(candidate((10)) == (81));\\n    assert(candidate((12)) == (274));\\n    assert(candidate((14)) == (927));\\n}\\n\", \"stop_tokens\": [\"\\n}\"]}", "__internal_uuid__": "d6714ae6-2f97-4a66-b854-cde44b59439a"}
{"content": "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n", "id": "HumanEval_79_decimal_to_binary", "labels": "{\"canonical_solution\":\"\", \"language\":\"cpp\"}", "test": "{\"test\": \"}\\nint main() {\\n    auto candidate = decimal_to_binary;\\n    assert(candidate((0)) == (\\\"db0db\\\"));\\n    assert(candidate((32)) == (\\\"db100000db\\\"));\\n    assert(candidate((103)) == (\\\"db1100111db\\\"));\\n    assert(candidate((15)) == (\\\"db1111db\\\"));\\n}\\n\", \"stop_tokens\": [\"\\n}\"]}", "__internal_uuid__": "609336f1-5fb5-4b2d-b1df-345bbe37bfce"}
{"content": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n", "id": "HumanEval_85_add", "labels": "{\"canonical_solution\":\"\", \"language\":\"cpp\"}", "test": "{\"test\": \"}\\nint main() {\\n    auto candidate = add;\\n    assert(candidate((std::vector<long>({(long)4, (long)88}))) == (88));\\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)7, (long)2, (long)122}))) == (122));\\n    assert(candidate((std::vector<long>({(long)4, (long)0, (long)6, (long)7}))) == (0));\\n    assert(candidate((std::vector<long>({(long)4, (long)4, (long)6, (long)8}))) == (12));\\n}\\n\", \"stop_tokens\": [\"\\n}\"]}", "__internal_uuid__": "8aee5a58-b1fd-4ac1-96cc-2b835d7ab9d4"}
{"content": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n", "id": "HumanEval_89_encrypt", "labels": "{\"canonical_solution\":\"\", \"language\":\"cpp\"}", "test": "{\"test\": \"}\\nint main() {\\n    auto candidate = encrypt;\\n    assert(candidate((\\\"hi\\\")) == (\\\"lm\\\"));\\n    assert(candidate((\\\"asdfghjkl\\\")) == (\\\"ewhjklnop\\\"));\\n    assert(candidate((\\\"gf\\\")) == (\\\"kj\\\"));\\n    assert(candidate((\\\"et\\\")) == (\\\"ix\\\"));\\n    assert(candidate((\\\"faewfawefaewg\\\")) == (\\\"jeiajeaijeiak\\\"));\\n    assert(candidate((\\\"hellomyfriend\\\")) == (\\\"lippsqcjvmirh\\\"));\\n    assert(candidate((\\\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\\\")) == (\\\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\\\"));\\n    assert(candidate((\\\"a\\\")) == (\\\"e\\\"));\\n}\\n\", \"stop_tokens\": [\"\\n}\"]}", "__internal_uuid__": "a23509b9-b769-44ef-8a0a-d57111e51022"}
{"content": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n", "id": "HumanEval_95_check_dict_case", "labels": "{\"canonical_solution\":\"\", \"language\":\"cpp\"}", "test": "{\"test\": \"}\\nint main() {\\n    auto candidate = check_dict_case;\\n    assert(candidate((std::map<std::string,std::string>({{\\\"p\\\", \\\"pineapple\\\"}, {\\\"b\\\", \\\"banana\\\"}}))) == (true));\\n    assert(candidate((std::map<std::string,std::string>({{\\\"p\\\", \\\"pineapple\\\"}, {\\\"A\\\", \\\"banana\\\"}, {\\\"B\\\", \\\"banana\\\"}}))) == (false));\\n    assert(candidate((std::map<std::string,std::string>({{\\\"p\\\", \\\"pineapple\\\"}, {\\\"5\\\", \\\"banana\\\"}, {\\\"a\\\", \\\"apple\\\"}}))) == (false));\\n    assert(candidate((std::map<std::string,std::string>({{\\\"Name\\\", \\\"John\\\"}, {\\\"Age\\\", \\\"36\\\"}, {\\\"City\\\", \\\"Houston\\\"}}))) == (false));\\n    assert(candidate((std::map<std::string,std::string>({{\\\"STATE\\\", \\\"NC\\\"}, {\\\"ZIP\\\", \\\"12345\\\"}}))) == (true));\\n    assert(candidate((std::map<std::string,std::string>({{\\\"fruit\\\", \\\"Orange\\\"}, {\\\"taste\\\", \\\"Sweet\\\"}}))) == (true));\\n    assert(candidate((std::map<std::string,std::string>())) == (false));\\n}\\n\", \"stop_tokens\": [\"\\n}\"]}", "__internal_uuid__": "b145c81b-edfd-4076-8581-822ee293a537"}
{"content": "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n", "id": "HumanEval_96_count_up_to", "labels": "{\"canonical_solution\":\"\", \"language\":\"cpp\"}", "test": "{\"test\": \"}\\nint main() {\\n    auto candidate = count_up_to;\\n    assert(candidate((5)) == (std::vector<long>({(long)2, (long)3})));\\n    assert(candidate((6)) == (std::vector<long>({(long)2, (long)3, (long)5})));\\n    assert(candidate((7)) == (std::vector<long>({(long)2, (long)3, (long)5})));\\n    assert(candidate((10)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7})));\\n    assert(candidate((0)) == (std::vector<long>()));\\n    assert(candidate((22)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19})));\\n    assert(candidate((1)) == (std::vector<long>()));\\n    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17})));\\n    assert(candidate((47)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43})));\\n    assert(candidate((101)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43, (long)47, (long)53, (long)59, (long)61, (long)67, (long)71, (long)73, (long)79, (long)83, (long)89, (long)97})));\\n}\\n\", \"stop_tokens\": [\"\\n}\"]}", "__internal_uuid__": "6d09b2cf-97ce-41f2-80e0-423484ebfd40"}

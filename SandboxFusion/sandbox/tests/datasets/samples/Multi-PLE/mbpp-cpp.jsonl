{"name":"mbpp_3_is_not_prime","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to identify non-prime numbers.\nbool is_not_prime(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_3_is_not_prime.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = is_not_prime;\n    assert(candidate((2)) == (false));\n    assert(candidate((10)) == (true));\n    assert(candidate((35)) == (true));\n    assert(candidate((37)) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_3_is_not_prime","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Write a cpp function to identify non-prime numbers.\nbool is_not_prime(long n) {\n    \/\/ Handle corner cases\n    if (n <= 1) return true;\n    if (n <= 3) return false;\n\n    \/\/ This is checked so that we can skip \n    \/\/ middle five numbers in below loop\n    if (n % 2 == 0 || n % 3 == 0) return true;\n\n    for (long i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return true;\n\n    return false;\n}\n\n\/\/ Helper function for testing\nvoid test() {\n    assert(is_not_prime(1) == true);   \/\/ 1 is not prime\n    assert(is_not_prime(2) == false);  \/\/ 2 is prime\n    assert(is_not_prime(3) == false);  \/\/ 3 is prime\n    assert(is_not_prime(4) == true);   \/\/ 4 is not prime\n    assert(is_not_prime(5) == false);  \/\/ 5 is prime\n    assert(is_not_prime(9) == true);   \/\/ 9 is not prime\n    assert(is_not_prime(15) == true);  \/\/ 15 is not prime\n    assert(is_not_prime(17) == false); \/\/ 17 is prime\n}\n\n\/\/ Uncomment the following line to run the test function\n\/\/ test();\n```\n\nThis code defines a function `is_not_prime` to check whether a number is not a prime. The function includes checks for base cases and an efficient algorithm to confirm non-prime status by checking divisibility. The `test` function contains assertions for various cases to ensure that `is_not_prime` works as expected. Note that the `test` function is left commented out to prevent it from running automatically; it can be uncommented for testing purposes."}
{"name":"mbpp_4_heap_queue_largest","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the n largest integers from a given vector of numbers, returned in descending order.\nstd::vector<long> heap_queue_largest(std::vector<long> nums, long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_4_heap_queue_largest.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = heap_queue_largest;\n    assert(candidate((std::vector<long>({(long)25, (long)35, (long)22, (long)85, (long)14, (long)65, (long)75, (long)22, (long)58})), (3)) == (std::vector<long>({(long)85, (long)75, (long)65})));\n    assert(candidate((std::vector<long>({(long)25, (long)35, (long)22, (long)85, (long)14, (long)65, (long)75, (long)22, (long)58})), (2)) == (std::vector<long>({(long)85, (long)75})));\n    assert(candidate((std::vector<long>({(long)25, (long)35, (long)22, (long)85, (long)14, (long)65, (long)75, (long)22, (long)58})), (5)) == (std::vector<long>({(long)85, (long)75, (long)65, (long)58, (long)35})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_4_heap_queue_largest","gpt_solution":"```cpp\n#include <vector>\n#include <queue>\n#include <functional>\n#include <assert.h>\n#include <bits\/stdc++.h>\n\nstd::vector<long> heap_queue_largest(std::vector<long> nums, long n) {\n    \/\/ Using a min-heap to maintain the n largest elements\n    std::priority_queue<long, std::vector<long>, std::greater<long>> min_heap;\n\n    \/\/ Iterate over all the elements in the given vector\n    for (const long& num : nums) {\n        \/\/ If the size of the heap is less than n, push the current number\n        if (min_heap.size() < n) {\n            min_heap.push(num);\n        } \n        \/\/ Otherwise, if the current number is larger than the smallest in the heap, replace it\n        else if (num > min_heap.top()) {\n            min_heap.pop();\n            min_heap.push(num);\n        }\n    }\n\n    \/\/ Extract the elements from the heap into a vector\n    std::vector<long> result;\n    while (!min_heap.empty()) {\n        result.push_back(min_heap.top());\n        min_heap.pop();\n    }\n\n    \/\/ Sort the result in descending order (greatest to smallest)\n    std::sort(result.begin(), result.end(), std::greater<long>());\n\n    return result;\n}\n```"}
{"name":"mbpp_6_differ_At_One_Bit_Pos","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to check whether the two numbers differ at one bit position only or not.\nbool differ_At_One_Bit_Pos(long a, long b) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_6_differ_At_One_Bit_Pos.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = differ_At_One_Bit_Pos;\n    assert(candidate((13), (9)) == (true));\n    assert(candidate((15), (8)) == (false));\n    assert(candidate((2), (4)) == (false));\n    assert(candidate((2), (3)) == (true));\n    assert(candidate((5), (1)) == (true));\n    assert(candidate((1), (5)) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_6_differ_At_One_Bit_Pos","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to check whether the two numbers differ at one bit position only or not.\nbool differ_At_One_Bit_Pos(long a, long b) {\n    long xor_result = a ^ b;\n    \n    \/\/ Check if xor_result has only one bit set\n    return xor_result && !(xor_result & (xor_result - 1));\n}\n```\n\nThis function compares two numbers to check if they differ by exactly one bit position. It uses the XOR operator to determine the positions where the bits differ and then checks if the resulting number has exactly one bit set using a standard bit manipulation technique. If the result of \\( a \\) XOR \\( b \\) has exactly one bit set, the two numbers differ by exactly one bit position."}
{"name":"mbpp_8_square_nums","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find squares of individual elements in a vector.\nstd::vector<long> square_nums(std::vector<long> nums) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_8_square_nums.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = square_nums;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (std::vector<long>({(long)1, (long)4, (long)9, (long)16, (long)25, (long)36, (long)49, (long)64, (long)81, (long)100})));\n    assert(candidate((std::vector<long>({(long)10, (long)20, (long)30}))) == (std::vector<long>({(long)100, (long)400, (long)900})));\n    assert(candidate((std::vector<long>({(long)12, (long)15}))) == (std::vector<long>({(long)144, (long)225})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_8_square_nums","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find squares of individual elements in a vector.\nstd::vector<long> square_nums(std::vector<long> nums) {\n    std::vector<long> squared_nums;\n    for(long num : nums) {\n        squared_nums.push_back(num * num);\n    }\n    return squared_nums;\n}\n```"}
{"name":"mbpp_9_find_Rotations","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the minimum number of rotations (greater than 0) required to get the same string.\nlong find_Rotations(std::string str) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_9_find_Rotations.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_Rotations;\n    assert(candidate((\"aaaa\")) == (1));\n    assert(candidate((\"ab\")) == (2));\n    assert(candidate((\"abc\")) == (3));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_9_find_Rotations","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the minimum number of rotations (greater than 0) required to get the same string.\nlong find_Rotations(std::string str) {\n    std::string doubled_str = str + str;\n    int n = str.size();\n\n    for (int i = 1; i < n; i++) {\n        if (doubled_str.substr(i, n) == str) {\n            return i;\n        }\n    }\n    return n; \/\/ If no rotation gives the same string, return the length of the string.\n}\n```\n\nThis function calculates the minimum number of rotations (greater than 0) required to return to the same string. It does this by doubling the input string and checking each possible rotation."}
{"name":"mbpp_11_remove_Occ","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to remove first and last occurrence of a given character from the string.\nstd::string remove_Occ(std::string s, std::string ch) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_11_remove_Occ.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = remove_Occ;\n    assert(candidate((\"hello\"), (\"l\")) == (\"heo\"));\n    assert(candidate((\"abcda\"), (\"a\")) == (\"bcd\"));\n    assert(candidate((\"PHP\"), (\"P\")) == (\"H\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_11_remove_Occ","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cppthon function to remove first and last occurrence of a given character from the string.\nstd::string remove_Occ(std::string s, std::string ch) {\n    char c = ch[0]; \/\/ Convert the string to a character\n\n    \/\/ Find the first occurrence\n    size_t first_occurrence = s.find(c);\n    if (first_occurrence != std::string::npos) {\n        s.erase(first_occurrence, 1);\n    }\n\n    \/\/ Find the last occurrence\n    size_t last_occurrence = s.rfind(c);\n    if (last_occurrence != std::string::npos) {\n        s.erase(last_occurrence, 1);\n    }\n\n    return s;\n}\n```"}
{"name":"mbpp_12_sort_matrix","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to sort a given matrix in ascending order according to the sum of its rows.\nstd::vector<std::vector<long>> sort_matrix(std::vector<std::vector<long>> M) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_12_sort_matrix.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sort_matrix;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)2, (long)4, (long)5}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1})}))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)2, (long)4, (long)5})})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)-2, (long)4, (long)-5}), (std::vector<long>)std::vector<long>({(long)1, (long)-1, (long)1})}))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)-2, (long)4, (long)-5}), (std::vector<long>)std::vector<long>({(long)1, (long)-1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)6, (long)4, (long)3}), (std::vector<long>)std::vector<long>({(long)2, (long)1, (long)4})}))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)6, (long)4, (long)3}), (std::vector<long>)std::vector<long>({(long)5, (long)8, (long)9})})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_12_sort_matrix","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to sort a given matrix in ascending order according to the sum of its rows.\nstd::vector<std::vector<long>> sort_matrix(std::vector<std::vector<long>> M) {\n    \/\/ Calculate the sum of each row and store it along with the corresponding row index\n    std::vector<std::pair<long, std::vector<long>>> rows_with_sums;\n    for (const auto& row : M) {\n        long sum = std::accumulate(row.begin(), row.end(), 0L);\n        rows_with_sums.push_back({sum, row});\n    }\n\n    \/\/ Sort the rows based on the calculated sum\n    std::sort(rows_with_sums.begin(), rows_with_sums.end());\n\n    \/\/ Extract the sorted rows\n    std::vector<std::vector<long>> sorted_matrix;\n    for (const auto& pair : rows_with_sums) {\n        sorted_matrix.push_back(pair.second);\n    }\n\n    return sorted_matrix;\n}\n```"}
{"name":"mbpp_14_find_Volume","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the volume of a triangular prism.\nlong find_Volume(long l, long b, long h) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_14_find_Volume.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_Volume;\n    assert(candidate((10), (8), (6)) == (240));\n    assert(candidate((3), (2), (2)) == (6));\n    assert(candidate((1), (2), (1)) == (1));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_14_find_Volume","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to find the volume of a triangular prism\n\/\/ The formula for the volume of a triangular prism is: V = 0.5 * base_length * height * length\nlong find_Volume(long b, long h, long l) {\n    return 0.5 * b * h * l;\n}\n```"}
{"name":"mbpp_16_text_lowercase_underscore","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\nbool text_lowercase_underscore(std::string text) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_16_text_lowercase_underscore.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = text_lowercase_underscore;\n    assert(candidate((\"aab_cbbbc\")) == (true));\n    assert(candidate((\"aab_Abbbc\")) == (false));\n    assert(candidate((\"Aaab_abbbc\")) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_16_text_lowercase_underscore","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\nbool text_lowercase_underscore(std::string text) {\n    \/\/ Check if the string is empty.\n    if (text.empty()) return false;\n    \n    \/\/ Iterate through the string and check the conditions.\n    for (size_t i = 0; i < text.length(); ++i) {\n        char c = text[i];\n        if (c != '_' && !islower(c)) {\n            return false;\n        }\n    }\n    \n    \/\/ Split the string by underscores and check each segment to ensure it's not empty.\n    std::stringstream ss(text);\n    std::string segment;\n    while (std::getline(ss, segment, '_')) {\n        if (segment.empty()) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n\nThis function `text_lowercase_underscore` checks if an input string consists of sequences of lowercase letters separated by underscores. It ensures that:\n1. The string is not empty.\n2. Each character in the string is either a lowercase letter or an underscore.\n3. Substrings split by underscores are not empty (i.e., there are no consecutive underscores nor starting\/ending underscores).\n\nYou can compile and test this function in your own environment or within a larger program."}
{"name":"mbpp_17_square_perimeter","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that returns the perimeter of a square given its side length as input.\nlong square_perimeter(long a) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_17_square_perimeter.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = square_perimeter;\n    assert(candidate((10)) == (40));\n    assert(candidate((5)) == (20));\n    assert(candidate((4)) == (16));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_17_square_perimeter","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\nusing namespace std;\n\n\/\/ Write a function that returns the perimeter of a square given its side length as input.\nlong square_perimeter(long a) {\n    return 4 * a;\n}\n```"}
{"name":"mbpp_18_remove_dirty_chars","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to remove characters from the first string which are present in the second string.\nstd::string remove_dirty_chars(std::string string, std::string second_string) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_18_remove_dirty_chars.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = remove_dirty_chars;\n    assert(candidate((\"probasscurve\"), (\"pros\")) == (\"bacuve\"));\n    assert(candidate((\"digitalindia\"), (\"talent\")) == (\"digiidi\"));\n    assert(candidate((\"exoticmiles\"), (\"toxic\")) == (\"emles\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_18_remove_dirty_chars","gpt_solution":"```cpp\n#include <string>\n#include <unordered_set>\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to remove characters from the first string which are present in the second string.\nstd::string remove_dirty_chars(std::string string, std::string second_string) {\n    \/\/ Create an unordered_set to store characters of the second string\n    std::unordered_set<char> dirtyChars(second_string.begin(), second_string.end());\n\n    \/\/ Resultant string after removing dirty characters\n    std::string result;\n\n    \/\/ Iterate over the first string and add characters to the result \n    \/\/ only if they are not present in the dirty set\n    for (char c : string) {\n        if (dirtyChars.find(c) == dirtyChars.end()) {\n            result += c;\n        }\n    }\n\n    return result;\n}\n```"}
{"name":"mbpp_19_test_duplicate","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find whether a given vector of integers contains any duplicate element.\nbool test_duplicate(std::vector<long> arraynums) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_19_test_duplicate.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = test_duplicate;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)4}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)2, (long)3, (long)3, (long)4, (long)4, (long)5}))) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_19_test_duplicate","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to find whether a given vector of integers contains any duplicate element.\nbool test_duplicate(std::vector<long> arraynums) {\n    std::unordered_set<long> num_set;\n    for(auto num : arraynums) {\n        if(num_set.find(num) != num_set.end()) {\n            return true; \/\/ Duplicate found\n        }\n        num_set.insert(num);\n    }\n    return false; \/\/ No duplicates found\n}\n```"}
{"name":"mbpp_20_is_woodall","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check if the given number is woodball or not.\nbool is_woodall(long x) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_20_is_woodall.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = is_woodall;\n    assert(candidate((383)) == (true));\n    assert(candidate((254)) == (false));\n    assert(candidate((200)) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_20_is_woodall","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check if the given number is woodall or not.\nbool is_woodall(long x) {\n    if (x <= 0) return false; \/\/ Woodall numbers are positive\n   \n    long n = 1;\n    while (true) {\n        long woodall_num = n * (1L << n) - 1;\n        if (woodall_num == x) return true; \/\/ x is a Woodall number\n        if (woodall_num > x) return false; \/\/ x is not a Woodall number\n        ++n;\n    }\n}\n```"}
{"name":"mbpp_56_checks","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to check if a given number is one less than twice its reverse.\nbool checks(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_56_checks.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = checks;\n    assert(candidate((70)) == (false));\n    assert(candidate((23)) == (false));\n    assert(candidate((73)) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_56_checks","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Helper function to reverse a number\nlong reverseNumber(long n) {\n    long rev = 0;\n    while (n > 0) {\n        rev = rev * 10 + n % 10;\n        n \/= 10;\n    }\n    return rev;\n}\n\n\/\/ Function to check if a given number is one less than twice its reverse\nbool checks(long n) {\n    long reversed = reverseNumber(n);\n    return n == 2 * reversed - 1;\n}\n```\n\nThis function `checks` takes a number `n`, calculates its reverse, and then checks if `n` is one less than twice its reversed number. The auxiliary function `reverseNumber` assists in reversing the number."}
{"name":"mbpp_57_find_Max_Num","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the largest number that can be formed with the given vector of digits.\nlong find_Max_Num(std::vector<long> arr) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_57_find_Max_Num.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_Max_Num;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (321));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)1}))) == (6541));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)9}))) == (9321));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_57_find_Max_Num","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\nlong find_Max_Num(std::vector<long> arr) {\n    \/\/ Concatenate all elements after converting them to string to form the largest number\n    \/\/ Custom comparator to order numbers in a way that forms the largest concatenated result\n    auto compare = [](long a, long b) {\n        std::string sa = std::to_string(a);\n        std::string sb = std::to_string(b);\n        return sa + sb > sb + sa;\n    };\n\n    \/\/ Sort array with custom comparator\n    std::sort(arr.begin(), arr.end(), compare);\n\n    \/\/ Concatenate sorted array elements\n    std::string result;\n    for (long num : arr) {\n        result += std::to_string(num);\n    }\n\n    \/\/ Edge case: if the result is just multiple zeros, return one zero\n    if(result[0] == '0') return 0;\n\n    return std::stol(result);\n}\n```"}
{"name":"mbpp_58_opposite_Signs","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to check whether the given two integers have opposite sign or not.\nbool opposite_Signs(long x, long y) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_58_opposite_Signs.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = opposite_Signs;\n    assert(candidate((1), (-2)) == (true));\n    assert(candidate((3), (2)) == (false));\n    assert(candidate((-10), (-10)) == (false));\n    assert(candidate((-2), (2)) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_58_opposite_Signs","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cpp function to check whether the given two integers have opposite sign or not.\nbool opposite_Signs(long x, long y) {\n    \/\/ If x and y have opposite signs, their product will be negative\n    return ((x ^ y) < 0);\n}\n```\n\nIn this code, we utilize the XOR (^) operation to determine if the two integers have opposite signs. If the result of `x ^ y` is less than zero, it means x and y have opposite signs. This is because the sign bit (most significant bit) will be different for numbers with opposite signs, leading to a negative result in their XOR operation."}
{"name":"mbpp_59_is_octagonal","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the nth octagonal number.\nlong is_octagonal(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_59_is_octagonal.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = is_octagonal;\n    assert(candidate((5)) == (65));\n    assert(candidate((10)) == (280));\n    assert(candidate((15)) == (645));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_59_is_octagonal","gpt_solution":"```cpp\n\/\/ Function to find the nth octagonal number\nlong is_octagonal(long n) {\n    \/\/ The formula for the nth octagonal number is: n * (3 * n - 2)\n    return n * (3 * n - 2);\n}\n```"}
{"name":"mbpp_61_count_Substrings","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to count the number of substrings with the sum of digits equal to their length.\nlong count_Substrings(std::string s) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_61_count_Substrings.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = count_Substrings;\n    assert(candidate((\"112112\")) == (6));\n    assert(candidate((\"111\")) == (6));\n    assert(candidate((\"1101112\")) == (12));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_61_count_Substrings","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a cpp function to count the number of substrings with the sum of digits equal to their length.\nlong count_Substrings(std::string s) {\n    long n = s.length(), count = 0;\n\n    \/\/ Iterate over all possible substrings\n    for (long i = 0; i < n; ++i) {\n        int sum_digits = 0;\n\n        for (long j = i; j < n; ++j) {\n            \/\/ Add current digit to sum\n            sum_digits += s[j] - '0';\n\n            \/\/ Check if the sum of digits is equal to the length of substring\n            if (sum_digits == j - i + 1) {\n                ++count;\n            }\n        }\n    }\n\n    return count;\n}\n```\n\nThis code iterates through all possible substrings of the given string `s` and calculates the sum of digits for each substring. It then checks if the sum of the digits is equal to the length of the substring. If it is, the counter is incremented. The final count is returned."}
{"name":"mbpp_62_smallest_num","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find smallest number in a vector.\nlong smallest_num(std::vector<long> xs) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_62_smallest_num.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = smallest_num;\n    assert(candidate((std::vector<long>({(long)10, (long)20, (long)1, (long)45, (long)99}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)45, (long)46, (long)50, (long)60}))) == (45));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_62_smallest_num","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cpp function to find the smallest number in a vector.\nlong smallest_num(std::vector<long> xs) {\n    assert(!xs.empty()); \/\/ Ensure the vector is not empty\n    long smallest = xs[0];\n    for (long num : xs) {\n        if (num < smallest) {\n            smallest = num;\n        }\n    }\n    return smallest;\n}\n```"}
{"name":"mbpp_63_max_difference","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the maximum difference between available pairs in the given tuple vector.\nlong max_difference(std::vector<std::tuple<long, long>> test_list) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_63_max_difference.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = max_difference;\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(3, 5), (std::tuple<long, long>)std::make_tuple(1, 7), (std::tuple<long, long>)std::make_tuple(10, 3), (std::tuple<long, long>)std::make_tuple(1, 2)}))) == (7));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(4, 6), (std::tuple<long, long>)std::make_tuple(2, 17), (std::tuple<long, long>)std::make_tuple(9, 13), (std::tuple<long, long>)std::make_tuple(11, 12)}))) == (15));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(12, 35), (std::tuple<long, long>)std::make_tuple(21, 27), (std::tuple<long, long>)std::make_tuple(13, 23), (std::tuple<long, long>)std::make_tuple(41, 22)}))) == (23));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_63_max_difference","gpt_solution":"```cpp\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\n\/\/ Write a function to find the maximum difference between available pairs in the given tuple vector.\nlong max_difference(std::vector<std::tuple<long, long>> test_list) {\n    long max_diff = 0;\n    \n    for (const auto& pair : test_list) {\n        long diff = std::abs(std::get<0>(pair) - std::get<1>(pair));\n        max_diff = std::max(max_diff, diff);\n    }\n    \n    return max_diff;\n}\n```\nThis code defines the `max_difference` function that takes a vector of tuples, where each tuple contains two `long` integers. It calculates and returns the maximum absolute difference between the elements of any tuple in the input vector."}
{"name":"mbpp_64_subject_marks","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to sort a vector of tuples using the second value of each tuple.\nstd::vector<std::tuple<std::string, long>> subject_marks(std::vector<std::tuple<std::string, long>> subjectmarks) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_64_subject_marks.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = subject_marks;\n    assert(candidate((std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"English\", 88), (std::tuple<std::string, long>)std::make_tuple(\"Science\", 90), (std::tuple<std::string, long>)std::make_tuple(\"Maths\", 97), (std::tuple<std::string, long>)std::make_tuple(\"Social sciences\", 82)}))) == (std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Social sciences\", 82), (std::tuple<std::string, long>)std::make_tuple(\"English\", 88), (std::tuple<std::string, long>)std::make_tuple(\"Science\", 90), (std::tuple<std::string, long>)std::make_tuple(\"Maths\", 97)})));\n    assert(candidate((std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Telugu\", 49), (std::tuple<std::string, long>)std::make_tuple(\"Hindhi\", 54), (std::tuple<std::string, long>)std::make_tuple(\"Social\", 33)}))) == (std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Social\", 33), (std::tuple<std::string, long>)std::make_tuple(\"Telugu\", 49), (std::tuple<std::string, long>)std::make_tuple(\"Hindhi\", 54)})));\n    assert(candidate((std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Physics\", 96), (std::tuple<std::string, long>)std::make_tuple(\"Chemistry\", 97), (std::tuple<std::string, long>)std::make_tuple(\"Biology\", 45)}))) == (std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Biology\", 45), (std::tuple<std::string, long>)std::make_tuple(\"Physics\", 96), (std::tuple<std::string, long>)std::make_tuple(\"Chemistry\", 97)})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_64_subject_marks","gpt_solution":"```cpp\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <string>\n\n\/\/ Write a function to sort a vector of tuples using the second value of each tuple.\nstd::vector<std::tuple<std::string, long>> subject_marks(std::vector<std::tuple<std::string, long>> subjectmarks) {\n    std::sort(subjectmarks.begin(), subjectmarks.end(), [](const auto& a, const auto& b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n    return subjectmarks;\n}\n```"}
{"name":"mbpp_65_recursive_list_sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\nunion Union_long_std_vector_long_{\n    long f0;\n    std::vector<long> f1;    Union_long_std_vector_long_(long _f0) : f0(_f0) {}\n    Union_long_std_vector_long_(std::vector<long> _f1) : f1(_f1) {}\n    ~Union_long_std_vector_long_() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(std::vector<long> f) {\n        return f1 == f ;\n    }\n};\n\/\/ Write a function to flatten a vector and sum all of its elements.\nlong recursive_list_sum(std::vector<Union_long_std_vector_long_> data_list) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_65_recursive_list_sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = recursive_list_sum;\n    assert(candidate((std::vector<Union_long_std_vector_long_>({1, 2, std::vector<long>({(long)3, (long)4}), std::vector<long>({(long)5, (long)6})}))) == (21));\n    assert(candidate((std::vector<Union_long_std_vector_long_>({7, 10, std::vector<long>({(long)15, (long)14}), std::vector<long>({(long)19, (long)41})}))) == (106));\n    assert(candidate((std::vector<Union_long_std_vector_long_>({10, 20, std::vector<long>({(long)30, (long)40}), std::vector<long>({(long)50, (long)60})}))) == (210));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_65_recursive_list_sum","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\nunion Union_long_std_vector_long_ {\n    long f0;\n    std::vector<long> f1;\n\n    Union_long_std_vector_long_(long _f0) : f0(_f0) {}\n    Union_long_std_vector_long_(std::vector<long> _f1) : f1(_f1) {}\n    ~Union_long_std_vector_long_() {}\n\n    bool operator==(long f) const {\n        return f0 == f ;\n    }\n    \n    bool operator==(const std::vector<long>& f) const {\n        return f1 == f ;\n    }\n    \n    bool is_long() const {\n        \/\/ Assuming that we have another way to check what type is active.\n        \/\/ For simplicity, assuming if std::vector is initialized, then it is vector long type.\n        \/\/ In real code, we might need to maintain a type indicator.\n        return f1.empty();\n    }\n};\n\n\/\/ Function to flatten a vector and sum all of its elements.\nlong recursive_list_sum(const std::vector<Union_long_std_vector_long_>& data_list) {\n    long sum = 0;\n    for (const auto& item : data_list) {\n        if (item.is_long()) {\n            sum += item.f0;\n        } else {\n            for (long elem : item.f1) {\n                sum += elem;\n            }\n        }\n    }\n    return sum;\n}\n```\n\nIn this code:\n- The `Union_long_std_vector_long_` union contains either a `long` or a `std::vector<long>`. \n- The `recursive_list_sum` function takes a vector of `Union_long_std_vector_long_` and iterates through each item to determine its type.\n- If the item is a `long`, it adds the value to the sum.\n- If the item is a `std::vector<long>`, it iterates through the vector and adds each element to the sum."}
{"name":"mbpp_66_pos_count","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to count the number of positive numbers in a vector.\nlong pos_count(std::vector<long> list) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_66_pos_count.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = pos_count;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)3, (long)-4}))) == (2));\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)-1}))) == (3));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (4));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_66_pos_count","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to count the number of positive numbers in a vector.\nlong pos_count(std::vector<long> list) {\n    long count = 0;\n    for(long num : list) {\n        if(num > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"name":"mbpp_67_bell_number","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the number of ways to partition a set of Bell numbers.\nlong bell_number(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_67_bell_number.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = bell_number;\n    assert(candidate((2)) == (2));\n    assert(candidate((10)) == (115975));\n    assert(candidate((56)) == (6775685320645824322581483068371419745979053216268760300));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_67_bell_number","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the number of ways to partition a set of Bell numbers.\nlong bell_number(long n) {\n    if (n == 0) return 1;\n    \n    std::vector<std::vector<long>> bell(n + 1, std::vector<long>(n + 1, 0));\n    bell[0][0] = 1;\n\n    for (long i = 1; i <= n; ++i) {\n        bell[i][0] = bell[i-1][i-1];\n        for (long j = 1; j <= i; ++j) {\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1];\n        }\n    }\n\n    return bell[n][0];\n}\n```"}
{"name":"mbpp_68_is_Monotonic","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to check whether the given vector is monotonic or not.\nbool is_Monotonic(std::vector<long> A) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_68_is_Monotonic.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = is_Monotonic;\n    assert(candidate((std::vector<long>({(long)6, (long)5, (long)4, (long)4}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)3}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2}))) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_68_is_Monotonic","gpt_solution":"```cpp\n#include <vector>\n\n\/\/ Function to check whether the given vector is monotonic or not.\nbool is_Monotonic(std::vector<long> A) {\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < A.size(); ++i) {\n        if (A[i] > A[i - 1]) {\n            decreasing = false;\n        }\n        if (A[i] < A[i - 1]) {\n            increasing = false;\n        }\n    }\n\n    \/\/ The vector is monotonic if it is either entirely non-increasing or non-decreasing.\n    return increasing || decreasing;\n}\n```"}
{"name":"mbpp_69_is_sublist","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check whether a vector contains the given subvector or not.\nbool is_sublist(std::vector<long> l, std::vector<long> s) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_69_is_sublist.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = is_sublist;\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)5, (long)7})), (std::vector<long>({(long)3, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)5, (long)7})), (std::vector<long>({(long)4, (long)3}))) == (true));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)5, (long)7})), (std::vector<long>({(long)1, (long)6}))) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_69_is_sublist","gpt_solution":"```cpp\n#include <vector>\n\n\/\/ Function to check whether a vector contains the given subvector or not.\nbool is_sublist(std::vector<long> l, std::vector<long> s) {\n    if(s.empty()) return true; \/\/ An empty subvector is always a sublist\n    if(l.size() < s.size()) return false; \/\/ If the main vector is smaller than the subvector, it can't contain the subvector\n\n    \/\/ Iterate through the main vector\n    for(size_t i = 0; i <= l.size() - s.size(); ++i) {\n        bool match = true;\n        \/\/ Check if the subvector matches the segment of the main vector starting at position i\n        for(size_t j = 0; j < s.size(); ++j) {\n            if(l[i + j] != s[j]) {\n                match = false;\n                break;\n            }\n        }\n        if(match) return true; \/\/ We found a match\n    }\n    return false; \/\/ No match found\n}\n```"}
{"name":"mbpp_70_get_equal","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find whether all the given vectors have equal length or not.\nbool get_equal(std::vector<std::vector<long>> Input) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_70_get_equal.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = get_equal;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11, (long)22, (long)33}), (std::vector<long>)std::vector<long>({(long)44, (long)55, (long)66})}))) == (true));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6, (long)7})}))) == (false));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4})}))) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_70_get_equal","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to find whether all the given vectors have equal length or not.\nbool get_equal(std::vector<std::vector<long>> Input) {\n    if (Input.empty()) {\n        return true;  \/\/ If there are no vectors, they are trivially equal\n    }\n\n    size_t length = Input[0].size();\n    for (const auto& vec : Input) {\n        if (vec.size() != length) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"name":"mbpp_71_comb_sort","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to sort a vector of elements.\nstd::vector<long> comb_sort(std::vector<long> nums) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_71_comb_sort.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = comb_sort;\n    assert(candidate((std::vector<long>({(long)5, (long)15, (long)37, (long)25, (long)79}))) == (std::vector<long>({(long)5, (long)15, (long)25, (long)37, (long)79})));\n    assert(candidate((std::vector<long>({(long)41, (long)32, (long)15, (long)19, (long)22}))) == (std::vector<long>({(long)15, (long)19, (long)22, (long)32, (long)41})));\n    assert(candidate((std::vector<long>({(long)99, (long)15, (long)13, (long)47}))) == (std::vector<long>({(long)13, (long)15, (long)47, (long)99})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_71_comb_sort","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to sort a vector of elements.\nstd::vector<long> comb_sort(std::vector<long> nums) {\n    \/\/ Define the gap shrink factor\n    const double shrink = 1.3;\n    int gap = nums.size();\n    bool sorted = false;\n\n    while (!sorted) {\n        gap = int(gap \/ shrink);\n        if (gap < 1) {\n            gap = 1;\n            sorted = true; \/\/ we assume the array is sorted\n        }\n\n        for (int i = 0; i + gap < nums.size(); ++i) {\n            if (nums[i] > nums[i + gap]) {\n                std::swap(nums[i], nums[i + gap]);\n                sorted = false; \/\/ we found a pair out of order, so array is not sorted\n            }\n        }\n    }\n    \n    return nums;\n}\n```"}
{"name":"mbpp_72_dif_Square","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to check whether the given number can be represented as the difference of two squares or not.\nbool dif_Square(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_72_dif_Square.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = dif_Square;\n    assert(candidate((5)) == (true));\n    assert(candidate((10)) == (false));\n    assert(candidate((15)) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_72_dif_Square","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to check whether the given number can be represented as the difference of two squares or not.\nbool dif_Square(long n) {\n    \/\/ In general, any integer n can be expressed as a difference of two squares\n    \/\/ if and only if n is not of the form 4k + 2 for any integer k.\n\n    \/\/ Check for the form 4k + 2\n    if (n % 4 == 2) {\n        return false;\n    }\n    return true;\n}\n\n\/\/ Example usage and test cases\nint main() {\n    assert(dif_Square(5) == true);    \/\/ 5 = 3^2 - 2^2\n    assert(dif_Square(8) == true);    \/\/ 8 = 5^2 - 3^2\n    assert(dif_Square(3) == true);    \/\/ 3 = 2^2 - 1^2\n    assert(dif_Square(6) == false);   \/\/ 6 is of the form 4k + 2\n    assert(dif_Square(1) == true);    \/\/ 1 = 1^2 - 0^2\n    assert(dif_Square(0) == true);    \/\/ 0 = 1^2 - 1^2 (0 = x^2 - x^2 for any x)\n\n    std::cout << \"All test cases passed!\\n\";\n    return 0;\n}\n```"}
{"name":"mbpp_74_is_samepatterns","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check whether it follows the sequence given in the patterns vector.\nbool is_samepatterns(std::vector<std::string> colors, std::vector<std::string> patterns) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_74_is_samepatterns.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = is_samepatterns;\n    assert(candidate((std::vector<std::string>({(std::string)\"red\", (std::string)\"green\", (std::string)\"green\"})), (std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"b\"}))) == (true));\n    assert(candidate((std::vector<std::string>({(std::string)\"red\", (std::string)\"green\", (std::string)\"greenn\"})), (std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"b\"}))) == (false));\n    assert(candidate((std::vector<std::string>({(std::string)\"red\", (std::string)\"green\", (std::string)\"greenn\"})), (std::vector<std::string>({(std::string)\"a\", (std::string)\"b\"}))) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_74_is_samepatterns","gpt_solution":"```cpp\n#include <cassert>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to check whether it follows the sequence given in the patterns vector.\nbool is_samepatterns(std::vector<std::string> colors, std::vector<std::string> patterns) {\n    if (colors.size() != patterns.size()) {\n        return false;\n    }\n\n    std::unordered_map<std::string, std::string> color_to_pattern;\n    std::unordered_map<std::string, std::string> pattern_to_color;\n\n    for (size_t i = 0; i < colors.size(); ++i) {\n        const std::string& color = colors[i];\n        const std::string& pattern = patterns[i];\n\n        if (color_to_pattern.count(color) > 0 && color_to_pattern[color] != pattern) {\n            return false;\n        }\n        if (pattern_to_color.count(pattern) > 0 && pattern_to_color[pattern] != color) {\n            return false;\n        }\n\n        color_to_pattern[color] = pattern;\n        pattern_to_color[pattern] = color;\n    }\n\n    return true;\n}\n```"}
{"name":"mbpp_75_find_tuples","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find tuples which have all elements divisible by k from the given vector of tuples.\nstd::vector<std::tuple<long, long, long>> find_tuples(std::vector<std::tuple<long, long, long>> test_list, long K) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_75_find_tuples.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_tuples;\n    assert(candidate((std::vector<std::tuple<long, long, long>>({(std::tuple<long, long, long>)std::make_tuple(6, 24, 12), (std::tuple<long, long, long>)std::make_tuple(7, 9, 6), (std::tuple<long, long, long>)std::make_tuple(12, 18, 21)})), (6)) == (std::vector<std::tuple<long, long, long>>({(std::tuple<long, long, long>)std::make_tuple(6, 24, 12)})));\n    assert(candidate((std::vector<std::tuple<long, long, long>>({(std::tuple<long, long, long>)std::make_tuple(5, 25, 30), (std::tuple<long, long, long>)std::make_tuple(4, 2, 3), (std::tuple<long, long, long>)std::make_tuple(7, 8, 9)})), (5)) == (std::vector<std::tuple<long, long, long>>({(std::tuple<long, long, long>)std::make_tuple(5, 25, 30)})));\n    assert(candidate((std::vector<std::tuple<long, long, long>>({(std::tuple<long, long, long>)std::make_tuple(7, 9, 16), (std::tuple<long, long, long>)std::make_tuple(8, 16, 4), (std::tuple<long, long, long>)std::make_tuple(19, 17, 18)})), (4)) == (std::vector<std::tuple<long, long, long>>({(std::tuple<long, long, long>)std::make_tuple(8, 16, 4)})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_75_find_tuples","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\nstd::vector<std::tuple<long, long, long>> find_tuples(std::vector<std::tuple<long, long, long>> test_list, long K) {\n    \/\/ Output vector to store the filtered tuples\n    std::vector<std::tuple<long, long, long>> result;\n\n    \/\/ Iterator through the given list of tuples\n    for (const auto& tup : test_list) {\n        \/\/ Extract elements from the tuple\n        long a, b, c;\n        std::tie(a, b, c) = tup;\n\n        \/\/ Check if all elements are divisible by K\n        if (a % K == 0 && b % K == 0 && c % K == 0) {\n            \/\/ If yes, add the tuple to the result\n            result.push_back(tup);\n        }\n    }\n\n    \/\/ Return the filtered list of tuples\n    return result;\n}\n```"}
{"name":"mbpp_77_is_Diff","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find whether a number is divisible by 11.\nbool is_Diff(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_77_is_Diff.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = is_Diff;\n    assert(candidate((12345)) == (false));\n    assert(candidate((1212112)) == (true));\n    assert(candidate((1212)) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_77_is_Diff","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cpp function to find whether a number is divisible by 11.\nbool is_Diff(long n) {\n    \/\/ Convert the number to a string to easily access individual digits.\n    std::string num_str = std::to_string(n);\n\n    \/\/ Initialize two sums: one for digits in odd positions and one for digits in even positions.\n    int odd_sum = 0, even_sum = 0;\n    \n    for (int i = 0; i < num_str.size(); i++) {\n        if (i % 2 == 0)\n            odd_sum += num_str[i] - '0';\n        else\n            even_sum += num_str[i] - '0';\n    }\n\n    \/\/ Check if the difference of these sums is divisible by 11.\n    return std::abs(odd_sum - even_sum) % 11 == 0;\n}\n```\n\nThis code defines a function `is_Diff` that determines if a given number is divisible by 11. The method uses the rule that for a number to be divisible by 11, the difference between the sum of the digits in odd positions and the sum of the digits in even positions must be divisible by 11."}
{"name":"mbpp_79_word_len","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to check whether the length of the word is odd or not.\nbool word_len(std::string s) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_79_word_len.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = word_len;\n    assert(candidate((\"Hadoop\")) == (false));\n    assert(candidate((\"great\")) == (true));\n    assert(candidate((\"structure\")) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_79_word_len","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cpp function to check whether the length of the word is odd or not.\nbool word_len(std::string s) {\n    return s.length() % 2 != 0;\n}\n```"}
{"name":"mbpp_80_tetrahedral_number","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the nth tetrahedral number.\nlong tetrahedral_number(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_80_tetrahedral_number.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = tetrahedral_number;\n    assert(candidate((5)) == (35));\n    assert(candidate((6)) == (56));\n    assert(candidate((7)) == (84));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_80_tetrahedral_number","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the nth tetrahedral number.\nlong tetrahedral_number(long n) {\n    return (n * (n + 1) * (n + 2)) \/ 6;\n}\n```"}
{"name":"mbpp_83_get_Char","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the character made by adding the ASCII value of all the characters of the given string modulo 26.\nstd::string get_Char(std::string strr) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_83_get_Char.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = get_Char;\n    assert(candidate((\"abc\")) == (\"f\"));\n    assert(candidate((\"gfg\")) == (\"t\"));\n    assert(candidate((\"ab\")) == (\"c\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_83_get_Char","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a cpp function to find the character made by adding the ASCII value of all the characters of the given string modulo 26.\nstd::string get_Char(std::string strr) {\n    int sum = 0;\n    for(char c : strr) {\n        sum += c; \/\/ Add ASCII values of all characters\n    }\n    char result = 'a' + (sum % 26); \/\/ Find the resultant character modulo 26\n    return std::string(1, result); \/\/ Convert char to string\n}\n```"}
{"name":"mbpp_84_sequence","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the nth number in the newman conway sequence.\nlong sequence(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_84_sequence.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sequence;\n    assert(candidate((10)) == (6));\n    assert(candidate((2)) == (1));\n    assert(candidate((3)) == (2));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_84_sequence","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to find the nth number in the Newman-Conway sequence\nlong sequence(long n) {\n    \/\/ Base cases for the Newman-Conway sequence\n    if (n == 1 || n == 2)\n        return 1;\n\n    \/\/ Initialize an array to store the values of the sequence\n    std::vector<long> seq(n + 1, 0);\n    seq[1] = seq[2] = 1;\n\n    \/\/ Fill the array using the recursive relation of the sequence\n    for (long i = 3; i <= n; ++i) {\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]];\n    }\n\n    \/\/ Return the nth number in the sequence\n    return seq[n];\n}\n\n\/\/ Example to run assertion tests for validation\nvoid test_sequence() {\n    assert(sequence(1) == 1);\n    assert(sequence(2) == 1);\n    assert(sequence(3) == 2);\n    assert(sequence(4) == 2);\n    assert(sequence(5) == 3);\n    assert(sequence(6) == 4);\n\n    std::cout << \"All tests passed!\" << std::endl;\n}\n```\n\nYou can call the `test_sequence` function in your main function to validate the implementation. The above code defines the `sequence` function to find the nth number in the Newman-Conway sequence using dynamic programming for optimal performance."}
{"name":"mbpp_86_centered_hexagonal_number","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find nth centered hexagonal number.\nlong centered_hexagonal_number(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_86_centered_hexagonal_number.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = centered_hexagonal_number;\n    assert(candidate((10)) == (271));\n    assert(candidate((2)) == (7));\n    assert(candidate((9)) == (217));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_86_centered_hexagonal_number","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find nth centered hexagonal number.\nlong centered_hexagonal_number(long n) {\n    assert(n >= 1); \/\/ Adding an assert to ensure n is a positive integer\n    return 3 * n * (n - 1) + 1;\n}\n```"}
{"name":"mbpp_87_merge_dictionaries_three","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to merge three dictionaries into a single map.\nstd::map<std::string,std::string> merge_dictionaries_three(std::map<std::string,std::string> dict1, std::map<std::string,std::string> dict2, std::map<std::string,std::string> dict3) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_87_merge_dictionaries_three.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = merge_dictionaries_three;\n    assert(candidate((std::map<std::string,std::string>({{\"R\", \"Red\"}, {\"B\", \"Black\"}, {\"P\", \"Pink\"}})), (std::map<std::string,std::string>({{\"G\", \"Green\"}, {\"W\", \"White\"}})), (std::map<std::string,std::string>({{\"O\", \"Orange\"}, {\"W\", \"White\"}, {\"B\", \"Black\"}}))) == (std::map<std::string,std::string>({{\"B\", \"Black\"}, {\"R\", \"Red\"}, {\"P\", \"Pink\"}, {\"G\", \"Green\"}, {\"W\", \"White\"}, {\"O\", \"Orange\"}})));\n    assert(candidate((std::map<std::string,std::string>({{\"R\", \"Red\"}, {\"B\", \"Black\"}, {\"P\", \"Pink\"}})), (std::map<std::string,std::string>({{\"G\", \"Green\"}, {\"W\", \"White\"}})), (std::map<std::string,std::string>({{\"L\", \"lavender\"}, {\"B\", \"Blue\"}}))) == (std::map<std::string,std::string>({{\"W\", \"White\"}, {\"P\", \"Pink\"}, {\"B\", \"Black\"}, {\"R\", \"Red\"}, {\"G\", \"Green\"}, {\"L\", \"lavender\"}})));\n    assert(candidate((std::map<std::string,std::string>({{\"R\", \"Red\"}, {\"B\", \"Black\"}, {\"P\", \"Pink\"}})), (std::map<std::string,std::string>({{\"L\", \"lavender\"}, {\"B\", \"Blue\"}})), (std::map<std::string,std::string>({{\"G\", \"Green\"}, {\"W\", \"White\"}}))) == (std::map<std::string,std::string>({{\"B\", \"Black\"}, {\"P\", \"Pink\"}, {\"R\", \"Red\"}, {\"G\", \"Green\"}, {\"L\", \"lavender\"}, {\"W\", \"White\"}})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_87_merge_dictionaries_three","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n\nstd::map<std::string, std::string> merge_dictionaries_three(std::map<std::string,std::string> dict1, std::map<std::string,std::string> dict2, std::map<std::string,std::string> dict3) {\n    std::map<std::string, std::string> merged_dict;\n\n    \/\/ Insert all elements from the first dictionary\n    merged_dict.insert(dict1.begin(), dict1.end());\n\n    \/\/ Insert all elements from the second dictionary\n    merged_dict.insert(dict2.begin(), dict2.end());\n\n    \/\/ Insert all elements from the third dictionary\n    merged_dict.insert(dict3.begin(), dict3.end());\n\n    return merged_dict;\n}\n```"}
{"name":"mbpp_88_freq_count","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to get the frequency of all the elements in a vector, returned as a map.\nstd::map<long,long> freq_count(std::vector<long> list1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_88_freq_count.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = freq_count;\n    assert(candidate((std::vector<long>({(long)10, (long)10, (long)10, (long)10, (long)20, (long)20, (long)20, (long)20, (long)40, (long)40, (long)50, (long)50, (long)30}))) == (std::map<long,long>({{10, 4}, {20, 4}, {40, 2}, {50, 2}, {30, 1}})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)4, (long)1, (long)3, (long)1, (long)4}))) == (std::map<long,long>({{1, 3}, {2, 2}, {3, 3}, {4, 3}})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)4, (long)9, (long)10, (long)4, (long)5, (long)6, (long)7, (long)9, (long)5}))) == (std::map<long,long>({{10, 1}, {5, 3}, {6, 2}, {7, 2}, {4, 2}, {9, 2}})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_88_freq_count","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to get the frequency of all the elements in a vector, returned as a map.\nstd::map<long, long> freq_count(std::vector<long> list1) {\n    std::map<long, long> frequency_map;\n    for (long num : list1) {\n        frequency_map[num]++;\n    }\n    return frequency_map;\n}\n```"}
{"name":"mbpp_89_closest_num","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the closest smaller number than n.\nlong closest_num(long N) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_89_closest_num.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = closest_num;\n    assert(candidate((11)) == (10));\n    assert(candidate((7)) == (6));\n    assert(candidate((12)) == (11));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_89_closest_num","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the closest smaller number than n.\n\nlong closest_num(long N) {\n    \/\/ Corner case: when N is 0 or negative, the closest smaller number is not defined.\n    \/\/ Returning -1 to indicate an invalid input.\n    if(N <= 0) return -1;\n    \n    \/\/ Otherwise, the closest smaller number than N is simply N-1\n    return N - 1;\n}\n```"}
{"name":"mbpp_90_len_log","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the length of the longest word.\nlong len_log(std::vector<std::string> list1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_90_len_log.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = len_log;\n    assert(candidate((std::vector<std::string>({(std::string)\"python\", (std::string)\"PHP\", (std::string)\"bigdata\"}))) == (7));\n    assert(candidate((std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))) == (3));\n    assert(candidate((std::vector<std::string>({(std::string)\"small\", (std::string)\"big\", (std::string)\"tall\"}))) == (5));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_90_len_log","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cpp function to find the length of the longest word.\nlong len_log(std::vector<std::string> list1) {\n    long max_len = 0;\n    for(const auto& word : list1) {\n        if(word.length() > max_len) {\n            max_len = word.length();\n        }\n    }\n    return max_len;\n}\n```\n\nThis function iterates through each word in the provided vector of strings and keeps track of the length of the longest word encountered. Finally, it returns the length of that longest word."}
{"name":"mbpp_91_find_substring","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check if a string is present as a substring in a given vector of string values.\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_91_find_substring.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_substring;\n    assert(candidate((std::vector<std::string>({(std::string)\"red\", (std::string)\"black\", (std::string)\"white\", (std::string)\"green\", (std::string)\"orange\"})), (\"ack\")) == (true));\n    assert(candidate((std::vector<std::string>({(std::string)\"red\", (std::string)\"black\", (std::string)\"white\", (std::string)\"green\", (std::string)\"orange\"})), (\"abc\")) == (false));\n    assert(candidate((std::vector<std::string>({(std::string)\"red\", (std::string)\"black\", (std::string)\"white\", (std::string)\"green\", (std::string)\"orange\"})), (\"ange\")) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_91_find_substring","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to check if a string is present as a substring in a given vector of string values.\nbool find_substring(const std::vector<std::string>& str1, const std::string& sub_str) {\n    for(const auto& s : str1) {\n        if(s.find(sub_str) != std::string::npos) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"name":"mbpp_92_is_undulating","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check whether the given number is undulating or not.\nbool is_undulating(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_92_is_undulating.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = is_undulating;\n    assert(candidate((1212121)) == (true));\n    assert(candidate((1991)) == (false));\n    assert(candidate((121)) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_92_is_undulating","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Write a function to check whether the given number is undulating or not.\nbool is_undulating(long n) {\n    \/\/ Convert the number to a string for easy digit comparison\n    string str = to_string(n);\n    int len = str.length();\n\n    if (len < 2) {\n        \/\/ A number with only one digit cannot be undulating\n        return false;\n    }\n\n    \/\/ Check the alternating pattern\n    char first = str[0];\n    char second = str[1];\n    \n    \/\/ First and second digits should be different\n    if (first == second) {\n        return false;\n    }\n\n    for (int i = 2; i < len; i++) {\n        if ((i % 2 == 0 && str[i] != first) || (i % 2 == 1 && str[i] != second)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"name":"mbpp_93_power","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to calculate the value of 'a' to the power 'b'.\nlong power(long a, long b) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_93_power.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = power;\n    assert(candidate((3), (4)) == (81));\n    assert(candidate((2), (3)) == (8));\n    assert(candidate((5), (5)) == (3125));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_93_power","gpt_solution":"```cpp\n#include <cassert>\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Write a function to calculate the value of 'a' to the power 'b'.\nlong power(long a, long b) {\n    assert(b >= 0); \/\/ Ensure that the power is non-negative\n    long result = 1;\n    while (b) {\n        if (b % 2 == 1) {\n            result *= a;\n        }\n        a *= a;\n        b \/= 2;\n    }\n    return result;\n}\n```"}
{"name":"mbpp_94_index_minimum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Given a vector of tuples, write a function that returns the first value of the tuple with the smallest second value.\nstd::string index_minimum(std::vector<std::tuple<std::string, long>> test_list) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_94_index_minimum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = index_minimum;\n    assert(candidate((std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Rash\", 143), (std::tuple<std::string, long>)std::make_tuple(\"Manjeet\", 200), (std::tuple<std::string, long>)std::make_tuple(\"Varsha\", 100)}))) == (\"Varsha\"));\n    assert(candidate((std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Yash\", 185), (std::tuple<std::string, long>)std::make_tuple(\"Dawood\", 125), (std::tuple<std::string, long>)std::make_tuple(\"Sanya\", 175)}))) == (\"Dawood\"));\n    assert(candidate((std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Sai\", 345), (std::tuple<std::string, long>)std::make_tuple(\"Salman\", 145), (std::tuple<std::string, long>)std::make_tuple(\"Ayesha\", 96)}))) == (\"Ayesha\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_94_index_minimum","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Given a vector of tuples, write a function that returns the first value of the tuple with the smallest second value.\nstd::string index_minimum(std::vector<std::tuple<std::string, long>> test_list) {\n    assert(!test_list.empty());  \/\/ Ensure the vector is not empty\n    \n    auto min_elem = min_element(test_list.begin(), test_list.end(), \n                                [](const tuple<string, long>& a, const tuple<string, long>& b) {\n                                    return get<1>(a) < get<1>(b);\n                                });\n                                \n    return get<0>(*min_elem);\n}\n```\n\nHere, the function `index_minimum` takes a vector of tuples as an argument. Each tuple contains a `string` and a `long`. The function returns the first value (string) of the tuple which has the smallest second value (long).\n\nThe `min_element` function is used to find the tuple with the smallest second value, and the custom comparator `[](const tuple<string, long>& a, const tuple<string, long>& b) { return get<1>(a) < get<1>(b); }` ensures that the comparison is done based on the long values. The result is accessed using `get<0>(*min_elem)` to get the first value of this tuple. \n\nThe `assert(!test_list.empty())` line makes sure the input vector is not empty, as calling `min_element` on an empty vector would be undefined."}
{"name":"mbpp_95_Find_Min_Length","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the length of the smallest vector in a vector of vectors.\nlong Find_Min_Length(std::vector<std::vector<long>> lst) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_95_Find_Min_Length.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = Find_Min_Length;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2})}))) == (1));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4})}))) == (2));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)3, (long)3, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)4, (long)4, (long)4})}))) == (3));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_95_Find_Min_Length","gpt_solution":"```cpp\n#include <vector>\n#include <algorithm>\n\nlong Find_Min_Length(std::vector<std::vector<long>> lst) {\n    \/\/ Use a lambda function to compare the lengths of the vectors\n    auto min_length = std::min_element(lst.begin(), lst.end(), [](const std::vector<long>& a, const std::vector<long>& b) {\n        return a.size() < b.size();\n    });\n\n    \/\/ Return the length of the smallest vector\n    return min_length->size();\n}\n```"}
{"name":"mbpp_96_divisor","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the number of divisors of a given integer.\nlong divisor(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_96_divisor.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = divisor;\n    assert(candidate((15)) == (4));\n    assert(candidate((12)) == (6));\n    assert(candidate((9)) == (3));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_96_divisor","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to find the number of divisors of a given integer.\nlong divisor(long n) {\n    if (n < 1) return 0; \/\/ No positive divisors for non-positive integers\n\n    long count = 0;\n    \/\/ Loop over all the numbers from 1 to sqrt(n) to find the divisors\n    for (long i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            \/\/ If i divides n, then both i and (n\/i) are divisors\n            if (i * i == n) {\n                count += 1; \/\/ When i and n\/i are the same (perfect square cases)\n            } else {\n                count += 2; \/\/ Otherwise, count both i and n\/i\n            }\n        }\n    }\n    return count;\n}\n\n\/\/ Example usage\n\/\/ int main() {\n\/\/     assert(divisor(10) == 4); \/\/ 1, 2, 5, 10\n\/\/     assert(divisor(15) == 4); \/\/ 1, 3, 5, 15\n\/\/     assert(divisor(1) == 1);  \/\/ 1\n\/\/     assert(divisor(16) == 5); \/\/ 1, 2, 4, 8, 16\n\/\/     assert(divisor(25) == 3); \/\/ 1, 5, 25\n\/\/     return 0;\n\/\/ }\n```"}
{"name":"mbpp_97_frequency_lists","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find frequency of each element in a flattened vector of vectors, returned in a map.\nstd::map<long,long> frequency_lists(std::vector<std::vector<long>> list1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_97_frequency_lists.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = frequency_lists;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6, (long)2}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9, (long)5})}))) == (std::map<long,long>({{1, 1}, {2, 3}, {3, 1}, {4, 1}, {5, 2}, {6, 1}, {7, 1}, {8, 1}, {9, 1}})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)11, (long)12})}))) == (std::map<long,long>({{1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}, {6, 1}, {7, 1}, {8, 1}, {9, 1}, {10, 1}, {11, 1}, {12, 1}})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)20, (long)30, (long)40, (long)17}), (std::vector<long>)std::vector<long>({(long)18, (long)16, (long)14, (long)13}), (std::vector<long>)std::vector<long>({(long)10, (long)20, (long)30, (long)40})}))) == (std::map<long,long>({{20, 2}, {30, 2}, {40, 2}, {17, 1}, {18, 1}, {16, 1}, {14, 1}, {13, 1}, {10, 1}})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_97_frequency_lists","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find frequency of each element in a flattened vector of vectors, returned in a map.\nstd::map<long, long> frequency_lists(std::vector<std::vector<long>> list1) {\n    std::map<long, long> frequency_map;  \/\/ Map to store frequency counts\n\n    for (const auto& sublist : list1) {\n        for (const auto& element : sublist) {\n            frequency_map[element]++;\n        }\n    }\n\n    return frequency_map;\n}\n```"}
{"name":"mbpp_99_decimal_to_binary","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\nstd::string decimal_to_binary(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_99_decimal_to_binary.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((8)) == (\"1000\"));\n    assert(candidate((18)) == (\"10010\"));\n    assert(candidate((7)) == (\"111\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_99_decimal_to_binary","gpt_solution":"```cpp\n#include <cassert>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\nstd::string decimal_to_binary(long n) {\n    if (n == 0) return \"0\";\n    std::string binary;\n    while (n > 0) {\n        binary += (n % 2 == 0 ? '0' : '1');\n        n \/= 2;\n    }\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"name":"mbpp_100_next_smallest_palindrome","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\nlong next_smallest_palindrome(long num) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_100_next_smallest_palindrome.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = next_smallest_palindrome;\n    assert(candidate((99)) == (101));\n    assert(candidate((1221)) == (1331));\n    assert(candidate((120)) == (121));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_100_next_smallest_palindrome","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to check if a given number is a palindrome.\nbool is_palindrome(long num) {\n    std::string str = std::to_string(num);\n    std::string rev = str;\n    std::reverse(rev.begin(), rev.end());\n    return str == rev;\n}\n\n\/\/ Function to find the next smallest palindrome of a specified integer, returned as an integer.\nlong next_smallest_palindrome(long num) {\n    num++; \/\/ Start checking from the next number\n    while (!is_palindrome(num)) {\n        num++;\n    }\n    return num;\n}\n\n\/\/ Test cases (example usage of assert.h to test correctness)\nvoid test() {\n    assert(next_smallest_palindrome(8) == 9);\n    assert(next_smallest_palindrome(10) == 11);\n    assert(next_smallest_palindrome(123) == 131);\n    assert(next_smallest_palindrome(999) == 1001);\n    assert(next_smallest_palindrome(1221) == 1331);\n}\n\n\/\/ Wrapping test cases in main to run them and verify correctness\nint main() {\n    test();\n    std::cout << \"All test cases passed!\" << std::endl;\n    return 0;\n}\n```"}
{"name":"mbpp_101_kth_element","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the kth element in the given vector using 1-based indexing.\nlong kth_element(std::vector<long> arr, long k) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_101_kth_element.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = kth_element;\n    assert(candidate((std::vector<long>({(long)12, (long)3, (long)5, (long)7, (long)19})), (2)) == (3));\n    assert(candidate((std::vector<long>({(long)17, (long)24, (long)8, (long)23})), (3)) == (8));\n    assert(candidate((std::vector<long>({(long)16, (long)21, (long)25, (long)36, (long)4})), (4)) == (36));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_101_kth_element","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the kth element in the given vector using 1-based indexing.\nlong kth_element(std::vector<long> arr, long k) {\n    \/\/ Check if k is within bounds\n    assert(k > 0 && k <= arr.size());\n\n    \/\/ Use nth_element to partition the vector such that the k-1-th element is in its final sorted position\n    std::nth_element(arr.begin(), arr.begin() + k - 1, arr.end());\n\n    \/\/ Return the k-1-th element which is the kth element in 1-based indexing\n    return arr[k - 1];\n}\n```"}
{"name":"mbpp_102_snake_to_camel","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to convert a snake case string to camel case string.\nstd::string snake_to_camel(std::string word) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_102_snake_to_camel.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = snake_to_camel;\n    assert(candidate((\"python_program\")) == (\"PythonProgram\"));\n    assert(candidate((\"python_language\")) == (\"PythonLanguage\"));\n    assert(candidate((\"programming_language\")) == (\"ProgrammingLanguage\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_102_snake_to_camel","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to convert a snake case string to camel case string.\nstd::string snake_to_camel(std::string word) {\n    std::string result;\n    bool next_upper = false;\n\n    for (char c : word) {\n        if (c == '_') {\n            next_upper = true;\n        } else {\n            if (next_upper) {\n                result += toupper(c);\n                next_upper = false;\n            } else {\n                result += c;\n            }\n        }\n    }\n\n    return result;\n}\n\nvoid test_snake_to_camel() {\n    assert(snake_to_camel(\"hello_world\") == \"helloWorld\");\n    assert(snake_to_camel(\"this_is_a_test\") == \"thisIsATest\");\n    assert(snake_to_camel(\"snake_case\") == \"snakeCase\");\n    assert(snake_to_camel(\"convert_this_function\") == \"convertThisFunction\");\n    assert(snake_to_camel(\"alreadyCamelCase\") == \"alreadyCamelCase\");\n    assert(snake_to_camel(\"_leading_underscore\") == \"LeadingUnderscore\");\n    assert(snake_to_camel(\"trailing_underscore_\") == \"trailingUnderscore\");\n    assert(snake_to_camel(\"_\") == \"\");\n    assert(snake_to_camel(\"\") == \"\");\n}\n\nint main() {\n    test_snake_to_camel();\n    std::cout << \"All tests passed!\";\n    return 0;\n}\n```\n\nThe function `snake_to_camel` converts a snake case string to a camel case string, and the `test_snake_to_camel` function ensures it works correctly."}
{"name":"mbpp_103_eulerian_num","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the Eulerian number a(n, m).\nlong eulerian_num(long n, long m) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_103_eulerian_num.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = eulerian_num;\n    assert(candidate((3), (1)) == (4));\n    assert(candidate((4), (1)) == (11));\n    assert(candidate((5), (3)) == (26));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_103_eulerian_num","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the Eulerian number a(n, m).\nlong eulerian_num(long n, long m) {\n    \/\/ Create a 2D array to store results of subproblems\n    std::vector<std::vector<long>> dp(n + 1, std::vector<long>(m + 1, 0));\n\n    \/\/ Base case: a(0, 0) = 1\n    dp[0][0] = 1;\n\n    \/\/ Fill the table according to the recurrence relation\n    for (long i = 1; i <= n; ++i) {\n        for (long j = 0; j <= m; ++j) {\n            dp[i][j] = ((i - j) * dp[i-1][j-1]) + ((j + 1) * dp[i-1][j]);\n        }\n    }\n\n    \/\/ Return the Eulerian number a(n, m)\n    return dp[n][m];\n}\n```"}
{"name":"mbpp_104_sort_sublists","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to sort each subvector of strings in a given vector of vectors.\nstd::vector<std::vector<std::string>> sort_sublists(std::vector<std::vector<std::string>> input_list) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_104_sort_sublists.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sort_sublists;\n    assert(candidate((std::vector<std::vector<std::string>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"green\", (std::string)\"orange\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"black\", (std::string)\"white\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"white\", (std::string)\"black\", (std::string)\"orange\"})}))) == (std::vector<std::vector<std::string>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"green\", (std::string)\"orange\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"black\", (std::string)\"white\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"black\", (std::string)\"orange\", (std::string)\"white\"})})));\n    assert(candidate((std::vector<std::vector<std::string>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\" red \", (std::string)\"green\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"blue \", (std::string)\" black\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\" orange\", (std::string)\"brown\"})}))) == (std::vector<std::vector<std::string>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\" red \", (std::string)\"green\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\" black\", (std::string)\"blue \"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\" orange\", (std::string)\"brown\"})})));\n    assert(candidate((std::vector<std::vector<std::string>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"zilver\", (std::string)\"gold\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"magnesium\", (std::string)\"aluminium\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"steel\", (std::string)\"bronze\"})}))) == (std::vector<std::vector<std::string>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"gold\", (std::string)\"zilver\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"aluminium\", (std::string)\"magnesium\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"bronze\", (std::string)\"steel\"})})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_104_sort_sublists","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to sort each subvector of strings in a given vector of vectors.\nstd::vector<std::vector<std::string>> sort_sublists(std::vector<std::vector<std::string>> input_list) {\n    for (auto& sublist : input_list) {\n        std::sort(sublist.begin(), sublist.end());\n    }\n    return input_list;\n}\n```"}
{"name":"mbpp_105_count","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to count true booleans in the given vector.\nlong count(std::vector<bool> lst) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_105_count.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = count;\n    assert(candidate((std::vector<bool>({(bool)true, (bool)false, (bool)true}))) == (2));\n    assert(candidate((std::vector<bool>({(bool)false, (bool)false}))) == (0));\n    assert(candidate((std::vector<bool>({(bool)true, (bool)true, (bool)true}))) == (3));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_105_count","gpt_solution":"```cpp\n#include <vector>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to count true booleans in the given vector.\nlong count(std::vector<bool> lst) {\n    long true_count = 0;\n    for(bool value : lst) {\n        if(value) {\n            true_count++;\n        }\n    }\n    return true_count;\n}\n```"}
{"name":"mbpp_106_add_lists","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to append the given vector to the given tuples.\nstd::tuple<long, long, long, long, long> add_lists(std::vector<long> test_list, std::tuple<long, long> test_tup) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_106_add_lists.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = add_lists;\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7})), (std::make_tuple(9, 10))) == (std::make_tuple(9, 10, 5, 6, 7)));\n    assert(candidate((std::vector<long>({(long)6, (long)7, (long)8})), (std::make_tuple(10, 11))) == (std::make_tuple(10, 11, 6, 7, 8)));\n    assert(candidate((std::vector<long>({(long)7, (long)8, (long)9})), (std::make_tuple(11, 12))) == (std::make_tuple(11, 12, 7, 8, 9)));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_106_add_lists","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to append the given vector to the given tuples.\nstd::tuple<long, long, long, long, long> add_lists(std::vector<long> test_list, std::tuple<long, long> test_tup) {\n    assert(test_list.size() == 3); \/\/ Ensure the vector has exactly 3 elements\n    \n    long first, second;\n    std::tie(first, second) = test_tup;\n\n    std::tuple<long, long, long, long, long> result = std::make_tuple(first, second, test_list[0], test_list[1], test_list[2]);\n    \n    return result;\n}\n```"}
{"name":"mbpp_108_merge_sorted_list","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to merge three vectors into a single sorted vector.\nstd::vector<long> merge_sorted_list(std::vector<long> num1, std::vector<long> num2, std::vector<long> num3) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_108_merge_sorted_list.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = merge_sorted_list;\n    assert(candidate((std::vector<long>({(long)25, (long)24, (long)15, (long)4, (long)5, (long)29, (long)110})), (std::vector<long>({(long)19, (long)20, (long)11, (long)56, (long)25, (long)233, (long)154})), (std::vector<long>({(long)24, (long)26, (long)54, (long)48}))) == (std::vector<long>({(long)4, (long)5, (long)11, (long)15, (long)19, (long)20, (long)24, (long)24, (long)25, (long)25, (long)26, (long)29, (long)48, (long)54, (long)56, (long)110, (long)154, (long)233})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)6, (long)8, (long)9})), (std::vector<long>({(long)2, (long)5, (long)7, (long)11})), (std::vector<long>({(long)1, (long)4, (long)7, (long)8, (long)12}))) == (std::vector<long>({(long)1, (long)1, (long)2, (long)3, (long)4, (long)5, (long)5, (long)6, (long)7, (long)7, (long)8, (long)8, (long)9, (long)11, (long)12})));\n    assert(candidate((std::vector<long>({(long)18, (long)14, (long)10, (long)9, (long)8, (long)7, (long)9, (long)3, (long)2, (long)4, (long)1})), (std::vector<long>({(long)25, (long)35, (long)22, (long)85, (long)14, (long)65, (long)75, (long)25, (long)58})), (std::vector<long>({(long)12, (long)74, (long)9, (long)50, (long)61, (long)41}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)7, (long)8, (long)9, (long)9, (long)9, (long)10, (long)12, (long)14, (long)14, (long)18, (long)22, (long)25, (long)25, (long)35, (long)41, (long)50, (long)58, (long)61, (long)65, (long)74, (long)75, (long)85})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_108_merge_sorted_list","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to merge three vectors into a single sorted vector.\nstd::vector<long> merge_sorted_list(std::vector<long> num1, std::vector<long> num2, std::vector<long> num3) {\n    std::vector<long> result;\n    \n    \/\/ Merging all three vectors\n    result.reserve(num1.size() + num2.size() + num3.size());\n    result.insert(result.end(), num1.begin(), num1.end());\n    result.insert(result.end(), num2.begin(), num2.end());\n    result.insert(result.end(), num3.begin(), num3.end());\n\n    \/\/ Sorting the resultant vector\n    std::sort(result.begin(), result.end());\n\n    return result;\n}\n```"}
{"name":"mbpp_109_odd_Equivalent","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the number of numbers with an odd value when rotating a binary string the given number of times.\nlong odd_Equivalent(std::string s, long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_109_odd_Equivalent.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = odd_Equivalent;\n    assert(candidate((\"011001\"), (6)) == (3));\n    assert(candidate((\"11011\"), (5)) == (4));\n    assert(candidate((\"1010\"), (4)) == (2));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_109_odd_Equivalent","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to convert a binary string to its integer equivalent\nlong binaryStringToInteger(string s) {\n    long num = 0;\n    long power = 1;\n    for (int i = s.size() - 1; i >= 0; --i) {\n        if (s[i] == '1') {\n            num += power;\n        }\n        power *= 2;\n    }\n    return num;\n}\n\n\/\/ Function to count the number of odd integers in various rotations of the binary string\nlong odd_Equivalent(std::string s, long n) {\n    int length = s.size();\n    set<long> oddNumbers;\n\n    \/\/ Rotate the binary string `n` times\n    for (long i = 0; i < n; ++i) {\n        \/\/ Rotate to the left by 1 position\n        rotate(s.begin(), s.begin() + 1, s.end());\n        \n        \/\/ Convert the rotated string to integer\n        long value = binaryStringToInteger(s);\n        \n        \/\/ Check if the integer is odd\n        if (value % 2 != 0) {\n            oddNumbers.insert(value);\n        }\n    }\n    \n    \/\/ The number of unique odd numbers encountered\n    return oddNumbers.size();\n}\n```"}
{"name":"mbpp_113_check_integer","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check if a string represents an integer or not.\nbool check_integer(std::string text) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_113_check_integer.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = check_integer;\n    assert(candidate((\"python\")) == (false));\n    assert(candidate((\"1\")) == (true));\n    assert(candidate((\"12345\")) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_113_check_integer","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to check if a string represents an integer or not.\nbool check_integer(std::string text) {\n    \/\/ Empty string is not a valid integer\n    if (text.empty()) return false;\n\n    \/\/ If the string contains only a sign, it's not a valid integer\n    if (text == \"+\" || text == \"-\") return false;\n    \n    int start = 0;\n    \/\/ Check for sign\n    if (text[0] == '+' || text[0] == '-') start = 1;\n\n    \/\/ The string should have digits after the sign (if any)\n    for (int i = start; i < text.size(); ++i) {\n        if (!isdigit(text[i])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid test() {\n    assert(check_integer(\"123\") == true);\n    assert(check_integer(\"+123\") == true);\n    assert(check_integer(\"-123\") == true);\n    assert(check_integer(\"0\") == true);\n    assert(check_integer(\"\") == false);\n    assert(check_integer(\"+\") == false);\n    assert(check_integer(\"-\") == false);\n    assert(check_integer(\"12a3\") == false);\n    assert(check_integer(\"abc\") == false);\n    assert(check_integer(\"12 3\") == false);\n}\n\ntest();\n```"}
{"name":"mbpp_116_tuple_to_int","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to convert a given tuple of positive integers into a single integer.\nlong tuple_to_int(std::tuple<long, long, long> nums) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_116_tuple_to_int.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = tuple_to_int;\n    assert(candidate((std::make_tuple(1, 2, 3))) == (123));\n    assert(candidate((std::make_tuple(4, 5, 6))) == (456));\n    assert(candidate((std::make_tuple(5, 6, 7))) == (567));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_116_tuple_to_int","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to convert a given tuple of positive integers into a single integer.\nlong tuple_to_int(std::tuple<long, long, long> nums) {\n    \/\/ Extract the three numbers from the tuple\n    long num1 = std::get<0>(nums);\n    long num2 = std::get<1>(nums);\n    long num3 = std::get<2>(nums);\n\n    \/\/ Combine the numbers into a single integer\n    \/\/ Each number should be separated by leading zeros ensuring fixed length if necessary\n    \/\/ Here, let's assume each number can go up to 999\n    \/\/ The resulting format would be num1num2num3\n\n    long result = num1 * 1000000 + num2 * 1000 + num3;\n    return result;\n}\n```\n\nExplanation:\n- We extract the three long integers from the tuple.\n- We then form a single long integer by concatenating these three integers.\n- We assume each number is a three-digit integer (i.e., can be up to 999).\n- Therefore, we multiply the first number by \\(10^6\\) and the second number by \\(10^3\\) to place them correctly.\n- Finally, we add them all together to form the single integer."}
{"name":"mbpp_117_list_to_float","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to convert all possible convertible elements in a vector of vectors to floats.\nstd::vector<std::tuple<float, float>> list_to_float(std::vector<std::tuple<std::string, std::string>> test_list) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_117_list_to_float.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = list_to_float;\n    assert(candidate((std::vector<std::tuple<std::string, std::string>>({(std::tuple<std::string, std::string>)std::make_tuple(\"3\", \"4\"), (std::tuple<std::string, std::string>)std::make_tuple(\"1\", \"26.45\"), (std::tuple<std::string, std::string>)std::make_tuple(\"7.32\", \"8\"), (std::tuple<std::string, std::string>)std::make_tuple(\"4\", \"8\")}))) == (std::vector<std::tuple<float, float>>({(std::tuple<float, float>)std::make_tuple(3.0f, 4.0f), (std::tuple<float, float>)std::make_tuple(1.0f, 26.45f), (std::tuple<float, float>)std::make_tuple(7.32f, 8.0f), (std::tuple<float, float>)std::make_tuple(4.0f, 8.0f)})));\n    assert(candidate((std::vector<std::tuple<std::string, std::string>>({(std::tuple<std::string, std::string>)std::make_tuple(\"4\", \"4\"), (std::tuple<std::string, std::string>)std::make_tuple(\"2\", \"27\"), (std::tuple<std::string, std::string>)std::make_tuple(\"4.12\", \"9\"), (std::tuple<std::string, std::string>)std::make_tuple(\"7\", \"11\")}))) == (std::vector<std::tuple<float, float>>({(std::tuple<float, float>)std::make_tuple(4.0f, 4.0f), (std::tuple<float, float>)std::make_tuple(2.0f, 27.0f), (std::tuple<float, float>)std::make_tuple(4.12f, 9.0f), (std::tuple<float, float>)std::make_tuple(7.0f, 11.0f)})));\n    assert(candidate((std::vector<std::tuple<std::string, std::string>>({(std::tuple<std::string, std::string>)std::make_tuple(\"6\", \"78\"), (std::tuple<std::string, std::string>)std::make_tuple(\"5\", \"26.45\"), (std::tuple<std::string, std::string>)std::make_tuple(\"1.33\", \"4\"), (std::tuple<std::string, std::string>)std::make_tuple(\"82\", \"13\")}))) == (std::vector<std::tuple<float, float>>({(std::tuple<float, float>)std::make_tuple(6.0f, 78.0f), (std::tuple<float, float>)std::make_tuple(5.0f, 26.45f), (std::tuple<float, float>)std::make_tuple(1.33f, 4.0f), (std::tuple<float, float>)std::make_tuple(82.0f, 13.0f)})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_117_list_to_float","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\nstd::vector<std::tuple<float, float>> list_to_float(std::vector<std::tuple<std::string, std::string>> test_list) {\n    std::vector<std::tuple<float, float>> result;\n\n    for (const auto& item : test_list) {\n        try {\n            float first = std::stof(std::get<0>(item));\n            float second = std::stof(std::get<1>(item));\n            result.push_back(std::make_tuple(first, second));\n        } catch (const std::invalid_argument& e) {\n            \/\/ Skip the element if it cannot be converted to float\n            continue;\n        }\n    }\n\n    return result;\n}\n```"}
{"name":"mbpp_118_string_to_list","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to convert a string to a vector of strings split on the space character.\nstd::vector<std::string> string_to_list(std::string string) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_118_string_to_list.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = string_to_list;\n    assert(candidate((\"python programming\")) == (std::vector<std::string>({(std::string)\"python\", (std::string)\"programming\"})));\n    assert(candidate((\"lists tuples strings\")) == (std::vector<std::string>({(std::string)\"lists\", (std::string)\"tuples\", (std::string)\"strings\"})));\n    assert(candidate((\"write a program\")) == (std::vector<std::string>({(std::string)\"write\", (std::string)\"a\", (std::string)\"program\"})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_118_string_to_list","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to convert a string to a vector of strings split on the space character.\nstd::vector<std::string> string_to_list(std::string str) {\n    std::vector<std::string> result;\n    std::istringstream stream(str);\n    std::string word;\n    while (stream >> word) {\n        result.push_back(word);\n    }\n    return result;\n}\n```"}
{"name":"mbpp_119_search","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the element that appears only once in a sorted vector.\nlong search(std::vector<long> arr) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_119_search.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)2, (long)3}))) == (3));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)3, (long)3, (long)4, (long)4, (long)5, (long)5, (long)7, (long)7, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4, (long)4}))) == (1));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_119_search","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cpp function to find the element that appears only once in a sorted vector.\nlong search(std::vector<long> arr) {\n    int n = arr.size();\n    \n    \/\/ Edge case: if there's only one element\n    if(n == 1) return arr[0];\n    \n    int left = 0, right = n - 1;\n    \n    while (left < right) {\n        int mid = left + (right - left) \/ 2;\n        \n        \/\/ Ensure mid is even for comparison\n        if (mid % 2 == 1) mid--;\n        \n        \/\/ Compare pairs\n        if (arr[mid] == arr[mid + 1]) {\n            left = mid + 2;\n        } else {\n            right = mid;\n        }\n    }\n    \n    return arr[left];\n}\n\n\/\/ Test cases\nint main() {\n    std::vector<long> test1 = {1, 1, 2, 3, 3, 4, 4, 8, 8}; \/\/ Expected output: 2\n    assert(search(test1) == 2);\n\n    std::vector<long> test2 = {3, 3, 7, 7, 10, 11, 11}; \/\/ Expected output: 10\n    assert(search(test2) == 10);\n\n    std::vector<long> test3 = {0, 1, 1}; \/\/ Expected output: 0\n    assert(search(test3) == 0);\n\n    std::vector<long> test4 = {1, 1, 2}; \/\/ Expected output: 2\n    assert(search(test4) == 2);\n\n    std::vector<long> test5 = {1}; \/\/ Expected output: 1\n    assert(search(test5) == 1);\n\n    std::cout << \"All test cases passed!\" << std::endl;\n    return 0;\n}\n```"}
{"name":"mbpp_120_max_product_tuple","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the maximum absolute product between numbers in pairs of tuples within a given vector.\nlong max_product_tuple(std::vector<std::tuple<long, long>> list1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_120_max_product_tuple.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = max_product_tuple;\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 7), (std::tuple<long, long>)std::make_tuple(2, 6), (std::tuple<long, long>)std::make_tuple(1, 8), (std::tuple<long, long>)std::make_tuple(4, 9)}))) == (36));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(10, 20), (std::tuple<long, long>)std::make_tuple(15, 2), (std::tuple<long, long>)std::make_tuple(5, 10)}))) == (200));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(11, 44), (std::tuple<long, long>)std::make_tuple(10, 15), (std::tuple<long, long>)std::make_tuple(20, 5), (std::tuple<long, long>)std::make_tuple(12, 9)}))) == (484));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_120_max_product_tuple","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n#include <assert.h>\n\nlong max_product_tuple(std::vector<std::tuple<long, long>> list1) {\n    long max_product = std::numeric_limits<long>::min();\n    \n    for (const auto& tup : list1) {\n        long a = std::get<0>(tup);\n        long b = std::get<1>(tup);\n        long product = std::abs(a * b);\n        if (product > max_product) {\n            max_product = product;\n        }\n    }\n    \n    return max_product;\n}\n```\n\nThis code defines a function `max_product_tuple` that takes a vector of tuples as an input. Each tuple contains two `long` type numbers. The function computes the maximum absolute product of numbers in pairs of tuples within the given vector and returns this value."}
{"name":"mbpp_123_amicable_numbers_sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to sum all amicable numbers from 1 to a specified number.\nlong amicable_numbers_sum(long limit) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_123_amicable_numbers_sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = amicable_numbers_sum;\n    assert(candidate((999)) == (504));\n    assert(candidate((9999)) == (31626));\n    assert(candidate((99)) == (0));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_123_amicable_numbers_sum","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n#include <assert.h>\n\n\/\/ Function to calculate the sum of proper divisors of a number\nlong sum_of_divisors(long n) {\n    long sum = 1; \/\/ 1 is a divisor of any number n > 1\n    for (long i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) {\n            if (i == n \/ i) {\n                sum += i;\n            } else {\n                sum += i + n \/ i;\n            }\n        }\n    }\n    return sum;\n}\n\n\/\/ Function to check if two numbers are amicable\nbool are_amicable(long a, long b) {\n    return (a != b) && (sum_of_divisors(a) == b) && (sum_of_divisors(b) == a);\n}\n\n\/\/ Function to sum all amicable numbers from 1 to a specified number\nlong amicable_numbers_sum(long limit) {\n    std::set<long> visited;\n    long sum = 0;\n    for (long i = 2; i < limit; ++i) {\n        if (visited.find(i) == visited.end()) {\n            long divisor_sum = sum_of_divisors(i);\n            if (divisor_sum < limit && are_amicable(i, divisor_sum)) {\n                visited.insert(i);\n                visited.insert(divisor_sum);\n                sum += i + divisor_sum;\n            }\n        }\n    }\n    return sum;\n}\n```"}
{"name":"mbpp_125_find_length","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\nlong find_length(std::string string) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_125_find_length.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_length;\n    assert(candidate((\"11000010001\")) == (6));\n    assert(candidate((\"10111\")) == (1));\n    assert(candidate((\"11011101100101\")) == (2));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_125_find_length","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\nlong find_length(std::string string) {\n    int n = string.length();\n    int current_sum = 0;\n    int max_diff = INT_MIN;\n    \n    for (int i = 0; i < n; i++) {\n        \/\/ Treat '0' as +1 and '1' as -1 \n        current_sum += (string[i] == '0') ? 1 : -1;\n        \n        \/\/ Update max_diff if current_sum is greater\n        if (current_sum > max_diff) {\n            max_diff = current_sum;\n        }\n        \n        \/\/ If current_sum becomes negative, reset it to 0\n        if (current_sum < 0) {\n            current_sum = 0;\n        }\n    }\n    \n    \/\/ If all characters are '1', max_diff would be INT_MIN, so we return 0 as there's no valid substring\n    return max_diff == INT_MIN ? 0 : max_diff;\n}\n```"}
{"name":"mbpp_126_sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the sum of common divisors of two given numbers.\nlong sum(long a, long b) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_126_sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sum;\n    assert(candidate((10), (15)) == (6));\n    assert(candidate((100), (150)) == (93));\n    assert(candidate((4), (6)) == (3));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_126_sum","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to find the greatest common divisor (GCD) of two numbers\nlong gcd(long a, long b) {\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\n\n\/\/ Function to find the sum of common divisors of two given numbers\nlong sum(long a, long b) {\n    long result = 0;\n\n    \/\/ Find the GCD of the two numbers\n    long n = gcd(a, b);\n\n    \/\/ Find the divisors of the GCD\n    for (long i = 1; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            \/\/ If divisors are equal, add it once\n            if (i == (n \/ i)) {\n                result += i;\n            }\n            else {\n                \/\/ Otherwise, add both\n                result += i;\n                result += (n \/ i);\n            }\n        }\n    }\n    return result;\n}\n```\n\nThis function finds the sum of all common divisors of two given numbers `a` and `b`. It first computes the GCD of the two numbers and then sums up all the divisors of the GCD."}
{"name":"mbpp_127_multiply_int","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to multiply two integers.\nlong multiply_int(long x, long y) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_127_multiply_int.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = multiply_int;\n    assert(candidate((10), (20)) == (200));\n    assert(candidate((5), (10)) == (50));\n    assert(candidate((4), (8)) == (32));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_127_multiply_int","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to multiply two integers.\nlong multiply_int(long x, long y) {\n    return x * y;\n}\n```"}
{"name":"mbpp_128_long_words","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find words that are longer than n characters from a given vector of words.\nstd::vector<std::string> long_words(long n, std::string str) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_128_long_words.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = long_words;\n    assert(candidate((3), (\"python is a programming language\")) == (std::vector<std::string>({(std::string)\"python\", (std::string)\"programming\", (std::string)\"language\"})));\n    assert(candidate((2), (\"writing a program\")) == (std::vector<std::string>({(std::string)\"writing\", (std::string)\"program\"})));\n    assert(candidate((5), (\"sorting list\")) == (std::vector<std::string>({(std::string)\"sorting\"})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_128_long_words","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find words that are longer than n characters from a given vector of words.\nstd::vector<std::string> long_words(long n, std::string str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string word;\n\n    while (iss >> word) {\n        if (word.length() > n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n```"}
{"name":"mbpp_129_magic_square_test","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to calculate whether the matrix is a magic square.\nbool magic_square_test(std::vector<std::vector<long>> my_matrix) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_129_magic_square_test.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = magic_square_test;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)7, (long)12, (long)1, (long)14}), (std::vector<long>)std::vector<long>({(long)2, (long)13, (long)8, (long)11}), (std::vector<long>)std::vector<long>({(long)16, (long)3, (long)10, (long)5}), (std::vector<long>)std::vector<long>({(long)9, (long)6, (long)15, (long)4})}))) == (true));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)7, (long)6}), (std::vector<long>)std::vector<long>({(long)9, (long)5, (long)1}), (std::vector<long>)std::vector<long>({(long)4, (long)3, (long)8})}))) == (true));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)7, (long)6}), (std::vector<long>)std::vector<long>({(long)9, (long)5, (long)1}), (std::vector<long>)std::vector<long>({(long)4, (long)3, (long)7})}))) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_129_magic_square_test","gpt_solution":"```cpp\n#include <iostream>\n#include <vector>\n#include <numeric>\n\n\/\/ Function to calculate whether the matrix is a magic square.\nbool magic_square_test(std::vector<std::vector<long>> my_matrix) {\n    int n = my_matrix.size();\n    if (n == 0) return false;\n    \n    \/\/ Check if the matrix is n x n\n    for (const auto& row : my_matrix) {\n        if (row.size() != n) return false;\n    }\n\n    \/\/ Calculate the sum of the first row to use as the reference sum\n    long target_sum = std::accumulate(my_matrix[0].begin(), my_matrix[0].end(), 0L);\n\n    \/\/ Check sums of all rows\n    for (const auto& row : my_matrix) {\n        if (std::accumulate(row.begin(), row.end(), 0L) != target_sum) {\n            return false;\n        }\n    }\n\n    \/\/ Check sums of all columns\n    for (int col = 0; col < n; ++col) {\n        long col_sum = 0;\n        for (int row = 0; row < n; ++row) {\n            col_sum += my_matrix[row][col];\n        }\n        if (col_sum != target_sum) {\n            return false;\n        }\n    }\n\n    \/\/ Check sums of both diagonals\n    long diagonal1_sum = 0, diagonal2_sum = 0;\n    for (int i = 0; i < n; ++i) {\n        diagonal1_sum += my_matrix[i][i];\n        diagonal2_sum += my_matrix[i][n - i - 1];\n    }\n    if (diagonal1_sum != target_sum || diagonal2_sum != target_sum) {\n        return false;\n    }\n\n    return true;\n}\n```\n\nThis function, `magic_square_test`, takes in a 2D vector representing a matrix and returns `true` if the matrix is a magic square, and `false` otherwise. A magic square is a matrix where the sum of each row, each column, and both main diagonals are all equal."}
{"name":"mbpp_130_max_occurrences","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the item with maximum frequency in a given vector.\nlong max_occurrences(std::vector<long> nums) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_130_max_occurrences.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = max_occurrences;\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)8, (long)4, (long)7, (long)9, (long)8, (long)2, (long)6, (long)5, (long)1, (long)6, (long)1, (long)2, (long)3, (long)2, (long)4, (long)6, (long)9, (long)1, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)8, (long)4, (long)7, (long)9, (long)8, (long)7, (long)9, (long)15, (long)14, (long)10, (long)12, (long)13, (long)16, (long)18}))) == (8));\n    assert(candidate((std::vector<long>({(long)10, (long)20, (long)20, (long)30, (long)40, (long)90, (long)80, (long)50, (long)30, (long)20, (long)50, (long)10}))) == (20));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_130_max_occurrences","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the item with maximum frequency in a given vector.\nlong max_occurrences(std::vector<long> nums) {\n    std::unordered_map<long, int> frequency_map;\n    long max_frequency_element = nums[0];\n    int max_frequency = 0;\n    \n    for(const long& num : nums) {\n        frequency_map[num]++;\n        if(frequency_map[num] > max_frequency) {\n            max_frequency = frequency_map[num];\n            max_frequency_element = num;\n        }\n    }\n    \n    return max_frequency_element;\n}\n\n\/\/ Test cases to validate the solution\nvoid test_max_occurrences() {\n    assert(max_occurrences({1, 3, 2, 1, 4, 1}) == 1);\n    assert(max_occurrences({3, 3, 3, 2, 2, 2, 3}) == 3);\n    assert(max_occurrences({5, 5, 5, 5, 5}) == 5);\n    assert(max_occurrences({7, 8, 9, 7, 8, 7}) == 7);\n    assert(max_occurrences({}) == 0);  \/\/ Edge case: Empty vector\n}\n\ntest_max_occurrences();\n```"}
{"name":"mbpp_131_reverse_vowels","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to reverse only the vowels of a given string (where y is not a vowel).\nstd::string reverse_vowels(std::string str1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_131_reverse_vowels.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = reverse_vowels;\n    assert(candidate((\"Python\")) == (\"Python\"));\n    assert(candidate((\"USA\")) == (\"ASU\"));\n    assert(candidate((\"ab\")) == (\"ab\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_131_reverse_vowels","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to check if a character is a vowel\nbool is_vowel(char c) {\n    c = tolower(c);\n    return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n}\n\n\/\/ Function to reverse only the vowels of a given string\nstd::string reverse_vowels(std::string str1) {\n    int left = 0;\n    int right = str1.length() - 1;\n    \n    while (left < right) {\n        \/\/ Move left pointer to the next vowel\n        while (left < right && !is_vowel(str1[left])) {\n            left++;\n        }\n        \n        \/\/ Move right pointer to the previous vowel\n        while (left < right && !is_vowel(str1[right])) {\n            right--;\n        }\n        \n        \/\/ Swap the vowels\n        if (left < right) {\n            std::swap(str1[left], str1[right]);\n            left++;\n            right--;\n        }\n    }\n    \n    return str1;\n}\n```\n\nTo use this function, simply call `reverse_vowels` with a string argument and it will return the string with reversed vowels. Note that this code does not have a `main` function as per the instructions."}
{"name":"mbpp_132_tup_string","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to convert a vector to a string.\nstd::string tup_string(std::vector<std::string> tup1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_132_tup_string.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = tup_string;\n    assert(candidate((std::vector<std::string>({(std::string)\"e\", (std::string)\"x\", (std::string)\"e\", (std::string)\"r\", (std::string)\"c\", (std::string)\"i\", (std::string)\"s\", (std::string)\"e\", (std::string)\"s\"}))) == (\"exercises\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"p\", (std::string)\"y\", (std::string)\"t\", (std::string)\"h\", (std::string)\"o\", (std::string)\"n\"}))) == (\"python\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"p\", (std::string)\"r\", (std::string)\"o\", (std::string)\"g\", (std::string)\"r\", (std::string)\"a\", (std::string)\"m\"}))) == (\"program\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_132_tup_string","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to convert a vector to a string.\nstd::string tup_string(std::vector<std::string> tup1) {\n    std::string result = \"(\";\n    for (size_t i = 0; i < tup1.size(); ++i) {\n        result += \"'\" + tup1[i] + \"'\";\n        if (i != tup1.size() - 1) {\n            result += \", \";\n        }\n    }\n    result += \")\";\n    return result;\n}\n```"}
{"name":"mbpp_133_sum_negativenum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to calculate the sum of the negative numbers of a given vector of numbers.\nlong sum_negativenum(std::vector<long> nums) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_133_sum_negativenum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sum_negativenum;\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-6, (long)-9, (long)11, (long)-12, (long)14, (long)-5, (long)17}))) == (-32));\n    assert(candidate((std::vector<long>({(long)10, (long)15, (long)-14, (long)13, (long)-18, (long)12, (long)-20}))) == (-52));\n    assert(candidate((std::vector<long>({(long)19, (long)-65, (long)57, (long)39, (long)152, (long)-639, (long)121, (long)44, (long)90, (long)-190}))) == (-894));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_133_sum_negativenum","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to calculate the sum of the negative numbers of a given vector of numbers.\nlong sum_negativenum(std::vector<long> nums) {\n    long sum = 0;\n    for (long num : nums) {\n        if (num < 0) {\n            sum += num;\n        }\n    }\n    return sum;\n}\n```"}
{"name":"mbpp_135_hexagonal_num","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the nth hexagonal number.\nlong hexagonal_num(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_135_hexagonal_num.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = hexagonal_num;\n    assert(candidate((10)) == (190));\n    assert(candidate((5)) == (45));\n    assert(candidate((7)) == (91));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_135_hexagonal_num","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the nth hexagonal number.\nlong hexagonal_num(long n) {\n    return n * (2 * n - 1);\n}\n```"}
{"name":"mbpp_138_is_Sum_Of_Powers_Of_Two","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to check whether the given number can be represented as sum of non-zero powers of 2 or not.\nbool is_Sum_Of_Powers_Of_Two(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_138_is_Sum_Of_Powers_Of_Two.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = is_Sum_Of_Powers_Of_Two;\n    assert(candidate((10)) == (true));\n    assert(candidate((7)) == (false));\n    assert(candidate((14)) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_138_is_Sum_Of_Powers_Of_Two","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to check whether the given number can be represented as sum of non-zero powers of 2 or not\nbool is_Sum_Of_Powers_Of_Two(long n) {\n    \/\/ If n is less than 1, it cannot be represented as a sum of positive powers of 2\n    if (n < 1) return false;\n\n    \/\/ Check each bit of n, if any bit is 1, that's a power of 2\n    while (n > 0) {\n        if (n % 2 != 0 && n % 2 != 1) return false;\n        n \/= 2;\n    }\n    \n    return true;\n}\n\n\/\/ Test cases\nint main() {\n    assert(is_Sum_Of_Powers_Of_Two(1) == true);  \/\/ 1 = 2^0\n    assert(is_Sum_Of_Powers_Of_Two(2) == true);  \/\/ 2 = 2^1\n    assert(is_Sum_Of_Powers_Of_Two(3) == true);  \/\/ 3 = 2^0 + 2^1\n    assert(is_Sum_Of_Powers_Of_Two(4) == true);  \/\/ 4 = 2^2\n    assert(is_Sum_Of_Powers_Of_Two(5) == true);  \/\/ 5 = 2^0 + 2^2\n    assert(is_Sum_Of_Powers_Of_Two(6) == true);  \/\/ 6 = 2^1 + 2^2\n    assert(is_Sum_Of_Powers_Of_Two(7) == true);  \/\/ 7 = 2^0 + 2^1 + 2^2\n    assert(is_Sum_Of_Powers_Of_Two(0) == false); \/\/ 0 cannot be represented as sum of non-zero powers of 2\n    assert(is_Sum_Of_Powers_Of_Two(-1) == false);\/\/ Negative number cannot be represented\n\n    cout << \"All test cases passed!\" << endl;\n    return 0;\n}\n```"}
{"name":"mbpp_141_pancake_sort","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to sort a vector of elements.\nstd::vector<long> pancake_sort(std::vector<long> nums) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_141_pancake_sort.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = pancake_sort;\n    assert(candidate((std::vector<long>({(long)15, (long)79, (long)25, (long)38, (long)69}))) == (std::vector<long>({(long)15, (long)25, (long)38, (long)69, (long)79})));\n    assert(candidate((std::vector<long>({(long)98, (long)12, (long)54, (long)36, (long)85}))) == (std::vector<long>({(long)12, (long)36, (long)54, (long)85, (long)98})));\n    assert(candidate((std::vector<long>({(long)41, (long)42, (long)32, (long)12, (long)23}))) == (std::vector<long>({(long)12, (long)23, (long)32, (long)41, (long)42})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_141_pancake_sort","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to flip the subarray nums[0..i]\nvoid flip(std::vector<long>& nums, int i) {\n    int start = 0;\n    while (start < i) {\n        std::swap(nums[start], nums[i]);\n        start++;\n        i--;\n    }\n}\n\n\/\/ Function to sort a vector of elements using Pancake Sort\nstd::vector<long> pancake_sort(std::vector<long> nums) {\n    int n = nums.size();\n    \/\/ One by one place maximum element at its correct position\n    for (int current_size = n; current_size > 1; --current_size) {\n        \/\/ Find position of the maximum element in the nums[0..current_size-1]\n        int max_idx = 0;\n        for (int i = 1; i < current_size; ++i) {\n            if (nums[i] > nums[max_idx]) {\n                max_idx = i;\n            }\n        }\n\n        \/\/ Move the maximum element to end of current array if it's not already at the end\n        if (max_idx != current_size - 1) {\n            \/\/ Flip the maximum element to the front\n            flip(nums, max_idx);\n            \/\/ Flip it to the current position\n            flip(nums, current_size - 1);\n        }\n    }\n    return nums;\n}\n```\n\nThis code defines a function `pancake_sort` that performs Pancake Sorting on a vector of long integers. It includes a helper function `flip` to reverse the subarray from the start to the given index."}
{"name":"mbpp_142_count_samepair","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to count number items that are identical in the same position of three given vectors.\nlong count_samepair(std::vector<long> list1, std::vector<long> list2, std::vector<long> list3) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_142_count_samepair.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = count_samepair;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8})), (std::vector<long>({(long)2, (long)2, (long)3, (long)1, (long)2, (long)6, (long)7, (long)9})), (std::vector<long>({(long)2, (long)1, (long)3, (long)1, (long)2, (long)6, (long)7, (long)9}))) == (3));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8})), (std::vector<long>({(long)2, (long)2, (long)3, (long)1, (long)2, (long)6, (long)7, (long)8})), (std::vector<long>({(long)2, (long)1, (long)3, (long)1, (long)2, (long)6, (long)7, (long)8}))) == (4));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)6, (long)7, (long)8})), (std::vector<long>({(long)2, (long)2, (long)3, (long)1, (long)2, (long)6, (long)7, (long)8})), (std::vector<long>({(long)2, (long)1, (long)3, (long)1, (long)2, (long)6, (long)7, (long)8}))) == (5));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_142_count_samepair","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to count number items that are identical in the same position of three given vectors.\nlong count_samepair(std::vector<long> list1, std::vector<long> list2, std::vector<long> list3) {\n    \/\/ Ensure that all lists are of the same size.\n    assert(list1.size() == list2.size() && list2.size() == list3.size());\n\n    long count = 0;\n    for (size_t i = 0; i < list1.size(); ++i) {\n        if (list1[i] == list2[i] && list2[i] == list3[i]) {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"name":"mbpp_143_find_lists","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find number of vectors present in the given vector.\nlong find_lists(std::vector<std::any> Input) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_143_find_lists.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_lists;\n    assert(candidate((std::vector<std::any>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7, (long)8})}))) == (2));\n    assert(candidate((std::vector<std::any>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6})}))) == (3));\n    assert(candidate((std::vector<std::any>({(long)9, (long)8, (long)7, (long)6, (long)5, (long)4, (long)3, (long)2, (long)1}))) == (1));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_143_find_lists","gpt_solution":"```cpp\n#include <vector>\n#include <any>\n#include <type_traits>\n#include <iostream>\n\n\/\/ Write a function to find number of vectors present in the given vector.\nlong find_lists(std::vector<std::any> Input) {\n    long count = 0;\n    for (const auto& item : Input) {\n        if (item.type() == typeid(std::vector<std::any>)) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n\nThis function iterates through the given vector of `std::any` elements and counts how many elements are vectors of `std::any`."}
{"name":"mbpp_145_max_Abs_Diff","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the maximum difference between any two elements in a given vector.\nlong max_Abs_Diff(std::vector<long> arr) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_145_max_Abs_Diff.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = max_Abs_Diff;\n    assert(candidate((std::vector<long>({(long)2, (long)1, (long)5, (long)3}))) == (4));\n    assert(candidate((std::vector<long>({(long)9, (long)3, (long)2, (long)5, (long)1}))) == (8));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (2));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_145_max_Abs_Diff","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cpp function to find the maximum difference between any two elements in a given vector.\nlong max_Abs_Diff(std::vector<long> arr) {\n    if (arr.size() < 2) {\n        return 0;\n    }\n\n    long min_element = *std::min_element(arr.begin(), arr.end());\n    long max_element = *std::max_element(arr.begin(), arr.end());\n\n    return max_element - min_element;\n}\n```"}
{"name":"mbpp_160_find_solution","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\nstd::optional<std::tuple<long, long>> find_solution(long a, long b, long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_160_find_solution.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_solution;\n    assert(candidate((2), (3), (7)) == std::make_tuple(2, 1));\n    assert(candidate((4), (2), (7)) == std::nullopt);\n    assert(candidate((1), (13), (17)) == std::make_tuple(4, 1));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_160_find_solution","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\nstd::optional<std::tuple<long, long>> find_solution(long a, long b, long n) {\n    \/\/ Extended Euclidean Algorithm to find one solution to ax + by = gcd(a, b)\n    auto extended_gcd = [](long a, long b) {\n        long x0 = 1, y0 = 0, x1 = 0, y1 = 1;\n        while (b != 0) {\n            long q = a \/ b;\n            std::tie(a, b) = std::make_tuple(b, a % b);\n            std::tie(x0, x1) = std::make_tuple(x1, x0 - q * x1);\n            std::tie(y0, y1) = std::make_tuple(y1, y0 - q * y1);\n        }\n        return std::make_tuple(a, x0, y0);\n    };\n\n    \/\/ Compute gcd(a, b) and the coefficients xg and yg\n    auto [g, xg, yg] = extended_gcd(a, b);\n\n    \/\/ Check if n is divisible by gcd(a, b)\n    if (n % g != 0) {\n        return std::nullopt; \/\/ No solution exists\n    }\n\n    \/\/ Scale the solution of ax + by = g to ax + by = n\n    long k = n \/ g;\n    long x = xg * k;\n    long y = yg * k;\n\n    return std::make_tuple(x, y);\n}\n```"}
{"name":"mbpp_161_remove_elements","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to remove all elements from a given vector present in another vector.\nstd::vector<long> remove_elements(std::vector<long> list1, std::vector<long> list2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_161_remove_elements.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = remove_elements;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10})), (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))) == (std::vector<long>({(long)1, (long)3, (long)5, (long)7, (long)9, (long)10})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10})), (std::vector<long>({(long)1, (long)3, (long)5, (long)7}))) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8, (long)9, (long)10})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10})), (std::vector<long>({(long)5, (long)7}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)6, (long)8, (long)9, (long)10})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_161_remove_elements","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to remove all elements from a given vector present in another vector.\nstd::vector<long> remove_elements(std::vector<long> list1, std::vector<long> list2) {\n    std::unordered_set<long> elements_to_remove(list2.begin(), list2.end());\n    std::vector<long> result;\n    \n    for(const long& element : list1) {\n        if(elements_to_remove.find(element) == elements_to_remove.end()) {\n            result.push_back(element);\n        }\n    }\n    \n    return result;\n}\n```"}
{"name":"mbpp_162_sum_series","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to calculate the sum (n - 2*i) from i=0 to n \/\/ 2, for instance n + (n-2) + (n-4)... (until n-x =< 0).\nlong sum_series(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_162_sum_series.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sum_series;\n    assert(candidate((6)) == (12));\n    assert(candidate((10)) == (30));\n    assert(candidate((9)) == (25));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_162_sum_series","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to calculate the sum (n - 2*i) from i=0 to n \/\/ 2, \n\/\/ for instance n + (n-2) + (n-4)... (until n-x <= 0).\nlong sum_series(long n) {\n    \/\/ Initialize sum to 0\n    long sum = 0;\n    \/\/ Loop to add n - 2*i values to sum\n    for (long i = 0; n - 2*i >= 0; ++i) {\n        sum += n - 2*i;\n    }\n    return sum;\n}\n```\n\nThis function `sum_series` calculates the sum of the series \\(n, n-2, n-4, \\ldots\\) until the value becomes less than or equal to 0. The function starts with `n` and continuously subtracts 2 in each iteration, accumulating the sum of all these values."}
{"name":"mbpp_164_are_equivalent","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to determine if the sum of the divisors of two integers are the same.\nbool are_equivalent(long num1, long num2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_164_are_equivalent.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = are_equivalent;\n    assert(candidate((36), (57)) == (false));\n    assert(candidate((2), (4)) == (false));\n    assert(candidate((23), (47)) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_164_are_equivalent","gpt_solution":"```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <assert.h>\n\n\/\/ Function to compute the sum of divisors of a given number\nlong sum_of_divisors(long num) {\n    long sum = 0;\n    for(long i = 1; i <= sqrt(num); i++) {\n        if(num % i == 0) {\n            if(num \/ i == i) {\n                sum += i;\n            } else {\n                sum += i;\n                sum += num \/ i;\n            }\n        }\n    }\n    return sum;\n}\n\n\/\/ Function to determine if the sum of the divisors of two integers are the same\nbool are_equivalent(long num1, long num2) {\n    return sum_of_divisors(num1) == sum_of_divisors(num2);\n}\n\n\/\/ Unit tests for validation\nvoid test() {\n    assert(are_equivalent(6, 28) == false); \/\/ sum of divisors of 6 is 12, sum of divisors of 28 is 56\n    assert(are_equivalent(6, 6) == true);   \/\/ sum of divisors of 6 is 12\n    assert(are_equivalent(28, 28) == true); \/\/ sum of divisors of 28 is 56\n    assert(are_equivalent(21, 21) == true); \/\/ sum of divisors of 21 is 32\n    assert(are_equivalent(4, 4) == true);   \/\/ sum of divisors of 4 is 7\n\n    std::cout << \"All test cases pass\" << std::endl;\n}\n\n\/\/ Uncomment the following line if you need to run the tests\n\/\/ test();\n```"}
{"name":"mbpp_165_count_char_position","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\nlong count_char_position(std::string str1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_165_count_char_position.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = count_char_position;\n    assert(candidate((\"xbcefg\")) == (2));\n    assert(candidate((\"ABcED\")) == (3));\n    assert(candidate((\"AbgdeF\")) == (5));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_165_count_char_position","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\nlong count_char_position(std::string str1) {\n    long count = 0;\n    for (size_t i = 0; i < str1.length(); i++) {\n        char c = tolower(str1[i]);\n        if (c >= 'a' && c <= 'z') {\n            if (c - 'a' == i) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"name":"mbpp_166_find_even_pair","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that counts the number of pairs of integers in a vector that xor to an even number.\nlong find_even_pair(std::vector<long> A) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_166_find_even_pair.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_even_pair;\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)7, (long)2, (long)1}))) == (4));\n    assert(candidate((std::vector<long>({(long)7, (long)2, (long)8, (long)1, (long)0, (long)5, (long)11}))) == (9));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (1));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_166_find_even_pair","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function that counts the number of pairs of integers in a vector that xor to an even number.\nlong find_even_pair(std::vector<long> A) {\n    long even_count = 0;\n    long odd_count = 0;\n    \n    \/\/ Count the number of even and odd numbers in the vector\n    for(long num : A) {\n        if(num % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    \n    \/\/ The number of pairs of integers that XOR to an even number\n    \/\/ includes all even-even pairs and all odd-odd pairs.\n    long even_pairs = even_count * (even_count - 1) \/ 2;\n    long odd_pairs = odd_count * (odd_count - 1) \/ 2;\n    \n    return even_pairs + odd_pairs;\n}\n```"}
{"name":"mbpp_167_next_power_of_2","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the smallest power of 2 greater than or equal to n.\nlong next_power_of_2(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_167_next_power_of_2.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = next_power_of_2;\n    assert(candidate((0)) == (1));\n    assert(candidate((5)) == (8));\n    assert(candidate((17)) == (32));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_167_next_power_of_2","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a C++ function to find the smallest power of 2 greater than or equal to n.\nlong next_power_of_2(long n) {\n    if (n <= 0) return 1;\n    n--;\n    n |= n >> 1;\n    n |= n >> 2;\n    n |= n >> 4;\n    n |= n >> 8;\n    n |= n >> 16;\n    n |= n >> 32; \/\/ This line is necessary for 64-bit longs.\n    return n + 1;\n}\n\n\/\/ Example usage and test:\nvoid test_next_power_of_2() {\n    assert(next_power_of_2(0) == 1);\n    assert(next_power_of_2(1) == 1);\n    assert(next_power_of_2(2) == 2);\n    assert(next_power_of_2(3) == 4);\n    assert(next_power_of_2(4) == 4);\n    assert(next_power_of_2(5) == 8);\n    assert(next_power_of_2(15) == 16);\n    assert(next_power_of_2(16) == 16);\n    assert(next_power_of_2(17) == 32);\n    assert(next_power_of_2(1023) == 1024);\n    assert(next_power_of_2(1024) == 1024);\n    assert(next_power_of_2(1025) == 2048);\n}\n\ntest_next_power_of_2();\n\n```\n\nThis implementation uses bitwise operations to efficiently calculate the smallest power of 2 greater than or equal to the given number `n`. The `test_next_power_of_2` function provides basic tests to verify that the `next_power_of_2` function works correctly."}
{"name":"mbpp_168_frequency","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to count the number of occurrences of a number in a given vector.\nlong frequency(std::vector<long> a, long x) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_168_frequency.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = frequency;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (4)) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4})), (3)) == (3));\n    assert(candidate((std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)1, (long)2})), (1)) == (2));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_168_frequency","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to count the number of occurrences of a number in a given vector.\nlong frequency(std::vector<long> a, long x) {\n    return std::count(a.begin(), a.end(), x);\n}\n```"}
{"name":"mbpp_170_sum_range_list","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the sum of numbers in a vector within a range specified by two indices.\nlong sum_range_list(std::vector<long> list1, long m, long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_170_sum_range_list.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sum_range_list;\n    assert(candidate((std::vector<long>({(long)2, (long)1, (long)5, (long)6, (long)8, (long)3, (long)4, (long)9, (long)10, (long)11, (long)8, (long)12})), (8), (10)) == (29));\n    assert(candidate((std::vector<long>({(long)2, (long)1, (long)5, (long)6, (long)8, (long)3, (long)4, (long)9, (long)10, (long)11, (long)8, (long)12})), (5), (7)) == (16));\n    assert(candidate((std::vector<long>({(long)2, (long)1, (long)5, (long)6, (long)8, (long)3, (long)4, (long)9, (long)10, (long)11, (long)8, (long)12})), (7), (10)) == (38));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_170_sum_range_list","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to find the sum of numbers in a vector within a range specified by two indices.\nlong sum_range_list(std::vector<long> list1, long m, long n) {\n    assert(m >= 0 && n < list1.size() && m <= n);  \/\/ Ensure valid indices\n    long sum = 0;\n    for (long i = m; i <= n; ++i) {\n        sum += list1[i];\n    }\n    return sum;\n}\n```"}
{"name":"mbpp_171_perimeter_pentagon","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the perimeter of a regular pentagon from the length of its sides.\nlong perimeter_pentagon(long a) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_171_perimeter_pentagon.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = perimeter_pentagon;\n    assert(candidate((5)) == (25));\n    assert(candidate((10)) == (50));\n    assert(candidate((15)) == (75));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_171_perimeter_pentagon","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the perimeter of a regular pentagon from the length of its sides.\n\/\/ A regular pentagon has all sides of equal length. The perimeter is the sum of the lengths of all five sides.\n\nlong perimeter_pentagon(long a) {\n    \/\/ The perimeter of a pentagon with side length a is just 5 * a\n    return 5 * a;\n}\n```"}
{"name":"mbpp_172_count_occurance","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to count the number of occurence of the string 'std' in a given string.\nlong count_occurance(std::string s) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_172_count_occurance.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = count_occurance;\n    assert(candidate((\"letstdlenstdporstd\")) == (3));\n    assert(candidate((\"truststdsolensporsd\")) == (1));\n    assert(candidate((\"makestdsostdworthit\")) == (2));\n    assert(candidate((\"stds\")) == (1));\n    assert(candidate((\"\")) == (0));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_172_count_occurance","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to count the number of occurrence of the string 'std' in a given string.\nlong count_occurrence(std::string s) {\n    long count = 0;\n    std::string target = \"std\";\n    size_t pos = s.find(target);\n    while (pos != std::string::npos) {\n        count++;\n        pos = s.find(target, pos + 1);\n    }\n    return count;\n}\n```"}
{"name":"mbpp_222_check_type","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check if all the elements in tuple have same data type or not.\nbool check_type(std::any test_tuple) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_222_check_type.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = check_type;\n    assert(candidate(std::make_tuple(5, 6, 7, 3, 5, 6)) == (true));\n    assert(candidate(std::make_tuple(1, 2, \"4\")) == (false));\n    assert(candidate(std::make_tuple(3, 2, 1, 4, 5)) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_222_check_type","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n#include <any>\n\n\/\/ Utility function to check if all the elements in tuple have the same data type\ntemplate <typename Tuple, std::size_t... Is>\nbool check_tuple_types_impl(const Tuple& tuple, std::index_sequence<Is...>) {\n    \/\/ Using a fold expression to check all elements' types\n    return ((std::any::type() == std::get<Is>(tuple).type()) && ...);\n}\n\nbool check_type(std::any test_tuple) {\n    \/\/ Use std::tuple to retrieve the tuple type\n    auto* tuple_ptr = std::any_cast<std::tuple<std::any>*>(&test_tuple);\n    if (tuple_ptr == nullptr) return false;\n    const auto& tuple = *tuple_ptr;\n\n    \/\/ Get the first element's type for comparison\n    if (std::tuple_size_v<decltype(tuple)> == 0) return true;\n    const auto& first_elem = std::get<0>(tuple);\n\n    \/\/ Check if all elements have the same type as the first element\n    return std::apply([&](const auto&... elems) {\n        return ((elems.type() == first_elem.type()) && ...);\n    }, tuple);\n}\n```\n\nHere's the complete code that checks if all the elements in a given tuple have the same data type. Note that we avoided a `main` function as requested. The `check_type` function takes a `std::any` parameter which is expected to contain a tuple of `std::any`s, verifying if all elements within the tuple are of the same type."}
{"name":"mbpp_223_is_majority","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that takes in a sorted vector, its length (n), and an element and returns whether the element is the majority element in the given sorted vector. (The majority element is the element that occurs more than n\/2 times.)\nbool is_majority(std::vector<long> arr, long n, long x) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_223_is_majority.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = is_majority;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)3, (long)10})), (7), (3)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)4, (long)4, (long)4, (long)6, (long)6})), (8), (4)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)2})), (5), (1)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)2})), (5), (1)) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_223_is_majority","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function that takes in a sorted vector, its length (n), and an element and returns whether the element is the majority element in the given sorted vector. (The majority element is the element that occurs more than n\/2 times.)\nbool is_majority(std::vector<long> arr, long n, long x) {\n    \/\/ Use binary search to find the first occurrence of x\n    auto first_occurrence = std::lower_bound(arr.begin(), arr.end(), x);\n    \n    \/\/ Check if x is present in the array\n    if (first_occurrence == arr.end() || *first_occurrence != x) {\n        return false;\n    }\n    \n    \/\/ Calculate the index of the first occurrence\n    long first_index = first_occurrence - arr.begin();\n    \n    \/\/ Calculate the index of the element n\/2 positions ahead\n    long majority_index = first_index + n \/ 2;\n    \n    \/\/ Check if the element at the majority index is still x\n    \/\/ and it doesn't exceed the array bounds.\n    if (majority_index < n && arr[majority_index] == x) {\n        return true;\n    }\n    \n    return false;\n}\n```"}
{"name":"mbpp_224_count_Set_Bits","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to count the number of set bits (binary digits with value 1) in a given number.\nlong count_Set_Bits(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_224_count_Set_Bits.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = count_Set_Bits;\n    assert(candidate((2)) == (1));\n    assert(candidate((4)) == (1));\n    assert(candidate((6)) == (2));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_224_count_Set_Bits","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cpp function to count the number of set bits (binary digits with value 1) in a given number.\nlong count_Set_Bits(long n) {\n    long count = 0;\n    while (n) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\n\n\/\/ You can add some test cases to verify the function works correctly\nvoid test_count_Set_Bits() {\n    assert(count_Set_Bits(0) == 0);\n    assert(count_Set_Bits(1) == 1);\n    assert(count_Set_Bits(2) == 1);\n    assert(count_Set_Bits(3) == 2);\n    assert(count_Set_Bits(4) == 1);\n    assert(count_Set_Bits(7) == 3);\n    assert(count_Set_Bits(255) == 8);\n    assert(count_Set_Bits(256) == 1);\n    std::cout << \"All test cases passed!\" << std::endl;\n}\n\n\/\/ Calling the test function\nint main() {\n    test_count_Set_Bits();\n    return 0;\n}\n```\n\nThis code defines a function `count_Set_Bits` that counts the number of set bits (binary digits with value 1) in a given number `n`. The function uses a loop that iterates through each bit of the number, checking if it is set (i.e., if it is 1), and returns the total count of set bits.\n\nIt also includes a `test_count_Set_Bits` function to verify that `count_Set_Bits` works correctly for several test cases. The main function calls the test function to run the tests."}
{"name":"mbpp_226_odd_values_string","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to remove the characters which have odd index values of a given string.\nstd::string odd_values_string(std::string str) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_226_odd_values_string.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = odd_values_string;\n    assert(candidate((\"abcdef\")) == (\"ace\"));\n    assert(candidate((\"python\")) == (\"pto\"));\n    assert(candidate((\"data\")) == (\"dt\"));\n    assert(candidate((\"lambs\")) == (\"lms\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_226_odd_values_string","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n\n\/\/ Write a C++ function to remove the characters which have odd index values of a given string.\nstd::string odd_values_string(std::string str) {\n    std::string result;\n    \/\/ Iterate through the string, appending characters at even indices to the result.\n    for (size_t i = 0; i < str.size(); i++) {\n        if (i % 2 == 0) {\n            result += str[i];\n        }\n    }\n    return result;\n}\n\n\/\/ Example Usage\n\/\/ int main() {\n\/\/     std::string input = \"abcdef\";\n\/\/     std::string output = odd_values_string(input);\n\/\/     std::cout << output << std::endl;  \/\/ Output: ace\n\/\/     return 0;\n\/\/ }\n\n\/\/ The main function and example usage are commented out.\n```"}
{"name":"mbpp_227_min_of_three","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find minimum of three numbers.\nlong min_of_three(long a, long b, long c) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_227_min_of_three.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = min_of_three;\n    assert(candidate((10), (20), (0)) == (0));\n    assert(candidate((19), (15), (18)) == (15));\n    assert(candidate((-10), (-20), (-30)) == (-30));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_227_min_of_three","gpt_solution":"```cpp\n#include <cassert>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to find minimum of three numbers.\nlong min_of_three(long a, long b, long c) {\n    return std::min({a, b, c});\n}\n```"}
{"name":"mbpp_228_all_Bits_Set_In_The_Given_Range","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to check whether all the bits are unset in the given range or not.\nbool all_Bits_Set_In_The_Given_Range(long n, long l, long r) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_228_all_Bits_Set_In_The_Given_Range.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = all_Bits_Set_In_The_Given_Range;\n    assert(candidate((4), (1), (2)) == (true));\n    assert(candidate((17), (2), (4)) == (true));\n    assert(candidate((39), (4), (6)) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_228_all_Bits_Set_In_The_Given_Range","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a cpp function to check whether all the bits are unset in the given range or not.\nbool all_Bits_Set_In_The_Given_Range(long n, long l, long r) {\n    \/\/ Masks with bits set in the range l to r (1-indexed).\n    long mask = (1L << (r)) - 1;\n    mask ^= (1L << (l - 1)) - 1;\n\n    \/\/ Bitwise AND with n, and check if the result is equal to the mask.\n    return (n & mask) == mask;\n}\n```"}
{"name":"mbpp_229_re_arrange_array","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that takes in a vector and an integer n, and re-arranges the first n elements of the given vector so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\nstd::vector<long> re_arrange_array(std::vector<long> arr, long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_229_re_arrange_array.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = re_arrange_array;\n    assert(candidate((std::vector<long>({(long)-1, (long)2, (long)-3, (long)4, (long)5, (long)6, (long)-7, (long)8, (long)9})), (9)) == (std::vector<long>({(long)-1, (long)-3, (long)-7, (long)4, (long)5, (long)6, (long)2, (long)8, (long)9})));\n    assert(candidate((std::vector<long>({(long)12, (long)-14, (long)-26, (long)13, (long)15})), (5)) == (std::vector<long>({(long)-14, (long)-26, (long)12, (long)13, (long)15})));\n    assert(candidate((std::vector<long>({(long)10, (long)24, (long)36, (long)-42, (long)-39, (long)-78, (long)85})), (7)) == (std::vector<long>({(long)-42, (long)-39, (long)-78, (long)10, (long)24, (long)36, (long)85})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_229_re_arrange_array","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function that takes in a vector and an integer n, and re-arranges the first n elements of the given vector \n\/\/ so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\nstd::vector<long> re_arrange_array(std::vector<long> arr, long n) {\n    std::vector<long> negative_elements;\n    std::vector<long> positive_elements;\n    \n    for (long i = 0; i < n; ++i) {\n        if (arr[i] < 0) {\n            negative_elements.push_back(arr[i]);\n        } else {\n            positive_elements.push_back(arr[i]);\n        }\n    }\n    \n    std::vector<long> result;\n    result.insert(result.end(), negative_elements.begin(), negative_elements.end());\n    result.insert(result.end(), positive_elements.begin(), positive_elements.end());\n    result.insert(result.end(), arr.begin() + n, arr.end());\n    \n    return result;\n}\n```"}
{"name":"mbpp_230_replace_blank","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\nstd::string replace_blank(std::string str1, std::string char) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_230_replace_blank.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = replace_blank;\n    assert(candidate((\"hello people\"), (\"@\")) == (\"hello@people\"));\n    assert(candidate((\"python program language\"), (\"$\")) == (\"python$program$language\"));\n    assert(candidate((\"blank space\"), (\"-\")) == (\"blank-space\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_230_replace_blank","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\nstd::string replace_blank(std::string str1, char replacement_char) {\n    for (int i = 0; i < str1.length(); ++i) {\n        if (str1[i] == ' ') {\n            str1[i] = replacement_char;\n        }\n    }\n    return str1;\n}\n```"}
{"name":"mbpp_234_volume_cube","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the volume of a cube given its side length.\nlong volume_cube(long l) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_234_volume_cube.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = volume_cube;\n    assert(candidate((3)) == (27));\n    assert(candidate((2)) == (8));\n    assert(candidate((5)) == (125));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_234_volume_cube","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the volume of a cube given its side length.\nlong volume_cube(long l) {\n    return l * l * l;\n}\n```"}
{"name":"mbpp_237_check_occurences","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that takes in a vector of tuples and returns a map mapping each unique tuple to the number of times it occurs in the vector.\nstd::map<std::tuple<long, long>,long> check_occurences(std::vector<std::tuple<long, long>> test_list) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_237_check_occurences.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = check_occurences;\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(3, 1), (std::tuple<long, long>)std::make_tuple(1, 3), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(5, 2), (std::tuple<long, long>)std::make_tuple(6, 3)}))) == (std::map<std::tuple<long, long>,long>({{std::make_tuple(1, 3), 2}, {std::make_tuple(2, 5), 2}, {std::make_tuple(3, 6), 1}})));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(4, 2), (std::tuple<long, long>)std::make_tuple(2, 4), (std::tuple<long, long>)std::make_tuple(3, 6), (std::tuple<long, long>)std::make_tuple(6, 3), (std::tuple<long, long>)std::make_tuple(7, 4)}))) == (std::map<std::tuple<long, long>,long>({{std::make_tuple(2, 4), 2}, {std::make_tuple(3, 6), 2}, {std::make_tuple(4, 7), 1}})));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(13, 2), (std::tuple<long, long>)std::make_tuple(11, 23), (std::tuple<long, long>)std::make_tuple(12, 25), (std::tuple<long, long>)std::make_tuple(25, 12), (std::tuple<long, long>)std::make_tuple(16, 23)}))) == (std::map<std::tuple<long, long>,long>({{std::make_tuple(2, 13), 1}, {std::make_tuple(11, 23), 1}, {std::make_tuple(12, 25), 2}, {std::make_tuple(16, 23), 1}})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_237_check_occurences","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function that takes in a vector of tuples and returns a map mapping each unique tuple to the number of times it occurs in the vector.\nstd::map<std::tuple<long, long>,long> check_occurences(std::vector<std::tuple<long, long>> test_list) {\n    std::map<std::tuple<long, long>, long> occurrences;\n\n    \/\/ Iterate over each tuple in the vector and update the count in the map.\n    for(auto &tuple : test_list) {\n        occurrences[tuple]++;\n    }\n\n    return occurrences;\n}\n```"}
{"name":"mbpp_238_number_of_substrings","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to count the number of non-empty substrings of a given string.\nlong number_of_substrings(std::string str) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_238_number_of_substrings.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = number_of_substrings;\n    assert(candidate((\"abc\")) == (6));\n    assert(candidate((\"abcd\")) == (10));\n    assert(candidate((\"abcde\")) == (15));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_238_number_of_substrings","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n\n\/\/ Write a cpp function to count the number of non-empty substrings of a given string.\nlong number_of_substrings(std::string str) {\n    \/\/ The number of non-empty substrings of a string of length n is given by the formula:\n    \/\/ n * (n + 1) \/ 2\n    long n = str.length();\n    return n * (n + 1) \/ 2;\n}\n```"}
{"name":"mbpp_239_get_total_number_of_sequences","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nlong get_total_number_of_sequences(long m, long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_239_get_total_number_of_sequences.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = get_total_number_of_sequences;\n    assert(candidate((10), (4)) == (4));\n    assert(candidate((5), (2)) == (6));\n    assert(candidate((16), (3)) == (84));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_239_get_total_number_of_sequences","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nlong get_total_number_of_sequences(long m, long n) {\n    \/\/ Create a dp table where dp[i][j] represents the number of sequences of length i \n    \/\/ ending with an element j that satisfies the conditions\n    vector<vector<long>> dp(n + 1, vector<long>(m + 1, 0));\n    \n    \/\/ Base case: sequences of length 1, all elements from 1 to m are valid\n    for (long j = 1; j <= m; ++j) {\n        dp[1][j] = 1;\n    }\n    \n    \/\/ Fill the dp table\n    for (long i = 2; i <= n; ++i) {\n        for (long j = 1; j <= m; ++j) {\n            for (long k = 1; k <= j \/ 2; ++k) {\n                dp[i][j] += dp[i - 1][k];\n            }\n        }\n    }\n    \n    \/\/ Calculate the total number of valid sequences of length n\n    long total_sequences = 0;\n    for (long j = 1; j <= m; ++j) {\n        total_sequences += dp[n][j];\n    }\n    \n    return total_sequences;\n}\n```"}
{"name":"mbpp_240_replace_list","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that takes in two vectors and replaces the last element of the first vector with the elements of the second vector.\nstd::vector<std::any> replace_list(std::vector<std::any> list1, std::vector<std::any> list2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_240_replace_list.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = replace_list;\n    assert(candidate((std::vector<std::any>({(long)1, (long)3, (long)5, (long)7, (long)9, (long)10})), (std::vector<std::any>({(long)2, (long)4, (long)6, (long)8}))) == (std::vector<std::any>({(long)1, (long)3, (long)5, (long)7, (long)9, (long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((std::vector<std::any>({(long)1, (long)2, (long)3, (long)4, (long)5})), (std::vector<std::any>({(long)5, (long)6, (long)7, (long)8}))) == (std::vector<std::any>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8})));\n    assert(candidate((std::vector<std::any>({(std::string)\"red\", (std::string)\"blue\", (std::string)\"green\"})), (std::vector<std::any>({(std::string)\"yellow\"}))) == (std::vector<std::any>({(std::string)\"red\", (std::string)\"blue\", (std::string)\"yellow\"})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_240_replace_list","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function that takes in two vectors and replaces the last element of the first vector with the elements of the second vector.\nstd::vector<std::any> replace_list(std::vector<std::any> list1, std::vector<std::any> list2) {\n    if (!list1.empty()) {\n        \/\/ Remove the last element from the first list\n        list1.pop_back();\n    }\n    \/\/ Insert all elements of the second list at the end of the first list\n    list1.insert(list1.end(), list2.begin(), list2.end());\n    return list1;\n}\n\n\/\/ Example test cases to check the implementation\nvoid test_replace_list() {\n    std::vector<std::any> list1 = {1, 2, 3};\n    std::vector<std::any> list2 = {4, 5, 6};\n    std::vector<std::any> result = replace_list(list1, list2);\n    assert(result == std::vector<std::any>({1, 2, 4, 5, 6}));\n\n    list1 = {\"a\", \"b\", \"c\"};\n    list2 = {\"x\", \"y\"};\n    result = replace_list(list1, list2);\n    assert(result == std::vector<std::any>({\"a\", \"b\", \"x\", \"y\"}));\n\n    list1 = {10, 20};\n    list2 = {30};\n    result = replace_list(list1, list2);\n    assert(result == std::vector<std::any>({10, 30}));\n\n    list1 = {};\n    list2 = {100, 200};\n    result = replace_list(list1, list2);\n    assert(result == std::vector<std::any>({100, 200}));\n}\n```"}
{"name":"mbpp_242_count_charac","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to count the total number of characters in a string.\nlong count_charac(std::string str1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_242_count_charac.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = count_charac;\n    assert(candidate((\"python programming\")) == (18));\n    assert(candidate((\"language\")) == (8));\n    assert(candidate((\"words\")) == (5));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_242_count_charac","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to count the total number of characters in a string.\nlong count_charac(std::string str1) {\n    return str1.length();\n}\n```"}
{"name":"mbpp_244_next_Perfect_Square","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the next perfect square greater than a given number.\nlong next_Perfect_Square(long N) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_244_next_Perfect_Square.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = next_Perfect_Square;\n    assert(candidate((35)) == (36));\n    assert(candidate((6)) == (9));\n    assert(candidate((9)) == (16));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_244_next_Perfect_Square","gpt_solution":"```cpp\n#include<cmath>\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Write a cpp function to find the next perfect square greater than a given number.\nlong next_Perfect_Square(long N) {\n    \/\/ Find the square root of the given number\n    long root = sqrt(N);\n\n    \/\/ Check if it's a perfect square\n    if (root * root == N) {\n        root += 1; \/\/ If it's a perfect square, increment the root\n    } else {\n        root = ceil(sqrt(N)); \/\/ Otherwise, find the ceiling of the square root\n    }\n\n    \/\/ Return the next perfect square\n    return root * root;\n}\n\n\/\/ Example assertion to check function implementation\nint main() {\n    assert(next_Perfect_Square(6) == 9);\n    assert(next_Perfect_Square(15) == 16);\n    assert(next_Perfect_Square(24) == 25);\n    assert(next_Perfect_Square(36) == 49);\n\n    cout << \"All test cases passed!\\n\";\n\n    return 0;\n}\n```"}
{"name":"mbpp_245_max_sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that takes a vector and finds the maximum sum of a bitonic subsequence for the given vector, where a sequence is bitonic if it is first increasing and then decreasing.\nlong max_sum(std::vector<long> arr) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_245_max_sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = max_sum;\n    assert(candidate((std::vector<long>({(long)1, (long)15, (long)51, (long)45, (long)33, (long)100, (long)12, (long)18, (long)9}))) == (194));\n    assert(candidate((std::vector<long>({(long)80, (long)60, (long)30, (long)40, (long)20, (long)10}))) == (210));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)14, (long)16, (long)21, (long)23, (long)29, (long)30}))) == (138));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_245_max_sum","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function that takes a vector and finds the maximum sum of a bitonic subsequence for the given vector, where a sequence is bitonic if it is first increasing and then decreasing.\nlong max_sum(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return 0;\n\n    \/\/ Arrays to store maximum sum increasing subsequence until index i\n    std::vector<long> inc(n, 0);\n    \/\/ Arrays to store maximum sum decreasing subsequence from index i\n    std::vector<long> dec(n, 0);\n\n    \/\/ Fill inc[] using the logic of the Longest Increasing Subsequence\n    for (int i = 0; i < n; ++i) {\n        inc[i] = arr[i];\n        for (int j = 0; j < i; ++j) {\n            if (arr[i] > arr[j] && inc[i] < inc[j] + arr[i]) {\n                inc[i] = inc[j] + arr[i];\n            }\n        }\n    }\n\n    \/\/ Fill dec[] using the logic of the Longest Decreasing Subsequence\n    for (int i = n-1; i >= 0; --i) {\n        dec[i] = arr[i];\n        for (int j = n-1; j > i; --j) {\n            if (arr[i] > arr[j] && dec[i] < dec[j] + arr[i]) {\n                dec[i] = dec[j] + arr[i];\n            }\n        }\n    }\n\n    \/\/ Find the maximum value of inc[i] + dec[i] - arr[i]\n    long max_sum = 0;\n    for (int i = 0; i < n; ++i) {\n        max_sum = std::max(max_sum, inc[i] + dec[i] - arr[i]);\n    }\n\n    return max_sum;\n}\n\n\/\/ Example usage:\n\/\/ int main() {\n\/\/     std::vector<long> arr = {1, 2, 5, 3, 2};\n\/\/     std::cout << max_sum(arr) << std::endl;  \/\/ Output: 9 (1, 2, 5, 3)\n\/\/     return 0;\n\/\/ }\n```"}
{"name":"mbpp_247_lps","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_247_lps.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_247_lps","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    \/\/ Create a table to store results of subproblems\n    std::vector<std::vector<int>> dp(n, std::vector<int>(n, 0));\n\n    \/\/ Strings of length 1 are palindromes of length 1\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n\n    \/\/ Build the table\n    for (int cl = 2; cl <= n; cl++) { \/\/ cl is length of substring\n        for (int i = 0; i < n - cl + 1; i++) {\n            int j = i + cl - 1;\n            if (str[i] == str[j] && cl == 2) {\n                dp[i][j] = 2;\n            } else if (str[i] == str[j]) {\n                dp[i][j] = dp[i+1][j-1] + 2;\n            } else {\n                dp[i][j] = std::max(dp[i][j-1], dp[i+1][j]);\n            }\n        }\n    }\n\n    \/\/ The length of the longest palindromic subsequence\n    return dp[0][n-1];\n}\n```\n\nHere's the code that completes the function `lps` to find the length of the longest palindromic subsequence in the given string. The function uses dynamic programming to build a table that stores results of subproblems, ensuring an efficient and optimal solution."}
{"name":"mbpp_249_intersection_array","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the intersection of two vectors.\nstd::vector<long> intersection_array(std::vector<long> array_nums1, std::vector<long> array_nums2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_249_intersection_array.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = intersection_array;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)7, (long)8, (long)9, (long)10})), (std::vector<long>({(long)1, (long)2, (long)4, (long)8, (long)9}))) == (std::vector<long>({(long)1, (long)2, (long)8, (long)9})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)7, (long)8, (long)9, (long)10})), (std::vector<long>({(long)3, (long)5, (long)7, (long)9}))) == (std::vector<long>({(long)3, (long)5, (long)7, (long)9})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)7, (long)8, (long)9, (long)10})), (std::vector<long>({(long)10, (long)20, (long)30, (long)40}))) == (std::vector<long>({(long)10})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_249_intersection_array","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the intersection of two vectors.\nstd::vector<long> intersection_array(std::vector<long> array_nums1, std::vector<long> array_nums2) {\n    std::unordered_set<long> set1(array_nums1.begin(), array_nums1.end());\n    std::unordered_set<long> set2(array_nums2.begin(), array_nums2.end());\n    std::vector<long> intersection;\n\n    for (const long& num : set2) {\n        if (set1.find(num) != set1.end()) {\n            intersection.push_back(num);\n        }\n    }\n\n    return intersection;\n}\n```"}
{"name":"mbpp_250_count_X","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function that takes in a tuple and an element and counts the occcurences of the element in the vector.\nlong count_X(std::vector<long> tup, long x) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_250_count_X.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = count_X;\n    assert(candidate((std::vector<long>({(long)10, (long)8, (long)5, (long)2, (long)10, (long)15, (long)10, (long)8, (long)5, (long)8, (long)8, (long)2})), (4)) == (0));\n    assert(candidate((std::vector<long>({(long)10, (long)8, (long)5, (long)2, (long)10, (long)15, (long)10, (long)8, (long)5, (long)8, (long)8, (long)2})), (10)) == (3));\n    assert(candidate((std::vector<long>({(long)10, (long)8, (long)5, (long)2, (long)10, (long)15, (long)10, (long)8, (long)5, (long)8, (long)8, (long)2})), (8)) == (4));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_250_count_X","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n#include <assert.h>\n\n\/\/ Write a cpp function that takes in a vector and an element and counts the occurrences of the element in the vector.\nlong count_X(std::vector<long> tup, long x) {\n    return std::count(tup.begin(), tup.end(), x);\n}\n```"}
{"name":"mbpp_251_insert_element","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that takes in a vector and an element and inserts the element before each element in the vector, and returns the resulting vector.\nstd::vector<std::string> insert_element(std::vector<std::string> list, std::string element) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_251_insert_element.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = insert_element;\n    assert(candidate((std::vector<std::string>({(std::string)\"Red\", (std::string)\"Green\", (std::string)\"Black\"})), (\"c\")) == (std::vector<std::string>({(std::string)\"c\", (std::string)\"Red\", (std::string)\"c\", (std::string)\"Green\", (std::string)\"c\", (std::string)\"Black\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"python\", (std::string)\"java\"})), (\"program\")) == (std::vector<std::string>({(std::string)\"program\", (std::string)\"python\", (std::string)\"program\", (std::string)\"java\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"happy\", (std::string)\"sad\"})), (\"laugh\")) == (std::vector<std::string>({(std::string)\"laugh\", (std::string)\"happy\", (std::string)\"laugh\", (std::string)\"sad\"})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_251_insert_element","gpt_solution":"```cpp\n#include <vector>\n#include <string>\n\n\/\/ Write a function that takes in a vector and an element and inserts the element before each element in the vector, and returns the resulting vector.\nstd::vector<std::string> insert_element(std::vector<std::string> list, std::string element) {\n    std::vector<std::string> result;\n    for(auto &item : list) {\n        result.push_back(element);\n        result.push_back(item);\n    }\n    return result;\n}\n```"}
{"name":"mbpp_252_convert","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to convert complex numbers to polar coordinates.\nstd::tuple<float, float> convert(long numbers) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_252_convert.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = convert;\n    assert(candidate((1)) == (std::make_tuple(1.0f, 0.0f)));\n    assert(candidate((4)) == (std::make_tuple(4.0f, 0.0f)));\n    assert(candidate((5)) == (std::make_tuple(5.0f, 0.0f)));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_252_convert","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to convert complex numbers to polar coordinates\nstd::tuple<float, float> convert(std::complex<float> number) {\n    float magnitude = std::abs(number);\n    float angle = std::arg(number);\n    return std::make_tuple(magnitude, angle);\n}\n```\n\nTo use the `convert` function, you can pass a `std::complex<float>` number to it and it will return a tuple containing the magnitude and angle in radians. Below is an example of usage:\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::complex<float> number(3.0, 4.0);\n    auto polar_coordinates = convert(number);\n    \n    std::cout << \"Magnitude: \" << std::get<0>(polar_coordinates) << \"\\n\";\n    std::cout << \"Angle: \" << std::get<1>(polar_coordinates) << \"\\n\";\n    \n    return 0;\n}\n```"}
{"name":"mbpp_253_count_integer","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\nunion Union_long_std_string_float{\n    long f0;\n    std::string f1;\n    float f2;    Union_long_std_string_float(long _f0) : f0(_f0) {}\n    Union_long_std_string_float(std::string _f1) : f1(_f1) {}\n    Union_long_std_string_float(float _f2) : f2(_f2) {}\n    ~Union_long_std_string_float() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(std::string f) {\n        return f1 == f ;\n    }    bool operator==(float f) {\n        return f2 == f ;\n    }\n};\n\/\/ Write a cppthon function that returns the number of integer elements in a given vector.\nlong count_integer(std::vector<Union_long_std_string_float> list1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_253_count_integer.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = count_integer;\n    assert(candidate((std::vector<Union_long_std_string_float>({1, 2, \"abc\", 1.2f}))) == (2));\n    assert(candidate((std::vector<Union_long_std_string_float>({(long)1, (long)2, (long)3}))) == (3));\n    assert(candidate((std::vector<Union_long_std_string_float>({(long)1, (long)1.2f, (long)4, (long)5.1f}))) == (2));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_253_count_integer","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Union definition\nunion Union_long_std_string_float {\n    long f0;\n    std::string f1;\n    float f2;\n\n    \/\/ Constructor for long\n    Union_long_std_string_float(long _f0) : f0(_f0) {}\n\n    \/\/ Constructor for std::string\n    Union_long_std_string_float(std::string _f1) : f1(_f1) {}\n\n    \/\/ Constructor for float\n    Union_long_std_string_float(float _f2) : f2(_f2) {}\n\n    \/\/ Destructor\n    ~Union_long_std_string_float() {}\n    \n    \/\/ Operator overloads for comparison\n    bool operator==(long f) {\n        return f0 == f ;\n    } \n\n    bool operator==(std::string f) {\n        return f1 == f ;\n    } \n\n    bool operator==(float f) {\n        return f2 == f ;\n    }\n};\n\n\/\/ Function to count the number of integer elements in a given vector\nlong count_integer(std::vector<Union_long_std_string_float> list1) {\n    long count = 0;\n    for(const auto& elem : list1) {\n        \/\/ The logic here assumes that the type f0 is set to long integers in the union\n        try {\n            long test = elem.f0; \/\/ If the type was long, this assignment should work\n            count++;\n        } catch (...) {\n            \/\/ Do nothing, skip this element\n        }\n    }\n    return count;\n}\n```"}
{"name":"mbpp_255_combinations_colors","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that takes in a vector and length n, and generates all combinations (with repetition) of the elements of the vector and returns a vector with a vector for each combination.\nstd::vector<std::vector<std::string>> combinations_colors(std::vector<std::string> l, long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_255_combinations_colors.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = combinations_colors;\n    assert(candidate((std::vector<std::string>({(std::string)\"Red\", (std::string)\"Green\", (std::string)\"Blue\"})), (1)) == (std::vector<std::vector<std::string>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"Red\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"Green\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"Blue\"})})));\n    assert(candidate((std::vector<std::string>({(std::string)\"Red\", (std::string)\"Green\", (std::string)\"Blue\"})), (2)) == (std::vector<std::vector<std::string>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"Red\", (std::string)\"Red\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"Red\", (std::string)\"Green\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"Red\", (std::string)\"Blue\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"Green\", (std::string)\"Green\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"Green\", (std::string)\"Blue\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"Blue\", (std::string)\"Blue\"})})));\n    assert(candidate((std::vector<std::string>({(std::string)\"Red\", (std::string)\"Green\", (std::string)\"Blue\"})), (3)) == (std::vector<std::vector<std::string>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"Red\", (std::string)\"Red\", (std::string)\"Red\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"Red\", (std::string)\"Red\", (std::string)\"Green\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"Red\", (std::string)\"Red\", (std::string)\"Blue\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"Red\", (std::string)\"Green\", (std::string)\"Green\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"Red\", (std::string)\"Green\", (std::string)\"Blue\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"Red\", (std::string)\"Blue\", (std::string)\"Blue\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"Green\", (std::string)\"Green\", (std::string)\"Green\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"Green\", (std::string)\"Green\", (std::string)\"Blue\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"Green\", (std::string)\"Blue\", (std::string)\"Blue\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"Blue\", (std::string)\"Blue\", (std::string)\"Blue\"})})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_255_combinations_colors","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to generate all combinations (with repetition) of the elements of the vector\nvoid generate_combinations(std::vector<std::vector<std::string>>& result, std::vector<std::string>& l,\n                           std::vector<std::string>& current, long n, long start) {\n    if (current.size() == n) {\n        result.push_back(current);\n        return;\n    }\n\n    for (long i = start; i < l.size(); ++i) {\n        current.push_back(l[i]);\n        generate_combinations(result, l, current, n, i);\n        current.pop_back();\n    }\n}\n\nstd::vector<std::vector<std::string>> combinations_colors(std::vector<std::string> l, long n) {\n    std::vector<std::vector<std::string>> result;\n    std::vector<std::string> current;\n    generate_combinations(result, l, current, n, 0);\n    return result;\n}\n```"}
{"name":"mbpp_256_count_Primes_nums","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\nlong count_Primes_nums(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_256_count_Primes_nums.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = count_Primes_nums;\n    assert(candidate((5)) == (2));\n    assert(candidate((10)) == (4));\n    assert(candidate((100)) == (25));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_256_count_Primes_nums","gpt_solution":"```cpp\n#include <vector>\n#include <cmath>\n\n\/\/ Function to count the number of prime numbers less than the given non-negative number.\nlong count_Primes_nums(long n) {\n    if (n <= 2) return 0; \/\/ There are no prime numbers less than 2.\n\n    \/\/ Use the Sieve of Eratosthenes to find all primes less than n.\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false; \/\/ 0 and 1 are not prime numbers.\n\n    for (long i = 2; i <= std::sqrt(n); ++i) {\n        if (is_prime[i]) {\n            for (long j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    \/\/ Count the number of primes.\n    long prime_count = 0;\n    for (long i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            ++prime_count;\n        }\n    }\n\n    return prime_count;\n}\n```"}
{"name":"mbpp_257_swap_numbers","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that takes in two numbers and returns a vector with the second number and then the first number.\nstd::vector<long> swap_numbers(long a, long b) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_257_swap_numbers.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = swap_numbers;\n    assert(candidate((10), (20)) == (std::vector<long>({(long)20, (long)10})));\n    assert(candidate((15), (17)) == (std::vector<long>({(long)17, (long)15})));\n    assert(candidate((100), (200)) == (std::vector<long>({(long)200, (long)100})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_257_swap_numbers","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function that takes in two numbers and returns a vector with the second number and then the first number.\nstd::vector<long> swap_numbers(long a, long b) {\n    std::vector<long> result;\n    result.push_back(b);\n    result.push_back(a);\n    return result;\n}\n```"}
{"name":"mbpp_259_maximize_elements","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to maximize the given two vectors.\nstd::vector<std::vector<long>> maximize_elements(std::vector<std::vector<long>> test_tup1, std::vector<std::vector<long>> test_tup2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_259_maximize_elements.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = maximize_elements;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5}), (std::vector<long>)std::vector<long>({(long)2, (long)9}), (std::vector<long>)std::vector<long>({(long)1, (long)10})})), (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)7}), (std::vector<long>)std::vector<long>({(long)3, (long)9}), (std::vector<long>)std::vector<long>({(long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)7, (long)3})}))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)7}), (std::vector<long>)std::vector<long>({(long)4, (long)9}), (std::vector<long>)std::vector<long>({(long)2, (long)9}), (std::vector<long>)std::vector<long>({(long)7, (long)10})})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)10}), (std::vector<long>)std::vector<long>({(long)2, (long)11})})), (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)4, (long)10}), (std::vector<long>)std::vector<long>({(long)2, (long)2}), (std::vector<long>)std::vector<long>({(long)8, (long)4})}))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)5, (long)10}), (std::vector<long>)std::vector<long>({(long)3, (long)10}), (std::vector<long>)std::vector<long>({(long)8, (long)11})})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)3, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)7}), (std::vector<long>)std::vector<long>({(long)4, (long)11}), (std::vector<long>)std::vector<long>({(long)3, (long)12})})), (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)5, (long)11}), (std::vector<long>)std::vector<long>({(long)3, (long)3}), (std::vector<long>)std::vector<long>({(long)9, (long)5})}))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)6, (long)11}), (std::vector<long>)std::vector<long>({(long)4, (long)11}), (std::vector<long>)std::vector<long>({(long)9, (long)12})})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_259_maximize_elements","gpt_solution":"```cpp\n#include <vector>\n#include <algorithm>\n\n\/\/ Write a function to maximize the given two vectors.\nstd::vector<std::vector<long>> maximize_elements(std::vector<std::vector<long>> test_tup1, std::vector<std::vector<long>> test_tup2) {\n    \/\/ Ensure both vectors have same outer size\n    assert(test_tup1.size() == test_tup2.size());\n\n    std::vector<std::vector<long>> result;\n    \n    for (size_t i = 0; i < test_tup1.size(); ++i) {\n        \/\/ Ensure both inner vectors at each index have the same size\n        assert(test_tup1[i].size() == test_tup2[i].size());\n        \n        std::vector<long> temp;\n        for (size_t j = 0; j < test_tup1[i].size(); ++j) {\n            temp.push_back(std::max(test_tup1[i][j], test_tup2[i][j]));\n        }\n        result.push_back(temp);\n    }\n    \n    return result;\n}\n```"}
{"name":"mbpp_260_newman_prime","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the nth newman\u2013shanks\u2013williams prime number.\nlong newman_prime(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_260_newman_prime.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = newman_prime;\n    assert(candidate((3)) == (7));\n    assert(candidate((4)) == (17));\n    assert(candidate((5)) == (41));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_260_newman_prime","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the nth newman\u2013shanks\u2013williams prime number.\nlong newman_prime(long n) {\n    if (n == 0) return 1;\n    if (n == 1) return 1;\n    std::vector<long> nsw_primes(n + 1, 0);\n    nsw_primes[0] = 1;\n    nsw_primes[1] = 1;\n    for (long i = 2; i <= n; ++i) {\n        nsw_primes[i] = 2 * nsw_primes[i-1] + nsw_primes[i-2];\n    }\n    return nsw_primes[n];\n}\n```"}
{"name":"mbpp_261_division_elements","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.\nstd::tuple<long, long, long, long> division_elements(std::tuple<long, long, long, long> test_tup1, std::tuple<long, long, long, long> test_tup2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_261_division_elements.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = division_elements;\n    assert(candidate((std::make_tuple(10, 4, 6, 9)), (std::make_tuple(5, 2, 3, 3))) == (std::make_tuple(2, 2, 2, 3)));\n    assert(candidate((std::make_tuple(12, 6, 8, 16)), (std::make_tuple(6, 3, 4, 4))) == (std::make_tuple(2, 2, 2, 4)));\n    assert(candidate((std::make_tuple(20, 14, 36, 18)), (std::make_tuple(5, 7, 6, 9))) == (std::make_tuple(4, 2, 6, 2)));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_261_division_elements","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.\nstd::tuple<long, long, long, long> division_elements(std::tuple<long, long, long, long> test_tup1, std::tuple<long, long, long, long> test_tup2) {\n    long a1, b1, c1, d1;\n    long a2, b2, c2, d2;\n    std::tie(a1, b1, c1, d1) = test_tup1;\n    std::tie(a2, b2, c2, d2) = test_tup2;\n\n    \/\/ Check if any element of the second tuple is zero to prevent division by zero\n    assert(a2 != 0 && b2 != 0 && c2 != 0 && d2 != 0);\n\n    return std::make_tuple(a1 \/ a2, b1 \/ b2, c1 \/ c2, d1 \/ d2);\n}\n```\n\nThis function takes in two `std::tuple<long, long, long, long>` objects, extracts the elements from both tuples, and performs element-wise division. Before dividing, it asserts that none of the elements in the second tuple are zero to avoid division by zero errors. The result is then returned as a new tuple."}
{"name":"mbpp_262_split_two_parts","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that takes in a vector and an integer L and splits the given vector into two parts where the length of the first part of the vector is L, and returns the resulting vectors in a tuple.\nstd::any split_two_parts(std::vector<std::any> list1, long L) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_262_split_two_parts.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = split_two_parts;\n    assert(candidate((std::vector<std::any>({(long)1, (long)1, (long)2, (long)3, (long)4, (long)4, (long)5, (long)1})), (3)) == std::make_tuple(std::vector<long>({(long)1, (long)1, (long)2}), std::vector<long>({(long)3, (long)4, (long)4, (long)5, (long)1})));\n    assert(candidate((std::vector<std::any>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\", (std::string)\"d\"})), (2)) == std::make_tuple(std::vector<std::string>({(std::string)\"a\", (std::string)\"b\"}), std::vector<std::string>({(std::string)\"c\", (std::string)\"d\"})));\n    assert(candidate((std::vector<std::any>({(std::string)\"p\", (std::string)\"y\", (std::string)\"t\", (std::string)\"h\", (std::string)\"o\", (std::string)\"n\"})), (4)) == std::make_tuple(std::vector<std::string>({(std::string)\"p\", (std::string)\"y\", (std::string)\"t\", (std::string)\"h\"}), std::vector<std::string>({(std::string)\"o\", (std::string)\"n\"})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_262_split_two_parts","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n#include <any>\n\nstd::tuple<std::vector<std::any>, std::vector<std::any>> split_two_parts(std::vector<std::any> list1, long L) {\n    std::vector<std::any> first_part, second_part;\n    \n    \/\/ Ensure L is in a valid range\n    if (L < 0) L = 0;\n    if (L > list1.size()) L = list1.size();\n\n    \/\/ Split the vector into two parts\n    first_part.insert(first_part.end(), list1.begin(), list1.begin() + L);\n    second_part.insert(second_part.end(), list1.begin() + L, list1.end());\n\n    return std::make_tuple(first_part, second_part);\n}\n```"}
{"name":"mbpp_264_dog_age","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to calculate a dog's age in dog's years.\nlong dog_age(long h_age) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_264_dog_age.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = dog_age;\n    assert(candidate((12)) == (61));\n    assert(candidate((15)) == (73));\n    assert(candidate((24)) == (109));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_264_dog_age","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to calculate a dog's age in dog's years.\nlong dog_age(long h_age) {\n    \/\/ Typically, a dog's first year is equivalent to 15 human years,\n    \/\/ the second year is equivalent to 9 human years,\n    \/\/ and every year after that is equivalent to 5 human years.\n    if (h_age <= 0) {\n        return 0;\n    } else if (h_age == 1) {\n        return 15;\n    } else if (h_age == 2) {\n        return 15 + 9;\n    } else {\n        return 15 + 9 + (h_age - 2) * 5;\n    }\n}\n\n\/\/ Test cases\nvoid test_dog_age() {\n    assert(dog_age(0) == 0);\n    assert(dog_age(1) == 15);\n    assert(dog_age(2) == 24);\n    assert(dog_age(3) == 29);\n    assert(dog_age(4) == 34);\n    assert(dog_age(10) == 64);\n}\n\nint main() {\n    test_dog_age();\n    std::cout << \"All tests passed.\" << std::endl;\n    return 0;\n}\n```"}
{"name":"mbpp_265_list_split","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that takes in a vector and an integer n and splits a vector for every nth element, returning a vector of the resulting vectors.\nstd::vector<std::vector<std::any>> list_split(std::vector<std::any> S, long step) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_265_list_split.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = list_split;\n    assert(candidate((std::vector<std::any>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\", (std::string)\"d\", (std::string)\"e\", (std::string)\"f\", (std::string)\"g\", (std::string)\"h\", (std::string)\"i\", (std::string)\"j\", (std::string)\"k\", (std::string)\"l\", (std::string)\"m\", (std::string)\"n\"})), (3)) == (std::vector<std::vector<std::any>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"a\", (std::string)\"d\", (std::string)\"g\", (std::string)\"j\", (std::string)\"m\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"b\", (std::string)\"e\", (std::string)\"h\", (std::string)\"k\", (std::string)\"n\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"c\", (std::string)\"f\", (std::string)\"i\", (std::string)\"l\"})})));\n    assert(candidate((std::vector<std::any>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10, (long)11, (long)12, (long)13, (long)14})), (3)) == (std::vector<std::vector<std::any>>({(std::vector<long>)std::vector<long>({(long)1, (long)4, (long)7, (long)10, (long)13}), (std::vector<long>)std::vector<long>({(long)2, (long)5, (long)8, (long)11, (long)14}), (std::vector<long>)std::vector<long>({(long)3, (long)6, (long)9, (long)12})})));\n    assert(candidate((std::vector<std::any>({(std::string)\"python\", (std::string)\"java\", (std::string)\"C\", (std::string)\"C++\", (std::string)\"DBMS\", (std::string)\"SQL\"})), (2)) == (std::vector<std::vector<std::any>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"python\", (std::string)\"C\", (std::string)\"DBMS\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"java\", (std::string)\"C++\", (std::string)\"SQL\"})})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_265_list_split","gpt_solution":"```cpp\n#include <cassert>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function that takes in a vector and an integer n and splits a vector for every nth element, \n\/\/ returning a vector of the resulting vectors.\nstd::vector<std::vector<std::any>> list_split(std::vector<std::any> S, long step) {\n    std::vector<std::vector<std::any>> result;\n    std::vector<std::any> temp;\n\n    for (size_t i = 0; i < S.size(); ++i) {\n        if (i % step == 0 && !temp.empty()) {\n            result.push_back(temp);\n            temp.clear();\n        }\n        temp.push_back(S[i]);\n    }\n\n    if (!temp.empty()) {\n        result.push_back(temp);\n    }\n\n    return result;\n}\n```"}
{"name":"mbpp_266_lateralsurface_cube","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the lateral surface area of a cube given its side length.\nlong lateralsurface_cube(long l) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_266_lateralsurface_cube.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = lateralsurface_cube;\n    assert(candidate((5)) == (100));\n    assert(candidate((9)) == (324));\n    assert(candidate((10)) == (400));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_266_lateralsurface_cube","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the lateral surface area of a cube given its side length.\nlong lateralsurface_cube(long l) {\n    \/\/ Formula for the lateral surface area of a cube: 4 * (side length)^2\n    return 4 * l * l;\n}\n```"}
{"name":"mbpp_267_square_Sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function that takes in an integer n and returns the sum of the squares of the first n odd natural numbers.\nlong square_Sum(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_267_square_Sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = square_Sum;\n    assert(candidate((2)) == (10));\n    assert(candidate((3)) == (35));\n    assert(candidate((4)) == (84));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_267_square_Sum","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function that takes in an integer n and returns the sum of the squares of the first n odd natural numbers.\nlong square_Sum(long n) {\n    long sum = 0;\n    \/\/ Loop through the first n odd numbers and calculate their squares\n    for(long i = 0; i < n; i++) {\n        long oddNumber = 2 * i + 1;\n        sum += oddNumber * oddNumber;\n    }\n    return sum;\n}\n```"}
{"name":"mbpp_268_find_star_num","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the n'th star number.\nlong find_star_num(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_268_find_star_num.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_star_num;\n    assert(candidate((3)) == (37));\n    assert(candidate((4)) == (73));\n    assert(candidate((5)) == (121));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_268_find_star_num","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n#include <assert.h>\n\n\/\/ Write a function to find the n-th star number.\nlong find_star_num(long n) {\n    \/\/ The formula to find the n-th star number is 6n(n - 1) + 1\n    return 6 * n * (n - 1) + 1;\n}\n```\n\nThis function calculates the n-th star number based on the provided formula. For example, the star numbers start from 1, 13, 37, 73, etc. The formula `6n(n - 1) + 1` derives these numbers directly."}
{"name":"mbpp_269_ascii_value","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the ascii value of a character.\nlong ascii_value(std::string k) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_269_ascii_value.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = ascii_value;\n    assert(candidate((\"A\")) == (65));\n    assert(candidate((\"R\")) == (82));\n    assert(candidate((\"S\")) == (83));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_269_ascii_value","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the ascii value of a character.\nlong ascii_value(std::string k) {\n    assert(k.size() == 1); \/\/ Ensure the string is exactly one character long\n    return static_cast<long>(k[0]); \/\/ Return the ASCII value of the character\n}\n```\n\nThis function takes a string `k` as input and asserts that `k` has exactly one character. It then returns the ASCII value of that character."}
{"name":"mbpp_270_sum_even_and_even_index","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the sum of even numbers at even positions of a vector.\nlong sum_even_and_even_index(std::vector<long> arr) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_270_sum_even_and_even_index.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sum_even_and_even_index;\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)12, (long)1, (long)18, (long)8}))) == (30));\n    assert(candidate((std::vector<long>({(long)3, (long)20, (long)17, (long)9, (long)2, (long)10, (long)18, (long)13, (long)6, (long)18}))) == (26));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)12, (long)1}))) == (12));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_270_sum_even_and_even_index","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a cpp function to find the sum of even numbers at even positions of a vector.\nlong sum_even_and_even_index(std::vector<long> arr) {\n    long sum = 0;\n    for (size_t i = 0; i < arr.size(); i += 2) {\n        if (arr[i] % 2 == 0) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```\n\nThis function iterates through the vector by incrementing the index by 2, thus only accessing the even-indexed positions. It checks if the value at the even positions is even, adds them to the sum, and returns the total sum."}
{"name":"mbpp_271_even_Power_Sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function that takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.\nlong even_Power_Sum(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_271_even_Power_Sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = even_Power_Sum;\n    assert(candidate((2)) == (1056));\n    assert(candidate((3)) == (8832));\n    assert(candidate((1)) == (32));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_271_even_Power_Sum","gpt_solution":"```cpp\n#include <cassert>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function that takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.\nlong even_Power_Sum(long n) {\n    long sum = 0;\n    for (long i = 1; i <= n; ++i) {\n        long even_num = 2 * i;\n        sum += pow(even_num, 5);\n    }\n    return sum;\n}\n```"}
{"name":"mbpp_272_rear_extract","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that takes in a vector of tuples and returns a vector containing the rear element of each tuple.\nstd::vector<long> rear_extract(std::vector<std::tuple<long, std::string, long>> test_list) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_272_rear_extract.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = rear_extract;\n    assert(candidate((std::vector<std::tuple<long, std::string, long>>({(std::tuple<long, std::string, long>)std::make_tuple(1, \"Rash\", 21), (std::tuple<long, std::string, long>)std::make_tuple(2, \"Varsha\", 20), (std::tuple<long, std::string, long>)std::make_tuple(3, \"Kil\", 19)}))) == (std::vector<long>({(long)21, (long)20, (long)19})));\n    assert(candidate((std::vector<std::tuple<long, std::string, long>>({(std::tuple<long, std::string, long>)std::make_tuple(1, \"Sai\", 36), (std::tuple<long, std::string, long>)std::make_tuple(2, \"Ayesha\", 25), (std::tuple<long, std::string, long>)std::make_tuple(3, \"Salman\", 45)}))) == (std::vector<long>({(long)36, (long)25, (long)45})));\n    assert(candidate((std::vector<std::tuple<long, std::string, long>>({(std::tuple<long, std::string, long>)std::make_tuple(1, \"Sudeep\", 14), (std::tuple<long, std::string, long>)std::make_tuple(2, \"Vandana\", 36), (std::tuple<long, std::string, long>)std::make_tuple(3, \"Dawood\", 56)}))) == (std::vector<long>({(long)14, (long)36, (long)56})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_272_rear_extract","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function that takes in a vector of tuples and returns a vector containing the rear element of each tuple.\nstd::vector<long> rear_extract(std::vector<std::tuple<long, std::string, long>> test_list) {\n    std::vector<long> result;\n    for(const auto& item : test_list) {\n        result.push_back(std::get<2>(item));\n    }\n    return result;\n}\n```"}
{"name":"mbpp_273_substract_elements","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\nstd::tuple<long, long, long> substract_elements(std::tuple<long, long, long> test_tup1, std::tuple<long, long, long> test_tup2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_273_substract_elements.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = substract_elements;\n    assert(candidate((std::make_tuple(10, 4, 5)), (std::make_tuple(2, 5, 18))) == (std::make_tuple(8, -1, -13)));\n    assert(candidate((std::make_tuple(11, 2, 3)), (std::make_tuple(24, 45, 16))) == (std::make_tuple(-13, -43, -13)));\n    assert(candidate((std::make_tuple(7, 18, 9)), (std::make_tuple(10, 11, 12))) == (std::make_tuple(-3, 7, -3)));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_273_substract_elements","gpt_solution":"```cpp\n#include <tuple>\n#include <iostream>\n\n\/\/ Write a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\nstd::tuple<long, long, long> substract_elements(std::tuple<long, long, long> test_tup1, std::tuple<long, long, long> test_tup2) {\n    long first1, second1, third1;\n    long first2, second2, third2;\n\n    std::tie(first1, second1, third1) = test_tup1;\n    std::tie(first2, second2, third2) = test_tup2;\n\n    return std::make_tuple(first1 - first2, second1 - second2, third1 - third2);\n}\n\n\/\/ Example usage\nvoid test_subtract_elements() {\n    std::tuple<long, long, long> tuple1 = std::make_tuple(10, 20, 30);\n    std::tuple<long, long, long> tuple2 = std::make_tuple(1, 2, 3);\n    std::tuple<long, long, long> result = substract_elements(tuple1, tuple2);\n\n    \/\/ Expected output: (9, 18, 27)\n    assert(result == std::make_tuple(9, 18, 27));\n}\n\n\/\/ The test can be run and debugged by calling the test function.\ntest_subtract_elements();\n```"}
{"name":"mbpp_274_even_binomial_Coeff_Sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function that takes in a positive integer n and finds the sum of even index binomial coefficients.\nlong even_binomial_Coeff_Sum(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_274_even_binomial_Coeff_Sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = even_binomial_Coeff_Sum;\n    assert(candidate((4)) == (8));\n    assert(candidate((6)) == (32));\n    assert(candidate((2)) == (2));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_274_even_binomial_Coeff_Sum","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a cpp function that takes in a positive integer n and finds the sum of even index binomial coefficients.\nlong even_binomial_Coeff_Sum(long n) {\n    \/\/ The property of the binomial coefficients (Pascal's triangle) for even index sums:\n    \/\/ The sum of the even-indexed binomial coefficients is equal to 2^(n-1).\n    return pow(2, n-1);\n}\n```\n\nExplanation:\nThe sum of even-indexed binomial coefficients for a given `n` can be derived using the binomial theorem properties. If you consider the expansion of `(1+1)^n`, which is `2^n`, and realise that the sum of all binomial coefficients is `2^n`. For even indices, the sum is exactly half of that, or `2^(n-1)`. The function computes this using the `pow` function from the `<cmath>` library."}
{"name":"mbpp_277_dict_filter","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that takes in a map and integer n and filters the map to only include entries with values greater than or equal to n.\nstd::map<std::string,long> dict_filter(std::map<std::string,long> dict, long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_277_dict_filter.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = dict_filter;\n    assert(candidate((std::map<std::string,long>({{\"Cierra Vega\", 175}, {\"Alden Cantrell\", 180}, {\"Kierra Gentry\", 165}, {\"Pierre Cox\", 190}})), (170)) == (std::map<std::string,long>({{\"Cierra Vega\", 175}, {\"Alden Cantrell\", 180}, {\"Pierre Cox\", 190}})));\n    assert(candidate((std::map<std::string,long>({{\"Cierra Vega\", 175}, {\"Alden Cantrell\", 180}, {\"Kierra Gentry\", 165}, {\"Pierre Cox\", 190}})), (180)) == (std::map<std::string,long>({{\"Alden Cantrell\", 180}, {\"Pierre Cox\", 190}})));\n    assert(candidate((std::map<std::string,long>({{\"Cierra Vega\", 175}, {\"Alden Cantrell\", 180}, {\"Kierra Gentry\", 165}, {\"Pierre Cox\", 190}})), (190)) == (std::map<std::string,long>({{\"Pierre Cox\", 190}})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_277_dict_filter","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\nstd::map<std::string, long> dict_filter(std::map<std::string, long> dict, long n) {\n    std::map<std::string, long> filtered_dict;\n    for(auto const& pair : dict) {\n        if(pair.second >= n) {\n            filtered_dict[pair.first] = pair.second;\n        }\n    }\n    return filtered_dict;\n}\n```"}
{"name":"mbpp_278_count_first_elements","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\nunion Union_long_std_tuple_long, long_{\n    long f0;\n    std::tuple<long, long> f1;    Union_long_std_tuple_long, long_(long _f0) : f0(_f0) {}\n    Union_long_std_tuple_long, long_(std::tuple<long, long> _f1) : f1(_f1) {}\n    ~Union_long_std_tuple_long, long_() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(std::tuple<long, long> f) {\n        return f1 == f ;\n    }\n};\n\/\/ Write a function to find the number of elements that occurs before the vector element in the given tuple.\nlong count_first_elements(std::vector<Union_long_std_tuple_long, long_> test_tup) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_278_count_first_elements.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = count_first_elements;\n    assert(candidate((std::vector<Union_long_std_tuple_long, long_>({1, 5, 7, std::make_tuple(4, 6), 10}))) == (3));\n    assert(candidate((std::vector<Union_long_std_tuple_long, long_>({2, 9, std::make_tuple(5, 7), 11}))) == (2));\n    assert(candidate((std::vector<Union_long_std_tuple_long, long_>({11, 15, 5, 8, std::make_tuple(2, 3), 8}))) == (4));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_278_count_first_elements","gpt_solution":"```cpp\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <unordered_map>\n#include <cassert>\n\n\/\/ Define the union\nunion Union_long_std_tuple_long_long_ {\n    long f0;\n    std::tuple<long, long> f1;\n    \n    Union_long_std_tuple_long_long_(long _f0) : f0(_f0) {}\n    Union_long_std_tuple_long_long_(std::tuple<long, long> _f1) : f1(_f1) {}\n    \n    ~Union_long_std_tuple_long_long_() {}\n    \n    bool operator==(long f) const {\n        return f0 == f;\n    }\n    \n    bool operator==(const std::tuple<long, long>& f) const {\n        return f1 == f;\n    }\n};\n\n\/\/ Write a function to find the number of elements that occurs before the vector element in the given tuple.\nlong count_first_elements(const std::vector<Union_long_std_tuple_long_long_>& test_tup) {\n    std::unordered_map<long, int> freq_map;\n    \n    \/\/ Count the occurrences of long elements in the union\n    for (const auto& elem : test_tup) {\n        if (!std::is_standard_layout<Union_long_std_tuple_long_long_>::value) {\n            \/\/ This union does not have 'std::habitual' or similar which checks active member\n            \/\/ Hence assuming the field to be f0 type long is active here for simplification\n            freq_map[elem.f0]++;\n        }\n    }\n    \n    long count = 0;\n    \/\/ Count the elements that appear before the elements from tuple\n    for (const auto& elem : test_tup) {\n        if (!std::is_standard_layout<Union_long_std_tuple_long_long_>::value) {\n            long first_element = std::get<0>(elem.f1);\n            count += freq_map[first_element];\n        }\n    }\n    \n    return count;\n}\n```"}
{"name":"mbpp_279_is_num_decagonal","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the nth decagonal number.\nlong is_num_decagonal(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_279_is_num_decagonal.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = is_num_decagonal;\n    assert(candidate((3)) == (27));\n    assert(candidate((7)) == (175));\n    assert(candidate((10)) == (370));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_279_is_num_decagonal","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to find the nth decagonal number.\nlong is_num_decagonal(long n) {\n    \/\/ The formula for the nth decagonal number is: n * (4*n - 3)\n    return n * (4 * n - 3);\n}\n```"}
{"name":"mbpp_280_sequential_search","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that takes in a vector and element and returns a tuple containing a boolean that indicates if the element is in the vector and the index position of the element (or -1 if the element is not found).\nstd::tuple<bool, long> sequential_search(std::vector<long> dlist, long item) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_280_sequential_search.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sequential_search;\n    assert(candidate((std::vector<long>({(long)11, (long)23, (long)58, (long)31, (long)56, (long)77, (long)43, (long)12, (long)65, (long)19})), (31)) == (std::make_tuple(true, 3)));\n    assert(candidate((std::vector<long>({(long)12, (long)32, (long)45, (long)62, (long)35, (long)47, (long)44, (long)61})), (61)) == (std::make_tuple(true, 7)));\n    assert(candidate((std::vector<long>({(long)9, (long)10, (long)17, (long)19, (long)22, (long)39, (long)48, (long)56})), (48)) == (std::make_tuple(true, 6)));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_280_sequential_search","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function that takes in a vector and element and returns a tuple containing a boolean that indicates if the element is in the vector and the index position of the element (or -1 if the element is not found).\nstd::tuple<bool, long> sequential_search(std::vector<long> dlist, long item) {\n    for (size_t i = 0; i < dlist.size(); ++i) {\n        if (dlist[i] == item) {\n            return std::make_tuple(true, i);\n        }\n    }\n    return std::make_tuple(false, -1);\n}\n```"}
{"name":"mbpp_281_all_unique","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to check if the elements of a given vector are unique or not.\nbool all_unique(std::vector<long> test_list) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_281_all_unique.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = all_unique;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_281_all_unique","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\nbool all_unique(std::vector<long> test_list) {\n    std::unordered_set<long> element_set;\n    for (const auto &element : test_list) {\n        \/\/ If the element is already in the set, elements are not unique\n        if (element_set.find(element) != element_set.end()) {\n            return false;\n        }\n        element_set.insert(element);\n    }\n    \/\/ If we go through the whole list without finding duplicates, elements are unique\n    return true;\n}\n```"}
{"name":"mbpp_282_sub_list","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to subtract two vectors element-wise.\nstd::vector<long> sub_list(std::vector<long> nums1, std::vector<long> nums2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_282_sub_list.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sub_list;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (std::vector<long>({(long)4, (long)5, (long)6}))) == (std::vector<long>({(long)-3, (long)-3, (long)-3})));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (std::vector<long>({(long)3, (long)4}))) == (std::vector<long>({(long)-2, (long)-2})));\n    assert(candidate((std::vector<long>({(long)90, (long)120})), (std::vector<long>({(long)50, (long)70}))) == (std::vector<long>({(long)40, (long)50})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_282_sub_list","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to subtract two vectors element-wise.\nstd::vector<long> sub_list(std::vector<long> nums1, std::vector<long> nums2) {\n    assert(nums1.size() == nums2.size());  \/\/ Ensure both vectors are of the same size\n    std::vector<long> result;\n    for (size_t i = 0; i < nums1.size(); ++i) {\n        result.push_back(nums1[i] - nums2[i]);\n    }\n    return result;\n}\n```"}
{"name":"mbpp_283_validate","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself.\nbool validate(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_283_validate.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = validate;\n    assert(candidate((1234)) == (true));\n    assert(candidate((51241)) == (false));\n    assert(candidate((321)) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_283_validate","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cpp function that takes in an integer and checks whether the frequency of each digit in the integer is less than or equal to the digit itself.\nbool validate(long n) {\n    std::string num = std::to_string(n);\n    std::unordered_map<char, int> freq;\n\n    \/\/ Count the frequency of each digit\n    for(char digit : num) {\n        freq[digit]++;\n    }\n\n    \/\/ Validate the condition for each digit\n    for(auto entry : freq) {\n        int digit = entry.first - '0';\n        int count = entry.second;\n\n        if(count > digit) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"name":"mbpp_284_check_element","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that takes in a vector and element and checks whether all items in the vector are equal to the given element.\nbool check_element(std::vector<std::any> list, std::any element) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_284_check_element.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = check_element;\n    assert(candidate((std::vector<std::any>({(std::string)\"green\", (std::string)\"orange\", (std::string)\"black\", (std::string)\"white\"})), (std::any(\"blue\"))) == (false));\n    assert(candidate((std::vector<std::any>({(long)1, (long)2, (long)3, (long)4})), (std::any(7))) == (false));\n    assert(candidate((std::vector<std::any>({(std::string)\"green\", (std::string)\"green\", (std::string)\"green\", (std::string)\"green\"})), (std::any(\"green\"))) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_284_check_element","gpt_solution":"```cpp\n#include <cassert>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function that takes in a vector and element and checks whether all items in the vector are equal to the given element.\nbool check_element(std::vector<std::any> list, std::any element) {\n    for (const auto& item : list) {\n        if (item.type() != element.type() || std::any_cast<int>(item) != std::any_cast<int>(element)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\/\/ Example usage:\n\/\/ assert(check_element({std::any(2), std::any(2), std::any(2)}, std::any(2)) == true);\n\/\/ assert(check_element({std::any(2), std::any(2), std::any(3)}, std::any(2)) == false);\n```\n\nThis function takes a vector of `std::any` and an element of type `std::any`. It iterates over the vector and compares each item to the given element, returning `false` if any item is not equal to the element. If all items are equal, it returns `true`.\n\nNote: Make sure to handle all required types appropriately in practical applications. The provided example assumes all elements and the comparison element are integers (`int`). Adjust the type casting based on the required element type."}
{"name":"mbpp_285_text_match_two_three","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.\nbool text_match_two_three(std::string text) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_285_text_match_two_three.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = text_match_two_three;\n    assert(candidate((\"ac\")) == (false));\n    assert(candidate((\"dc\")) == (false));\n    assert(candidate((\"abbbba\")) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_285_text_match_two_three","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.\nbool text_match_two_three(std::string text) {\n    std::regex pattern(\"a(b{2,3})\");\n    return std::regex_search(text, pattern);\n}\n```"}
{"name":"mbpp_286_max_sub_array_sum_repeated","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the largest sum of a contiguous vector in the modified vector which is formed by repeating the given vector k times.\nlong max_sub_array_sum_repeated(std::vector<long> a, long n, long k) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_286_max_sub_array_sum_repeated.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = max_sub_array_sum_repeated;\n    assert(candidate((std::vector<long>({(long)10, (long)20, (long)-30, (long)-1})), (4), (3)) == (30));\n    assert(candidate((std::vector<long>({(long)-1, (long)10, (long)20})), (3), (2)) == (59));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3})), (3), (3)) == (-1));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_286_max_sub_array_sum_repeated","gpt_solution":"```cpp\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n\nlong max_sub_array_sum_repeated(std::vector<long> a, long n, long k) {\n    long max_sum_kadane(std::vector<long>&, long);\n\n    if (k == 1) {\n        return max_sum_kadane(a, n);\n    }\n\n    \/\/ Find sum of elements in the vector\n    long array_sum = std::accumulate(a.begin(), a.end(), 0L);\n\n    \/\/ Calculate the combined arrays' maximum subarray sum using Kadane\u2019s algorithm for two arrays\n    long max_prefix_suffix_sum = max_sum_kadane(a, 2 * n);\n    \n    \/\/ If the total sum of the array is positive, the maximum subarray sum\n    \/\/ can include parts of more than one repeat of the array\n    if (array_sum > 0) {\n        return max_prefix_suffix_sum + (k - 2) * array_sum;\n    } else {\n        \/\/ If the total sum is non-positive, the maximum subarray sum could either be in one array\n        \/\/ or within the combined two arrays\n        return max_sum_kadane(a, n);\n    }\n}\n\n\/\/ Helper function to perform Kadane's algorithm\nlong max_sum_kadane(std::vector<long> &array, long size) {\n    long max_sum = LONG_MIN;\n    long current_sum = 0;\n\n    for (long i = 0; i < size; i++) {\n        long element = array[i % array.size()];\n        current_sum += element;\n\n        if (max_sum < current_sum) {\n            max_sum = current_sum;\n        }\n        if (current_sum < 0) {\n            current_sum = 0;\n        }\n    }\n    return max_sum;\n}\n```\n\nThis code defines a function `max_sub_array_sum_repeated` which calculates the maximum subarray sum for an array that is repeated `k` times. For the implementation of Kadane\u2019s algorithm, I've added an auxiliary function `max_sum_kadane`. The overall maximum subarray sum is determined based on whether the sum of the array elements is positive or not, enabling the handling of cases where the array is repeated multiple times efficiently."}
{"name":"mbpp_287_square_Sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function takes in an integer n and returns the sum of squares of first n even natural numbers.\nlong square_Sum(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_287_square_Sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = square_Sum;\n    assert(candidate((2)) == (20));\n    assert(candidate((3)) == (56));\n    assert(candidate((4)) == (120));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_287_square_Sum","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Write a function that takes in an integer n and returns the sum of squares of first n even natural numbers.\nlong square_Sum(long n) {\n    long sum = 0;\n    for (long i = 1; i <= n; ++i) {\n        \/\/ Calculate the i-th even natural number: 2 * i\n        long even_num = 2 * i;\n        \/\/ Add the square of the even number to the sum\n        sum += even_num * even_num;\n    }\n    return sum;\n}\n\n\/\/ Example usage\n\/*\nint main() {\n    long n = 5;\n    cout << \"Sum of squares of first \" << n << \" even natural numbers is: \" << square_Sum(n) << endl;\n    return 0;\n}\n*\/\n```\n\nThis code defines the function `square_Sum` which calculates and returns the sum of squares of the first `n` even natural numbers. The loop iterates `n` times and for each iteration, it computes the even natural number and adds its square to the sum. The `main` function is commented out to adhere to your requirement of not including it in the code."}
{"name":"mbpp_290_max_length","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the vector of maximum length in a vector of vectors.\nstd::tuple<long, std::vector<long>> max_length(std::vector<std::vector<long>> list1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_290_max_length.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = max_length;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)5, (long)7}), (std::vector<long>)std::vector<long>({(long)9, (long)11}), (std::vector<long>)std::vector<long>({(long)13, (long)15, (long)17})}))) == (std::make_tuple(3, std::vector<long>({(long)13, (long)15, (long)17}))));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)5, (long)7}), (std::vector<long>)std::vector<long>({(long)10, (long)12, (long)14, (long)15})}))) == (std::make_tuple(4, std::vector<long>({(long)10, (long)12, (long)14, (long)15}))));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5}), (std::vector<long>)std::vector<long>({(long)15, (long)20, (long)25})}))) == (std::make_tuple(3, std::vector<long>({(long)15, (long)20, (long)25}))));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_290_max_length","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the vector of maximum length in a vector of vectors.\nstd::tuple<long, std::vector<long>> max_length(std::vector<std::vector<long>> list1) {\n    if (list1.empty()) {\n        return std::make_tuple(0L, std::vector<long>{});\n    }\n    \n    long max_len = 0;\n    std::vector<long> max_vec;\n\n    for (const auto& vec : list1) {\n        if (vec.size() > max_len) {\n            max_len = vec.size();\n            max_vec = vec;\n        }\n    }\n\n    return std::make_tuple(max_len, max_vec);\n}\n\n\/\/ Example usage and testing (this would normally be in your main function or testing framework):\nvoid test_max_length() {\n    std::vector<std::vector<long>> list1 = {\n        {1, 2, 3},\n        {4, 5, 6, 7},\n        {8, 9},\n        {10, 11, 12, 13, 14}\n    };\n    auto result = max_length(list1);\n    assert(std::get<0>(result) == 5);\n    assert(std::get<1>(result) == std::vector<long>({10, 11, 12, 13, 14}));\n\n    list1 = {};\n    result = max_length(list1);\n    assert(std::get<0>(result) == 0);\n    assert(std::get<1>(result).empty());\n\n    list1 = {{1}};\n    result = max_length(list1);\n    assert(std::get<0>(result) == 1);\n    assert(std::get<1>(result) == std::vector<long>({1}));\n}\n\n\/\/ Running a simple test\ntest_max_length();\n```"}
{"name":"mbpp_291_count_no_of_ways","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.\nlong count_no_of_ways(long n, long k) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_291_count_no_of_ways.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = count_no_of_ways;\n    assert(candidate((2), (4)) == (16));\n    assert(candidate((3), (2)) == (6));\n    assert(candidate((4), (4)) == (228));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_291_count_no_of_ways","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Write a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.\nlong count_no_of_ways(long n, long k) {\n    if (n == 1) {\n        return k;\n    }\n    if (n == 2) {\n        return k * k;\n    }\n    \n    long same = k;\n    long diff = k * (k - 1);\n    long total = same + diff;\n    \n    for (long i = 3; i <= n; ++i) {\n        same = diff;\n        diff = total * (k - 1);\n        total = same + diff;\n    }\n    \n    return total;\n}\n\n```"}
{"name":"mbpp_292_find","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find quotient of two numbers (rounded down to the nearest integer).\nlong find(long n, long m) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_292_find.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find;\n    assert(candidate((10), (3)) == (3));\n    assert(candidate((4), (2)) == (2));\n    assert(candidate((20), (5)) == (4));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_292_find","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cpp function to find quotient of two numbers (rounded down to the nearest integer).\nlong find(long n, long m) {\n    assert(m != 0); \/\/ Ensure that we are not dividing by zero\n    return n \/ m; \/\/ Using integer division which automatically rounds down\n}\n```\n\nThis function takes two long integers `n` and `m` and returns the quotient of these two numbers rounded down to the nearest integer. The use of integer division (the `\/` operator) in C++ ensures that the result is already rounded down to the nearest integer. Furthermore, the `assert` statement makes sure that `m` is not zero to avoid division by zero errors.\n\n"}
{"name":"mbpp_293_otherside_rightangle","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the third side of a right angled triangle.\nfloat otherside_rightangle(long w, long h) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_293_otherside_rightangle.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = otherside_rightangle;\n    assert(candidate((7), (8)) == (10.63014581273465f));\n    assert(candidate((3), (4)) == (float(5)));\n    assert(candidate((7), (15)) == (16.55294535724685f));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_293_otherside_rightangle","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Write a function to find the third side of a right angled triangle.\nfloat otherside_rightangle(long w, long h) {\n    \/\/ Check if the inputs can form a right-angled triangle\n    if (w <= 0 || h <= 0) {\n        throw invalid_argument(\"Sides of triangle must be positive\");\n    }\n\n    \/\/ Calculate the third side by Pythagorean theorem\n    float third_side = sqrt(w * w + h * h);\n\n    return third_side;\n}\n```\n\nThis function, `otherside_rightangle`, takes two arguments `w` (one side of a right-angled triangle) and `h` (the other side of the right-angled triangle). It calculates and returns the length of the third side (hypotenuse) using the Pythagorean theorem. The function also includes a check to ensure that the sides are positive."}
{"name":"mbpp_294_max_val","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n\/\/ Write a function to find the maximum value in a given heterogeneous vector.\nlong max_val(std::vector<Union_std_string_long> listval) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_294_max_val.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = max_val;\n    assert(candidate((std::vector<Union_std_string_long>({(std::string)\"Python\", (std::string)3, (std::string)2, (std::string)4, (std::string)5, (std::string)\"version\"}))) == (5));\n    assert(candidate((std::vector<Union_std_string_long>({(std::string)\"Python\", (std::string)15, (std::string)20, (std::string)25}))) == (25));\n    assert(candidate((std::vector<Union_std_string_long>({(std::string)\"Python\", (std::string)30, (std::string)20, (std::string)40, (std::string)50, (std::string)\"version\"}))) == (50));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_294_max_val","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\nunion Union_std_string_long {\n    std::string f0;\n    long f1;\n    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f;\n    }\n    bool operator==(long f) {\n        return f1 == f;\n    }\n};\n\nlong max_val(std::vector<Union_std_string_long> listval) {\n    long max_value = LONG_MIN; \/\/ Start with the smallest possible value\n    for (auto& item : listval) {\n        \/\/ Assuming the union holds a `long`, because checking for the type of union is not possible\n        if (item.f1 > max_value) \/\/ We can only safely compare long values\n            max_value = item.f1;\n    }\n    return max_value;\n}\n```\n\nIn the above code, it is assumed that the `Union_std_string_long` vector mainly stores `long` values, since distinguishing between the types currently stored in the union is inherently unsafe directly. It finds and returns the maximum `long` value in the provided vector."}
{"name":"mbpp_295_sum_div","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to return the sum of all divisors of a number.\nlong sum_div(long number) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_295_sum_div.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sum_div;\n    assert(candidate((8)) == (7));\n    assert(candidate((12)) == (16));\n    assert(candidate((7)) == (1));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_295_sum_div","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to return the sum of all divisors of a number.\nlong sum_div(long number) {\n    long sum = 0;\n    for (long i = 1; i <= std::sqrt(number); ++i) {\n        if (number % i == 0) {\n            if (i == number \/ i) {\n                sum += i; \/\/ if both divisors are the same, add it only once\n            } else {\n                sum += i + number \/ i; \/\/ add both divisors\n            }\n        }\n    }\n    return sum;\n}\n```\n\nThis function `sum_div` calculates the sum of all divisors of the given number by iterating up to the square root of the number and adding both the divisor and the quotient when the number is divisible by the iterator."}
{"name":"mbpp_296_get_Inv_Count","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to count inversions in a vector.\nlong get_Inv_Count(std::vector<long> arr) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_296_get_Inv_Count.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = get_Inv_Count;\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)6, (long)4, (long)5}))) == (5));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)5, (long)6, (long)1}))) == (3));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_296_get_Inv_Count","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n#include <assert.h>\n\n\/\/ Function to merge two halves and count inversions\nlong merge_and_count(std::vector<long> &arr, std::vector<long> &temp, long left, long mid, long right)\n{\n    long i = left;    \/\/ Starting index for left subarray\n    long j = mid + 1; \/\/ Starting index for right subarray\n    long k = left;    \/\/ Starting index to be sorted\n    long inv_count = 0;\n\n    \/\/ Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while ((i <= mid) && (j <= right))\n    {\n        if (arr[i] <= arr[j])\n        {\n            temp[k++] = arr[i++];\n        }\n        else\n        {\n            temp[k++] = arr[j++];\n            inv_count = inv_count + (mid - i + 1);\n        }\n    }\n\n    \/\/ Copy the remaining elements of left subarray, if any\n    while (i <= mid)\n        temp[k++] = arr[i++];\n\n    \/\/ Copy the remaining elements of right subarray, if any\n    while (j <= right)\n        temp[k++] = arr[j++];\n\n    \/\/ Copy the sorted subarray into Original array\n    for (i = left; i <= right; i++)\n        arr[i] = temp[i];\n\n    return inv_count;\n}\n\n\/\/ Function to sort the array and return the number of inversions in the array.\nlong merge_sort_and_count(std::vector<long> &arr, std::vector<long> &temp, long left, long right)\n{\n    long mid, inv_count = 0;\n    if (left < right)\n    {\n        mid = (right + left) \/ 2;\n\n        inv_count += merge_sort_and_count(arr, temp, left, mid);\n        inv_count += merge_sort_and_count(arr, temp, mid + 1, right);\n\n        inv_count += merge_and_count(arr, temp, left, mid, right);\n    }\n    return inv_count;\n}\n\n\/\/ Write a cpp function to count inversions in a vector.\nlong get_Inv_Count(std::vector<long> arr) {\n    std::vector<long> temp(arr.size());\n    return merge_sort_and_count(arr, temp, 0, arr.size() - 1);\n}\n```"}
{"name":"mbpp_297_flatten_list","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\nunion Union_long_std_vector_long_{\n    long f0;\n    std::vector<long> f1;    Union_long_std_vector_long_(long _f0) : f0(_f0) {}\n    Union_long_std_vector_long_(std::vector<long> _f1) : f1(_f1) {}\n    ~Union_long_std_vector_long_() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(std::vector<long> f) {\n        return f1 == f ;\n    }\n};\n\/\/ Write a function to flatten a given nested vector structure.\nstd::vector<long> flatten_list(std::vector<Union_long_std_vector_long_> list1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_297_flatten_list.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = flatten_list;\n    assert(candidate((std::vector<Union_long_std_vector_long_>({0, 10, std::vector<long>({(long)20, (long)30}), 40, 50, std::vector<long>({(long)60, (long)70, (long)80}), std::vector<long>({(long)90, (long)100, (long)110, (long)120})}))) == (std::vector<long>({(long)0, (long)10, (long)20, (long)30, (long)40, (long)50, (long)60, (long)70, (long)80, (long)90, (long)100, (long)110, (long)120})));\n    assert(candidate((std::vector<Union_long_std_vector_long_>({(std::vector<long>)std::vector<long>({(long)10, (long)20}), (std::vector<long>)std::vector<long>({(long)40}), (std::vector<long>)std::vector<long>({(long)30, (long)56, (long)25}), (std::vector<long>)std::vector<long>({(long)10, (long)20}), (std::vector<long>)std::vector<long>({(long)33}), (std::vector<long>)std::vector<long>({(long)40})}))) == (std::vector<long>({(long)10, (long)20, (long)40, (long)30, (long)56, (long)25, (long)10, (long)20, (long)33, (long)40})));\n    assert(candidate((std::vector<Union_long_std_vector_long_>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)10, (long)11, (long)12}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)10, (long)11, (long)12, (long)7, (long)8, (long)9})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_297_flatten_list","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\nunion Union_long_std_vector_long_ {\n    long f0;\n    std::vector<long> f1;\n    \n    Union_long_std_vector_long_(long _f0) : f0(_f0) {}\n    Union_long_std_vector_long_(std::vector<long> _f1) : f1(_f1) {}\n    ~Union_long_std_vector_long_() {}\n    \n    bool operator==(long f) {\n        return f0 == f ;\n    }\n    \n    bool operator==(std::vector<long> f) {\n        return f1 == f ;\n    }\n};\n\n\/\/ Write a function to flatten a given nested vector structure.\nstd::vector<long> flatten_list(std::vector<Union_long_std_vector_long_> list1) {\n    std::vector<long> result;\n    std::stack<Union_long_std_vector_long_> stack;\n    \n    \/\/ Push all elements to the stack in reverse order\n    for (auto it = list1.rbegin(); it != list1.rend(); ++it) {\n        stack.push(*it);\n    }\n    \n    while (!stack.empty()) {\n        Union_long_std_vector_long_ current = stack.top();\n        stack.pop();\n        \n        \/\/ If the current element is a long, add it to the result\n        if (current == current.f0) {\n            result.push_back(current.f0);\n        } else {\n            \/\/ If the current element is a vector, push its elements to the stack in reverse order\n            for (auto it = current.f1.rbegin(); it != current.f1.rend(); ++it) {\n                stack.push(Union_long_std_vector_long_(*it));\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"name":"mbpp_299_max_aggregate","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to calculate the maximum aggregate from the vector of tuples.\nstd::tuple<std::string, long> max_aggregate(std::vector<std::tuple<std::string, long>> stdata) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_299_max_aggregate.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = max_aggregate;\n    assert(candidate((std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Juan Whelan\", 90), (std::tuple<std::string, long>)std::make_tuple(\"Sabah Colley\", 88), (std::tuple<std::string, long>)std::make_tuple(\"Peter Nichols\", 7), (std::tuple<std::string, long>)std::make_tuple(\"Juan Whelan\", 122), (std::tuple<std::string, long>)std::make_tuple(\"Sabah Colley\", 84)}))) == (std::make_tuple(\"Juan Whelan\", 212)));\n    assert(candidate((std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Juan Whelan\", 50), (std::tuple<std::string, long>)std::make_tuple(\"Sabah Colley\", 48), (std::tuple<std::string, long>)std::make_tuple(\"Peter Nichols\", 37), (std::tuple<std::string, long>)std::make_tuple(\"Juan Whelan\", 22), (std::tuple<std::string, long>)std::make_tuple(\"Sabah Colley\", 14)}))) == (std::make_tuple(\"Juan Whelan\", 72)));\n    assert(candidate((std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Juan Whelan\", 10), (std::tuple<std::string, long>)std::make_tuple(\"Sabah Colley\", 20), (std::tuple<std::string, long>)std::make_tuple(\"Peter Nichols\", 30), (std::tuple<std::string, long>)std::make_tuple(\"Juan Whelan\", 40), (std::tuple<std::string, long>)std::make_tuple(\"Sabah Colley\", 50)}))) == (std::make_tuple(\"Sabah Colley\", 70)));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_299_max_aggregate","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to calculate the maximum aggregate from the vector of tuples.\nstd::tuple<std::string, long> max_aggregate(std::vector<std::tuple<std::string, long>> stdata) {\n    \/\/ Create a map to store the aggregate values for each key\n    std::map<std::string, long> aggregates;\n\n    \/\/ Iterate over each tuple in the input vector\n    for (const auto& entry : stdata) {\n        \/\/ Extract the key and value from the tuple\n        std::string key;\n        long value;\n        std::tie(key, value) = entry;\n\n        \/\/ Accumulate the value in the map for the corresponding key\n        aggregates[key] += value;\n    }\n\n    \/\/ Find the key with the maximum aggregate value\n    std::string max_key;\n    long max_value = LONG_MIN;\n    for (const auto& aggregate : aggregates) {\n        if (aggregate.second > max_value) {\n            max_value = aggregate.second;\n            max_key = aggregate.first;\n        }\n    }\n\n    \/\/ Return the key and its aggregate value as a tuple\n    return std::make_tuple(max_key, max_value);\n}\n```"}
{"name":"mbpp_304_find_Element","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find element at a given index after number of rotations.\nlong find_Element(std::vector<long> arr, std::vector<std::vector<long>> ranges, long rotations, long index) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_304_find_Element.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_Element;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})), (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)2}), (std::vector<long>)std::vector<long>({(long)0, (long)3})})), (2), (1)) == (3));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)2})})), (1), (2)) == (3));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)2})})), (1), (1)) == (1));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_304_find_Element","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to find element at a given index after number of rotations.\nlong find_Element(vector<long> arr, vector<vector<long>> ranges, long rotations, long index) {\n    long n = arr.size();\n    long num_ranges = ranges.size();\n\n    \/\/ Effective rotations might be more than the number of ranges\n    rotations = rotations % num_ranges;\n\n    \/\/ We will track the net shift in index due to rotations\n    long net_shift = 0;\n\n    \/\/ Calculate the net shift from the given ranges\n    for (int i = 0; i < rotations; i++) {\n        int start = ranges[i][0];\n        int end = ranges[i][1];\n\n        \/\/ Update net_shift according to the range\n        net_shift += (end - start + 1);\n    }\n\n    \/\/ Adjust the index according to the net_shift calculated\n    index = (index + net_shift) % n;\n\n    \/\/ Retrieve and return the element at the modified index\n    return arr[index];\n}\n\nint main() {\n    vector<long> arr = {1, 2, 3, 4, 5};\n    vector<vector<long>> ranges = {{0, 2}, {1, 3}, {2, 4}};\n    \n    assert(find_Element(arr, ranges, 1, 0) == 2);\n    assert(find_Element(arr, ranges, 2, 0) == 4);\n    assert(find_Element(arr, ranges, 3, 0) == 1);\n    \n    return 0;\n}\n```\n\nIn this code snippet, `find_Element` computes the element at a given `index` after a series of rotations described by the `ranges`. The effective number of rotations is obtained through modulo operation to avoid redundant full cycles. Finally, the function adjusts the index according to the derived net shift and returns the desired element."}
{"name":"mbpp_305_start_withp","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to return two words from a vector of words starting with letter 'p'.\nstd::tuple<std::string, std::string> start_withp(std::vector<std::string> words) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_305_start_withp.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = start_withp;\n    assert(candidate((std::vector<std::string>({(std::string)\"Python PHP\", (std::string)\"Java JavaScript\", (std::string)\"c c++\"}))) == (std::make_tuple(\"Python\", \"PHP\")));\n    assert(candidate((std::vector<std::string>({(std::string)\"Python Programming\", (std::string)\"Java Programming\"}))) == (std::make_tuple(\"Python\", \"Programming\")));\n    assert(candidate((std::vector<std::string>({(std::string)\"Pqrst Pqr\", (std::string)\"qrstuv\"}))) == (std::make_tuple(\"Pqrst\", \"Pqr\")));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_305_start_withp","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to return two words from a vector of words starting with letter 'p'.\nstd::tuple<std::string, std::string> start_withp(std::vector<std::string> words) {\n    std::string word1, word2;\n    int count = 0;\n\n    for (const auto& word : words) {\n        if (word[0] == 'p' || word[0] == 'P') {\n            if (count == 0) {\n                word1 = word;\n            } else if (count == 1) {\n                word2 = word;\n                break;\n            }\n            count++;\n        }\n    }\n\n    if (count < 2) {\n        throw std::runtime_error(\"Less than 2 words starting with 'p' found\");\n    }\n\n    return std::make_tuple(word1, word2);\n}\n```"}
{"name":"mbpp_306_max_sum_increasing_subseq","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .\nlong max_sum_increasing_subseq(std::vector<long> a, long n, long index, long k) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_306_max_sum_increasing_subseq.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = max_sum_increasing_subseq;\n    assert(candidate((std::vector<long>({(long)1, (long)101, (long)2, (long)3, (long)100, (long)4, (long)5})), (7), (4), (6)) == (11));\n    assert(candidate((std::vector<long>({(long)1, (long)101, (long)2, (long)3, (long)100, (long)4, (long)5})), (7), (2), (5)) == (7));\n    assert(candidate((std::vector<long>({(long)11, (long)15, (long)19, (long)21, (long)26, (long)28, (long)31})), (7), (2), (4)) == (71));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_306_max_sum_increasing_subseq","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the maximum sum of increasing subsequence from prefix \n\/\/ until ith index and also including a given kth element which is after i, i.e., k > i.\nlong max_sum_increasing_subseq(std::vector<long> a, long n, long index, long k) {\n    \/\/ dp array to store maximum sum of increasing subsequence ending at each index\n    std::vector<long> dp(n, 0);\n\n    \/\/ Initialize dp array with the values of array a\n    for (long i = 0; i <= index; ++i) {\n        dp[i] = a[i];\n    }\n\n    \/\/ Calculate maximum sum of increasing subsequence ending at each index up to 'index'\n    for (long i = 1; i <= index; ++i) {\n        for (long j = 0; j < i; ++j) {\n            if (a[i] > a[j] && dp[i] < dp[j] + a[i]) {\n                dp[i] = dp[j] + a[i];\n            }\n        }\n    }\n\n    \/\/ Find the maximum sum of increasing subsequence ending at each position up to 'index'\n    long max_sum_up_to_index = *max_element(dp.begin(), dp.begin() + index + 1);\n\n    \/\/ To include the a[k] element, we need to find the longest increasing subsequence sum \n    \/\/ from beginning up to index and checking with a[k].\n    long max_sum = 0;\n    for (long i = 0; i <= index; ++i) {\n        if (a[k] > a[i]) {\n            max_sum = std::max(max_sum, dp[i] + a[k]);\n        }\n    }\n\n    return max_sum;\n}\n```"}
{"name":"mbpp_308_large_product","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_308_large_product.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_308_large_product","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    \/\/ Create a max-heap to store the products along with their indices\n    std::priority_queue<std::tuple<long, int, int>> max_heap;\n    \n    \/\/ Sort both vectors in descending order\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    \n    \/\/ Add the pair of the first elements in both vectors to the heap\n    max_heap.push({ nums1[0] * nums2[0], 0, 0 });\n    \n    \/\/ Set to keep track of the visited indices pairs to avoid repetition\n    std::set<std::pair<int, int>> visited;\n    visited.insert({ 0, 0 });\n    \n    \/\/ Vector to store the N largest products\n    std::vector<long> result;\n    \n    \/\/ Extract N largest products\n    while (N-- > 0 && !max_heap.empty()) {\n        auto [product, i, j] = max_heap.top();\n        max_heap.pop();\n        result.push_back(product);\n        \n        \/\/ Add the next pair from nums1 and nums2 if not visited\n        if (i + 1 < nums1.size() && visited.count({ i + 1, j }) == 0) {\n            visited.insert({ i + 1, j });\n            max_heap.push({ nums1[i + 1] * nums2[j], i + 1, j });\n        }\n        \n        if (j + 1 < nums2.size() && visited.count({ i, j + 1 }) == 0) {\n            visited.insert({ i, j + 1 });\n            max_heap.push({ nums1[i] * nums2[j + 1], i, j + 1 });\n        }\n    }\n    \n    return result;\n}\n```"}
{"name":"mbpp_309_maximum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the maximum of two numbers.\nlong maximum(long a, long b) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_309_maximum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = maximum;\n    assert(candidate((5), (10)) == (10));\n    assert(candidate((-1), (-2)) == (-1));\n    assert(candidate((9), (7)) == (9));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_309_maximum","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to find the maximum of two numbers.\nlong maximum(long a, long b) {\n    return (a > b) ? a : b;\n}\n```\n\nThe above code defines a function `maximum` that takes two `long` integers as input and returns the larger one using a ternary operator. This function doesn't contain a `main` function as per your request."}
{"name":"mbpp_310_string_to_tuple","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to convert a given string to a vector of characters.\nstd::vector<std::string> string_to_tuple(std::string str1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_310_string_to_tuple.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = string_to_tuple;\n    assert(candidate((\"python 3.0\")) == (std::vector<std::string>({(std::string)\"p\", (std::string)\"y\", (std::string)\"t\", (std::string)\"h\", (std::string)\"o\", (std::string)\"n\", (std::string)\"3\", (std::string)\".\", (std::string)\"0\"})));\n    assert(candidate((\"item1\")) == (std::vector<std::string>({(std::string)\"i\", (std::string)\"t\", (std::string)\"e\", (std::string)\"m\", (std::string)\"1\"})));\n    assert(candidate((\"15.10\")) == (std::vector<std::string>({(std::string)\"1\", (std::string)\"5\", (std::string)\".\", (std::string)\"1\", (std::string)\"0\"})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_310_string_to_tuple","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to convert a given string to a vector of characters.\nstd::vector<char> string_to_vector(std::string str1) {\n    std::vector<char> char_vector;\n    for(char c : str1) {\n        char_vector.push_back(c);\n    }\n    return char_vector;\n}\n```"}
{"name":"mbpp_388_highest_Power_of_2","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the highest power of 2 that is less than or equal to n.\nlong highest_Power_of_2(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_388_highest_Power_of_2.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = highest_Power_of_2;\n    assert(candidate((10)) == (8));\n    assert(candidate((19)) == (16));\n    assert(candidate((32)) == (32));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_388_highest_Power_of_2","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Function to find the highest power of 2 that is less than or equal to n\nlong highest_Power_of_2(long n) {\n    if (n < 1) {\n        return 0;\n    }\n\n    \/\/ Initialize result as 1\n    long res = 1;\n\n    \/\/ Update `res` to the highest power of 2 less than or equal to `n`\n    while (res <= n \/ 2) {\n        res *= 2;\n    }\n\n    return res;\n}\n```"}
{"name":"mbpp_389_find_lucas","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the n'th lucas number.\nlong find_lucas(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_389_find_lucas.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_lucas;\n    assert(candidate((9)) == (76));\n    assert(candidate((4)) == (7));\n    assert(candidate((3)) == (4));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_389_find_lucas","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the n'th lucas number.\nlong find_lucas(long n) {\n    \/\/ Lucas numbers are similar to Fibonacci numbers, but they start with 2 and 1.\n    if (n == 0) return 2;\n    if (n == 1) return 1;\n    long a = 2, b = 1, c;\n    for (long i = 2; i <= n; ++i) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n```\n\nIn this code:\n- We provide the function `find_lucas` that calculates the nth Lucas number using an iterative approach.\n- The base cases for `n == 0` and `n == 1` return 2 and 1, respectively.\n- We use a loop to generate Lucas numbers up to the nth number by summing the previous two numbers and updating the variables accordingly."}
{"name":"mbpp_390_add_string","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to apply a given format string to all of the elements in a vector.\nstd::vector<std::string> add_string(std::vector<std::any> list_, std::string string) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_390_add_string.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = add_string;\n    assert(candidate((std::vector<std::any>({(long)1, (long)2, (long)3, (long)4})), (\"temp{0}\")) == (std::vector<std::string>({(std::string)\"temp1\", (std::string)\"temp2\", (std::string)\"temp3\", (std::string)\"temp4\"})));\n    assert(candidate((std::vector<std::any>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\", (std::string)\"d\"})), (\"python{0}\")) == (std::vector<std::string>({(std::string)\"pythona\", (std::string)\"pythonb\", (std::string)\"pythonc\", (std::string)\"pythond\"})));\n    assert(candidate((std::vector<std::any>({(long)5, (long)6, (long)7, (long)8})), (\"string{0}\")) == (std::vector<std::string>({(std::string)\"string5\", (std::string)\"string6\", (std::string)\"string7\", (std::string)\"string8\"})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_390_add_string","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to apply a given format string to all of the elements in a vector.\nstd::vector<std::string> add_string(std::vector<std::any> list_, std::string format) {\n    std::vector<std::string> formatted_list;\n\n    for(const auto& item : list_) {\n        if(item.type() == typeid(int)) {\n            formatted_list.push_back(format + std::to_string(std::any_cast<int>(item)));\n        } else if(item.type() == typeid(double)) {\n            formatted_list.push_back(format + std::to_string(std::any_cast<double>(item)));\n        } else if(item.type() == typeid(std::string)) {\n            formatted_list.push_back(format + std::any_cast<std::string>(item));\n        } else {\n            throw std::invalid_argument(\"Unsupported type in the vector\");\n        }\n    }\n\n    return formatted_list;\n}\n```"}
{"name":"mbpp_391_convert_list_dictionary","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to convert more than one vector to nested map.\nstd::vector<std::map<std::string,std::map<std::string,long>>> convert_list_dictionary(std::vector<std::string> l1, std::vector<std::string> l2, std::vector<long> l3) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_391_convert_list_dictionary.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = convert_list_dictionary;\n    assert(candidate((std::vector<std::string>({(std::string)\"S001\", (std::string)\"S002\", (std::string)\"S003\", (std::string)\"S004\"})), (std::vector<std::string>({(std::string)\"Adina Park\", (std::string)\"Leyton Marsh\", (std::string)\"Duncan Boyle\", (std::string)\"Saim Richards\"})), (std::vector<long>({(long)85, (long)98, (long)89, (long)92}))) == (std::vector<std::map<std::string,std::map<std::string,long>>>({(std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"S001\", std::map<std::string,long>({{\"Adina Park\", 85}})}}), (std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"S002\", std::map<std::string,long>({{\"Leyton Marsh\", 98}})}}), (std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"S003\", std::map<std::string,long>({{\"Duncan Boyle\", 89}})}}), (std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"S004\", std::map<std::string,long>({{\"Saim Richards\", 92}})}})})));\n    assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"def\", (std::string)\"ghi\", (std::string)\"jkl\"})), (std::vector<std::string>({(std::string)\"python\", (std::string)\"program\", (std::string)\"language\", (std::string)\"programs\"})), (std::vector<long>({(long)100, (long)200, (long)300, (long)400}))) == (std::vector<std::map<std::string,std::map<std::string,long>>>({(std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"abc\", std::map<std::string,long>({{\"python\", 100}})}}), (std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"def\", std::map<std::string,long>({{\"program\", 200}})}}), (std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"ghi\", std::map<std::string,long>({{\"language\", 300}})}}), (std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"jkl\", std::map<std::string,long>({{\"programs\", 400}})}})})));\n    assert(candidate((std::vector<std::string>({(std::string)\"A1\", (std::string)\"A2\", (std::string)\"A3\", (std::string)\"A4\"})), (std::vector<std::string>({(std::string)\"java\", (std::string)\"C\", (std::string)\"C++\", (std::string)\"DBMS\"})), (std::vector<long>({(long)10, (long)20, (long)30, (long)40}))) == (std::vector<std::map<std::string,std::map<std::string,long>>>({(std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"A1\", std::map<std::string,long>({{\"java\", 10}})}}), (std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"A2\", std::map<std::string,long>({{\"C\", 20}})}}), (std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"A3\", std::map<std::string,long>({{\"C++\", 30}})}}), (std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"A4\", std::map<std::string,long>({{\"DBMS\", 40}})}})})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_391_convert_list_dictionary","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to convert more than one vector to nested map.\nstd::vector<std::map<std::string, std::map<std::string, long>>> convert_list_dictionary(\n    std::vector<std::string> l1, \n    std::vector<std::string> l2, \n    std::vector<long> l3) \n{\n    \/\/ Check if the size of the lists are the same.\n    assert(l1.size() == l2.size() && l2.size() == l3.size());\n    \n    std::vector<std::map<std::string, std::map<std::string, long>>> result;\n    std::map<std::string, std::map<std::string, long>> temp_map;\n\n    for (size_t i = 0; i < l1.size(); ++i) {\n        temp_map[l1[i]][l2[i]] = l3[i];\n    }\n\n    result.push_back(temp_map);\n    return result;\n}\n```"}
{"name":"mbpp_392_get_max_sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the maximum sum possible by using the given equation f(n) = max( (f(n\/2) + f(n\/3) + f(n\/4) + f(n\/5)), n).\nlong get_max_sum(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_392_get_max_sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = get_max_sum;\n    assert(candidate((60)) == (106));\n    assert(candidate((10)) == (12));\n    assert(candidate((2)) == (2));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_392_get_max_sum","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Create a map to use for memoization\nstd::unordered_map<long, long> memo;\n\n\/\/ Function to find the maximum sum possible by using the given equation f(n)\nlong get_max_sum(long n) {\n    \/\/ Base case: if n is 0\n    if (n == 0) {\n        return 0;\n    }\n\n    \/\/ Check if the result for this value of n is already in the map\n    if (memo.find(n) != memo.end()) {\n        return memo[n];\n    }\n\n    \/\/ Calculate the four parts\n    long part1 = get_max_sum(n \/ 2);\n    long part2 = get_max_sum(n \/ 3);\n    long part3 = get_max_sum(n \/ 4);\n    long part4 = get_max_sum(n \/ 5);\n\n    \/\/ Use the provided formula\n    long max_value = std::max(n, part1 + part2 + part3 + part4);\n\n    \/\/ Store the result in the map for future use\n    memo[n] = max_value;\n\n    \/\/ Return the result\n    return max_value;\n}\n```"}
{"name":"mbpp_393_max_length_list","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the vector with maximum length.\nstd::tuple<long, std::vector<long>> max_length_list(std::vector<std::vector<long>> input_list) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_393_max_length_list.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = max_length_list;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)5, (long)7}), (std::vector<long>)std::vector<long>({(long)9, (long)11}), (std::vector<long>)std::vector<long>({(long)13, (long)15, (long)17})}))) == (std::make_tuple(3, std::vector<long>({(long)13, (long)15, (long)17}))));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1})}))) == (std::make_tuple(5, std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)3, (long)4, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)7, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)10, (long)11, (long)12})}))) == (std::make_tuple(4, std::vector<long>({(long)6, (long)7, (long)8, (long)9}))));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_393_max_length_list","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the vector with maximum length.\nstd::tuple<long, std::vector<long>> max_length_list(std::vector<std::vector<long>> input_list) {\n    \/\/ Initialize to store the maximum length and the corresponding vector\n    long max_length = 0;\n    std::vector<long> max_vector;\n\n    \/\/ Loop through each vector in the input list\n    for (const auto& vec : input_list) {\n        \/\/ Get the length of current vector\n        long length = vec.size();\n\n        \/\/ Update max_length and max_vector if the current vector is longer\n        if (length > max_length) {\n            max_length = length;\n            max_vector = vec;\n        }\n    }\n\n    \/\/ Return the maximum length and the corresponding vector as a tuple\n    return std::make_tuple(max_length, max_vector);\n}\n```"}
{"name":"mbpp_394_check_distinct","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check if given vector contains no duplicates.\nbool check_distinct(std::vector<long> test_tup) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_394_check_distinct.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = check_distinct;\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)5, (long)6, (long)1, (long)4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)5, (long)6}))) == (true));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)4, (long)5, (long)6}))) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_394_check_distinct","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to check if given vector contains no duplicates.\nbool check_distinct(std::vector<long> test_tup) {\n    std::unordered_set<long> unique_elements;\n    for(const long& element : test_tup) {\n        if(unique_elements.find(element) != unique_elements.end()) {\n            return false; \/\/ Duplicate found\n        }\n        unique_elements.insert(element);\n    }\n    return true; \/\/ No duplicates found\n}\n```\n\nIn this code, we use an `unordered_set` to keep track of unique elements in the vector. If we encounter an element that is already in the set, we know that the vector contains duplicates, and we return `false`. If we go through all elements without finding duplicates, we return `true`."}
{"name":"mbpp_395_first_non_repeating_character","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the first non-repeated character in a given string.\nstd::optional<std::string> first_non_repeating_character(std::string str1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_395_first_non_repeating_character.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = first_non_repeating_character;\n    assert(candidate((\"abcabc\")) == std::nullopt);\n    assert(candidate((\"abc\")) == \"a\");\n    assert(candidate((\"ababc\")) == \"c\");\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_395_first_non_repeating_character","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n#include <optional>\n\nstd::optional<char> first_non_repeating_character(const std::string& str) {\n    std::unordered_map<char, int> char_count;\n    \n    \/\/ Count the occurrences of each character\n    for (char ch : str) {\n        char_count[ch]++;\n    }\n    \n    \/\/ Find the first character that appears only once\n    for (char ch : str) {\n        if (char_count[ch] == 1) {\n            return ch;\n        }\n    }\n    \n    \/\/ If no non-repeating character is found, return an empty optional\n    return std::nullopt;\n}\n```"}
{"name":"mbpp_396_check_char","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check whether the given string starts and ends with the same character or not.\nstd::string check_char(std::string string) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_396_check_char.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = check_char;\n    assert(candidate((\"abba\")) == (\"Valid\"));\n    assert(candidate((\"a\")) == (\"Valid\"));\n    assert(candidate((\"abcd\")) == (\"Invalid\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_396_check_char","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to check whether the given string starts and ends with the same character or not.\nstd::string check_char(std::string str) {\n    if (str.empty())\n        return \"Empty string\";\n    \n    if (str.front() == str.back())\n        return \"Yes\";\n    \n    return \"No\";\n}\n```\n\nThis code defines the function `check_char` which checks if the given string starts and ends with the same character. If the string is empty, it returns \"Empty string\". If the string's first and last characters are the same, it returns \"Yes\", otherwise it returns \"No\"."}
{"name":"mbpp_397_median_numbers","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the median of three numbers.\nfloat median_numbers(long a, long b, long c) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_397_median_numbers.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = median_numbers;\n    assert(candidate((25), (55), (65)) == (55.0f));\n    assert(candidate((20), (10), (30)) == (20.0f));\n    assert(candidate((15), (45), (75)) == (45.0f));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_397_median_numbers","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the median of three numbers.\nfloat median_numbers(long a, long b, long c) {\n    \/\/ Sort the three numbers\n    if ((a >= b && a <= c) || (a <= b && a >= c))\n        return a;\n    else if ((b >= a && b <= c) || (b <= a && b >= c))\n        return b;\n    else\n        return c;\n}\n```"}
{"name":"mbpp_398_sum_of_digits","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to compute the sum of digits of each number of a given vector.\nlong sum_of_digits(std::vector<std::any> nums) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_398_sum_of_digits.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sum_of_digits;\n    assert(candidate((std::vector<std::any>({(long)10, (long)2, (long)56}))) == (14));\n    assert(candidate((std::vector<std::any>({(std::vector<long>)std::vector<std::any>({10, 20, 4, 5, \"b\", 70, \"a\"})}))) == (19));\n    assert(candidate((std::vector<std::any>({(long)10, (long)20, (long)-4, (long)5, (long)-70}))) == (19));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_398_sum_of_digits","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Function to compute the sum of digits of each number in a given vector\nlong sum_of_digits(std::vector<std::any> nums) {\n    long total_sum = 0;\n\n    for (const auto& elem : nums) {\n        if (elem.type() == typeid(int)) {\n            int number = std::any_cast<int>(elem);\n            int sum_digits = 0;\n\n            \/\/ Compute the sum of digits for the current number\n            while (number != 0) {\n                sum_digits += number % 10;\n                number \/= 10;\n            }\n            \n            total_sum += sum_digits;\n        } else if (elem.type() == typeid(long)) {\n            long number = std::any_cast<long>(elem);\n            long sum_digits = 0;\n\n            \/\/ Compute the sum of digits for the current number\n            while (number != 0) {\n                sum_digits += number % 10;\n                number \/= 10;\n            }\n            \n            total_sum += sum_digits;\n        }\n        \/\/ Add other data type checks if necessary\n    }\n\n    return total_sum;\n}\n```\n\nThis code defines the function `sum_of_digits` that takes a `std::vector<std::any>` and computes the sum of digits of each number in the vector. Note that the implementation currently handles `int` and `long` types. If other types need to be considered, similar logic can be added to handle those types accordingly."}
{"name":"mbpp_399_bitwise_xor","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to perform the mathematical bitwise xor operation across the given tuples.\nstd::tuple<long, long, long, long> bitwise_xor(std::tuple<long, long, long, long> test_tup1, std::tuple<long, long, long, long> test_tup2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_399_bitwise_xor.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = bitwise_xor;\n    assert(candidate((std::make_tuple(10, 4, 6, 9)), (std::make_tuple(5, 2, 3, 3))) == (std::make_tuple(15, 6, 5, 10)));\n    assert(candidate((std::make_tuple(11, 5, 7, 10)), (std::make_tuple(6, 3, 4, 4))) == (std::make_tuple(13, 6, 3, 14)));\n    assert(candidate((std::make_tuple(12, 6, 8, 11)), (std::make_tuple(7, 4, 5, 6))) == (std::make_tuple(11, 2, 13, 13)));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_399_bitwise_xor","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to perform the mathematical bitwise xor operation across the given tuples.\nstd::tuple<long, long, long, long> bitwise_xor(std::tuple<long, long, long, long> test_tup1, std::tuple<long, long, long, long> test_tup2) {\n    long a1, b1, c1, d1;\n    long a2, b2, c2, d2;\n    \n    \/\/ Unpack the first tuple\n    std::tie(a1, b1, c1, d1) = test_tup1;\n    \n    \/\/ Unpack the second tuple\n    std::tie(a2, b2, c2, d2) = test_tup2;\n    \n    \/\/ Perform bitwise XOR on each corresponding element\n    long r1 = a1 ^ a2;\n    long r2 = b1 ^ b2;\n    long r3 = c1 ^ c2;\n    long r4 = d1 ^ d2;\n    \n    \/\/ Return the resulting tuple\n    return std::make_tuple(r1, r2, r3, r4);\n}\n\n\/\/ Example usage\n\/\/ std::tuple<long, long, long, long> tup1 = std::make_tuple(1, 2, 3, 4);\n\/\/ std::tuple<long, long, long, long> tup2 = std::make_tuple(4, 3, 2, 1);\n\/\/ std::tuple<long, long, long, long> result = bitwise_xor(tup1, tup2);\n\/\/ assert(result == std::make_tuple(1^4, 2^3, 3^2, 4^1));\n```"}
{"name":"mbpp_400_extract_freq","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to extract the number of unique tuples in the given vector.\nlong extract_freq(std::vector<std::tuple<long, long>> test_list) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_400_extract_freq.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = extract_freq;\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(3, 4), (std::tuple<long, long>)std::make_tuple(1, 2), (std::tuple<long, long>)std::make_tuple(4, 3), (std::tuple<long, long>)std::make_tuple(5, 6)}))) == (3));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(4, 15), (std::tuple<long, long>)std::make_tuple(2, 3), (std::tuple<long, long>)std::make_tuple(5, 4), (std::tuple<long, long>)std::make_tuple(6, 7)}))) == (4));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(5, 16), (std::tuple<long, long>)std::make_tuple(2, 3), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(6, 9)}))) == (4));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_400_extract_freq","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to extract the number of unique tuples in the given vector.\nlong extract_freq(std::vector<std::tuple<long, long>> test_list) {\n    \/\/ Use a set to store unique tuples\n    std::set<std::tuple<long, long>> unique_tuples;\n    \n    \/\/ Iterate through the list and insert tuples into the set\n    for (const auto& item : test_list) {\n        unique_tuples.insert(item);\n    }\n    \n    \/\/ The size of the set is the number of unique tuples\n    return unique_tuples.size();\n}\n```\n\nThis code defines a function `extract_freq` that takes a vector of tuples containing `long` integers and returns the number of unique tuples in the vector. It uses a set to achieve this, as sets inherently store only unique elements."}
{"name":"mbpp_401_add_nested_tuples","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to perform index wise addition of vector elements in the given two nested vectors.\nstd::vector<std::vector<long>> add_nested_tuples(std::vector<std::vector<long>> test_tup1, std::vector<std::vector<long>> test_tup2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_401_add_nested_tuples.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = add_nested_tuples;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5}), (std::vector<long>)std::vector<long>({(long)2, (long)9}), (std::vector<long>)std::vector<long>({(long)1, (long)10})})), (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)7}), (std::vector<long>)std::vector<long>({(long)3, (long)9}), (std::vector<long>)std::vector<long>({(long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)7, (long)3})}))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)7, (long)10}), (std::vector<long>)std::vector<long>({(long)7, (long)14}), (std::vector<long>)std::vector<long>({(long)3, (long)10}), (std::vector<long>)std::vector<long>({(long)8, (long)13})})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)10}), (std::vector<long>)std::vector<long>({(long)2, (long)11})})), (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)4, (long)10}), (std::vector<long>)std::vector<long>({(long)2, (long)2}), (std::vector<long>)std::vector<long>({(long)8, (long)4})}))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)9, (long)12}), (std::vector<long>)std::vector<long>({(long)9, (long)16}), (std::vector<long>)std::vector<long>({(long)5, (long)12}), (std::vector<long>)std::vector<long>({(long)10, (long)15})})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)3, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)7}), (std::vector<long>)std::vector<long>({(long)4, (long)11}), (std::vector<long>)std::vector<long>({(long)3, (long)12})})), (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)5, (long)11}), (std::vector<long>)std::vector<long>({(long)3, (long)3}), (std::vector<long>)std::vector<long>({(long)9, (long)5})}))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11, (long)14}), (std::vector<long>)std::vector<long>({(long)11, (long)18}), (std::vector<long>)std::vector<long>({(long)7, (long)14}), (std::vector<long>)std::vector<long>({(long)12, (long)17})})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_401_add_nested_tuples","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to perform index wise addition of vector elements in the given two nested vectors.\nstd::vector<std::vector<long>> add_nested_tuples(std::vector<std::vector<long>> test_tup1, std::vector<std::vector<long>> test_tup2) {\n    \/\/ Ensure that the input vectors have the same size\n    assert(test_tup1.size() == test_tup2.size());\n    for(size_t i = 0; i < test_tup1.size(); ++i) {\n        assert(test_tup1[i].size() == test_tup2[i].size());\n    }\n\n    \/\/ Create a result vector of the same size\n    std::vector<std::vector<long>> result(test_tup1.size(), std::vector<long>(test_tup1[0].size()));\n\n    \/\/ Perform index wise addition\n    for(size_t i = 0; i < test_tup1.size(); ++i) {\n        for(size_t j = 0; j < test_tup1[i].size(); ++j) {\n            result[i][j] = test_tup1[i][j] + test_tup2[i][j];\n        }\n    }\n\n    return result;\n}\n```"}
{"name":"mbpp_404_minimum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the minimum of two numbers.\nlong minimum(long a, long b) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_404_minimum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = minimum;\n    assert(candidate((1), (2)) == (1));\n    assert(candidate((-5), (-4)) == (-5));\n    assert(candidate((0), (0)) == (0));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_404_minimum","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the minimum of two numbers.\nlong minimum(long a, long b) {\n    return (a < b) ? a : b;\n}\n```"}
{"name":"mbpp_405_check_tuplex","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n\/\/ Write a function to check whether an element exists within a tuple.\nbool check_tuplex(std::vector<Union_std_string_long> tuplex, std::any tuple1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_405_check_tuplex.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = check_tuplex;\n    assert(candidate((std::vector<Union_std_string_long>({(std::string)\"w\", (std::string)3, (std::string)\"r\", (std::string)\"e\", (std::string)\"s\", (std::string)\"o\", (std::string)\"u\", (std::string)\"r\", (std::string)\"c\", (std::string)\"e\"})), (std::any(\"r\"))) == (true));\n    assert(candidate((std::vector<Union_std_string_long>({(std::string)\"w\", (std::string)3, (std::string)\"r\", (std::string)\"e\", (std::string)\"s\", (std::string)\"o\", (std::string)\"u\", (std::string)\"r\", (std::string)\"c\", (std::string)\"e\"})), (std::any(\"5\"))) == (false));\n    assert(candidate((std::vector<Union_std_string_long>({(std::string)\"w\", (std::string)3, (std::string)\"r\", (std::string)\"e\", (std::string)\"s\", (std::string)\"o\", (std::string)\"u\", (std::string)\"r\", (std::string)\"c\", (std::string)\"e\"})), (std::any(3))) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_405_check_tuplex","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    \n    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }\n    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n\n\/\/ Write a function to check whether an element exists within a tuple.\nbool check_tuplex(std::vector<Union_std_string_long> tuplex, std::any tuple1) {\n    for(const auto& element : tuplex) {\n        if (tuple1.type() == typeid(std::string)) {\n            try {\n                std::string value = std::any_cast<std::string>(tuple1);\n                if (element == value) {\n                    return true;\n                }\n            } catch (const std::bad_any_cast& e) {\n                continue;\n            }\n        } else if (tuple1.type() == typeid(long)) {\n            try {\n                long value = std::any_cast<long>(tuple1);\n                if (element == value) {\n                    return true;\n                }\n            } catch (const std::bad_any_cast& e) {\n                continue;\n            }\n        }\n    }\n    return false;\n}\n```\n\nThe above code defines a union `Union_std_string_long` that can hold either a `std::string` or a `long`, and a function `check_tuplex` that takes a vector of `Union_std_string_long` and a `std::any` type, checks the type of `std::any`, and searches for it in the vector."}
{"name":"mbpp_406_find_Parity","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find whether the parity of a given number is odd.\nbool find_Parity(long x) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_406_find_Parity.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_Parity;\n    assert(candidate((12)) == (false));\n    assert(candidate((7)) == (true));\n    assert(candidate((10)) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_406_find_Parity","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to find whether the parity of a given number is odd\nbool find_Parity(long x) {\n    bool parity = false;  \/\/ Initialize parity as false (even parity)\n    while (x) {\n        parity = !parity; \/\/ Toggle parity\n        x = x & (x - 1);  \/\/ Remove the lowest set bit\n    }\n    return parity;  \/\/ True if parity is odd, else false\n}\n```"}
{"name":"mbpp_407_rearrange_bigger","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to create the next bigger number by rearranging the digits of a given number.\nstd::any rearrange_bigger(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_407_rearrange_bigger.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = rearrange_bigger;\n    assert(candidate((12)) == (std::any(21)));\n    assert(candidate((10)) == (std::any(false)));\n    assert(candidate((102)) == (std::any(120)));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_407_rearrange_bigger","gpt_solution":"```cpp\n#include <cassert>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to create the next bigger number by rearranging the digits of a given number.\nstd::any rearrange_bigger(long n) {\n    std::string num_str = std::to_string(n);\n    int length = num_str.size();\n\n    \/\/ Step 1: Find the rightmost character which is smaller than its next character.\n    int i;\n    for (i = length - 2; i >= 0; --i) {\n        if (num_str[i] < num_str[i + 1]) {\n            break;\n        }\n    }\n\n    \/\/ If no such character is found, no larger number can be formed\n    if (i == -1) {\n        return std::any();\n    }\n\n    \/\/ Step 2: Find the smallest digit on the right side of the found character, which is larger than the found character\n    int j;\n    for (j = length - 1; j > i; --j) {\n        if (num_str[j] > num_str[i]) {\n            break;\n        }\n    }\n\n    \/\/ Step 3: Swap the above found characters\n    std::swap(num_str[i], num_str[j]);\n\n    \/\/ Step 4: Sort the digits after the (i+1)th position\n    std::sort(num_str.begin() + i + 1, num_str.end());\n\n    \/\/ Convert the rearranged string back to long\n    long next_bigger_number = std::stol(num_str);\n\n    return std::any(next_bigger_number);\n}\n\n\/\/ Helper function for testing\nvoid test_rearrange_bigger() {\n    \/\/ Some test cases\n    assert(std::any_cast<long>(rearrange_bigger(1234)) == 1243);\n    assert(std::any_cast<long>(rearrange_bigger(4321)) == 0);\n    assert(std::any_cast<long>(rearrange_bigger(534976)) == 536479);\n    assert(std::any_cast<long>(rearrange_bigger(123)) == 132);\n    assert(std::any_cast<long>(rearrange_bigger(111)) == 0);\n}\n\n\/\/ Note: Call test_rearrange_bigger() function from main() or test framework to verify correctness\n\/*\nint main() {\n    test_rearrange_bigger();\n    return 0;\n}\n*\/\n```"}
{"name":"mbpp_408_k_smallest_pairs","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_408_k_smallest_pairs.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_408_k_smallest_pairs","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n\n    auto compare = [&](std::pair<int, int> a, std::pair<int, int> b) {\n        return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];\n    };\n\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, decltype(compare)> min_heap(compare);\n    for (int i = 0; i < nums1.size() && i < k; ++i) {\n        min_heap.emplace(i, 0);\n    }\n\n    while (k-- > 0 && !min_heap.empty()) {\n        auto [i, j] = min_heap.top();\n        min_heap.pop();\n        result.push_back({ nums1[i], nums2[j] });\n        if (j + 1 < nums2.size()) {\n            min_heap.emplace(i, j + 1);\n        }\n    }\n\n    return result;\n}\n```"}
{"name":"mbpp_409_min_product_tuple","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the minimum product from the pairs of tuples within a given vector.\nlong min_product_tuple(std::vector<std::tuple<long, long>> list1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_409_min_product_tuple.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = min_product_tuple;\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 7), (std::tuple<long, long>)std::make_tuple(2, 6), (std::tuple<long, long>)std::make_tuple(1, 8), (std::tuple<long, long>)std::make_tuple(4, 9)}))) == (8));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(10, 20), (std::tuple<long, long>)std::make_tuple(15, 2), (std::tuple<long, long>)std::make_tuple(5, 10)}))) == (30));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(11, 44), (std::tuple<long, long>)std::make_tuple(10, 15), (std::tuple<long, long>)std::make_tuple(20, 5), (std::tuple<long, long>)std::make_tuple(12, 9)}))) == (100));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_409_min_product_tuple","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n#include <assert.h>\n\n\/\/ Write a function to find the minimum product from the pairs of tuples within a given vector.\nlong min_product_tuple(std::vector<std::tuple<long, long>> list1) {\n    \/\/ Initialize min_product with the maximum possible value\n    long min_product = std::numeric_limits<long>::max();\n    \n    for (const auto& tuple : list1) {\n        long first = std::get<0>(tuple);\n        long second = std::get<1>(tuple);\n        \n        \/\/ Calculate the product of the current tuple\n        long product = first * second;\n        \n        \/\/ Update min_product if the current product is smaller\n        if (product < min_product) {\n            min_product = product;\n        }\n    }\n    \n    return min_product;\n}\n\n\/\/ Example test case\nvoid test() {\n    std::vector<std::tuple<long, long>> list1 = {{1, 2}, {3, 4}, {5, -6}};\n    assert(min_product_tuple(list1) == -30);\n    \n    list1 = {{-1, -2}, {-3, -4}, {-5, -6}};\n    assert(min_product_tuple(list1) == -30);\n\n    list1 = {{0, 2}, {3, -4}, {5, 6}};\n    assert(min_product_tuple(list1) == -12);\n\n    list1 = {{10, 10}, {20, 20}, {30, 30}};\n    assert(min_product_tuple(list1) == 100);\n\n    \/\/ Add more test cases if needed\n}\n\n\/\/ Uncomment the line below to run the test function if you want to test the correctness of the code\n\/\/ test();\n```"}
{"name":"mbpp_410_min_val","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n\/\/ Write a function to find the minimum value in a given heterogeneous vector.\nlong min_val(std::vector<Union_std_string_long> listval) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_410_min_val.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = min_val;\n    assert(candidate((std::vector<Union_std_string_long>({(std::string)\"Python\", (std::string)3, (std::string)2, (std::string)4, (std::string)5, (std::string)\"version\"}))) == (2));\n    assert(candidate((std::vector<Union_std_string_long>({(std::string)\"Python\", (std::string)15, (std::string)20, (std::string)25}))) == (15));\n    assert(candidate((std::vector<Union_std_string_long>({(std::string)\"Python\", (std::string)30, (std::string)20, (std::string)40, (std::string)50, (std::string)\"version\"}))) == (20));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_410_min_val","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\nunion Union_std_string_long {\n    std::string f0;\n    long f1;\n\n    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n\n    bool operator==(std::string f) {\n        return f0 == f;\n    }\n\n    bool operator==(long f) {\n        return f1 == f;\n    }\n};\n\nlong min_val(std::vector<Union_std_string_long> listval) {\n    bool has_value = false;\n    long min_value = LONG_MAX;\n\n    for (const auto& item : listval) {\n        if (item == item.f1) { \/\/ Check if the union currently holds a long\n            if (!has_value || item.f1 < min_value) {\n                min_value = item.f1;\n                has_value = true;\n            }\n        }\n    }\n\n    if (has_value) {\n        return min_value;\n    } else {\n        throw std::runtime_error(\"No long integers found in the list.\");\n    }\n}\n```"}
{"name":"mbpp_411_snake_to_camel","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to convert the given snake case string to camel case string.\nstd::string snake_to_camel(std::string word) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_411_snake_to_camel.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = snake_to_camel;\n    assert(candidate((\"android_tv\")) == (\"AndroidTv\"));\n    assert(candidate((\"google_pixel\")) == (\"GooglePixel\"));\n    assert(candidate((\"apple_watch\")) == (\"AppleWatch\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_411_snake_to_camel","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to convert the given snake case string to camel case string.\nstd::string snake_to_camel(std::string word) {\n    std::string result;\n    bool to_upper = false;\n\n    for (char ch : word) {\n        if (ch == '_') {\n            to_upper = true;\n        } else {\n            if (to_upper) {\n                result += toupper(ch);\n                to_upper = false;\n            } else {\n                result += ch;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"name":"mbpp_412_remove_odd","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to remove odd numbers from a given vector.\nstd::vector<long> remove_odd(std::vector<long> l) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_412_remove_odd.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = remove_odd;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)6}))) == (std::vector<long>({(long)2, (long)4, (long)6})));\n    assert(candidate((std::vector<long>({(long)10, (long)20, (long)3}))) == (std::vector<long>({(long)10, (long)20})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_412_remove_odd","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a cppthon function to remove odd numbers from a given vector.\nstd::vector<long> remove_odd(std::vector<long> l) {\n    \/\/ Create an iterator to traverse through the vector.\n    std::vector<long>::iterator it = l.begin();\n    \n    \/\/ Loop through the vector and remove odd numbers.\n    while (it != l.end()) {\n        if (*it % 2 != 0) {\n            it = l.erase(it); \/\/ Erase the element and return the new iterator.\n        } else {\n            ++it; \/\/ Move to the next element.\n        }\n    }\n    \n    return l; \/\/ Return the modified vector.\n}\n\n```"}
{"name":"mbpp_413_extract_nth_element","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to extract the nth element from a given vector of tuples.\nstd::vector<std::any> extract_nth_element(std::vector<std::tuple<std::string, long, long>> list1, long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_413_extract_nth_element.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = extract_nth_element;\n    assert(candidate((std::vector<std::tuple<std::string, long, long>>({(std::tuple<std::string, long, long>)std::make_tuple(\"Greyson Fulton\", 98, 99), (std::tuple<std::string, long, long>)std::make_tuple(\"Brady Kent\", 97, 96), (std::tuple<std::string, long, long>)std::make_tuple(\"Wyatt Knott\", 91, 94), (std::tuple<std::string, long, long>)std::make_tuple(\"Beau Turnbull\", 94, 98)})), (0)) == (std::vector<std::any>({(std::string)\"Greyson Fulton\", (std::string)\"Brady Kent\", (std::string)\"Wyatt Knott\", (std::string)\"Beau Turnbull\"})));\n    assert(candidate((std::vector<std::tuple<std::string, long, long>>({(std::tuple<std::string, long, long>)std::make_tuple(\"Greyson Fulton\", 98, 99), (std::tuple<std::string, long, long>)std::make_tuple(\"Brady Kent\", 97, 96), (std::tuple<std::string, long, long>)std::make_tuple(\"Wyatt Knott\", 91, 94), (std::tuple<std::string, long, long>)std::make_tuple(\"Beau Turnbull\", 94, 98)})), (2)) == (std::vector<std::any>({(long)99, (long)96, (long)94, (long)98})));\n    assert(candidate((std::vector<std::tuple<std::string, long, long>>({(std::tuple<std::string, long, long>)std::make_tuple(\"Greyson Fulton\", 98, 99), (std::tuple<std::string, long, long>)std::make_tuple(\"Brady Kent\", 97, 96), (std::tuple<std::string, long, long>)std::make_tuple(\"Wyatt Knott\", 91, 94), (std::tuple<std::string, long, long>)std::make_tuple(\"Beau Turnbull\", 94, 98)})), (1)) == (std::vector<std::any>({(long)98, (long)97, (long)91, (long)94})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_413_extract_nth_element","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n#include <any>\n\nstd::vector<std::any> extract_nth_element(std::vector<std::tuple<std::string, long, long>> list1, long n) {\n    \/\/ Assert the given n should be within the bounds of the tuple size (0, 1, or 2)\n    assert(n >= 0 && n < 3);\n    \n    std::vector<std::any> result;\n    for(auto& tup : list1) {\n        if(n == 0) result.push_back(std::get<0>(tup));\n        else if(n == 1) result.push_back(std::get<1>(tup));\n        else if(n == 2) result.push_back(std::get<2>(tup));\n    }\n    \n    return result;\n}\n```"}
{"name":"mbpp_414_overlapping","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to check whether any value in a sequence exists in a sequence or not.\nbool overlapping(std::vector<long> list1, std::vector<long> list2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_414_overlapping.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = overlapping;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})), (std::vector<long>({(long)6, (long)7, (long)8, (long)9}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (std::vector<long>({(long)4, (long)5, (long)6}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)5})), (std::vector<long>({(long)1, (long)4, (long)5}))) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_414_overlapping","gpt_solution":"```cpp\n#include <vector>\n#include <unordered_set>\n\n\/\/ Function to check whether any value in a sequence exists in another sequence or not\nbool overlapping(std::vector<long> list1, std::vector<long> list2) {\n    \/\/ Create a set from the first list\n    std::unordered_set<long> set1(list1.begin(), list1.end());\n\n    \/\/ Check if any element in list2 exists in the set (which means it exists in list1)\n    for (long value : list2) {\n        if (set1.find(value) != set1.end()) {\n            return true; \/\/ Found an overlapping element\n        }\n    }\n\n    \/\/ No overlapping elements found\n    return false;\n}\n```"}
{"name":"mbpp_415_max_Product","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find a pair with highest product from a given vector of integers.\nstd::tuple<long, long> max_Product(std::vector<long> arr) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_415_max_Product.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = max_Product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)7, (long)0, (long)8, (long)4}))) == (std::make_tuple(7, 8)));\n    assert(candidate((std::vector<long>({(long)0, (long)-1, (long)-2, (long)-4, (long)5, (long)0, (long)-6}))) == (std::make_tuple(-4, -6)));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::make_tuple(2, 3)));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_415_max_Product","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a C++ function to find a pair with the highest product from a given vector of integers.\nstd::tuple<long, long> max_Product(std::vector<long> arr) {\n    \/\/ Check if the vector size is at least 2\n    assert(arr.size() >= 2);\n\n    \/\/ Initialize variables to store the maximum and second maximum numbers\n    long max1 = LONG_MIN, max2 = LONG_MIN;\n\n    \/\/ Initialize variables to store the minimum and second minimum numbers\n    long min1 = LONG_MAX, min2 = LONG_MAX;\n\n    \/\/ Iterate through the vector to find the required values\n    for(long num : arr) {\n        \/\/ Update the maximum and second maximum numbers\n        if (num > max1) {\n            max2 = max1;\n            max1 = num;\n        } else if (num > max2) {\n            max2 = num;\n        }\n\n        \/\/ Update the minimum and second minimum numbers\n        if (num < min1) {\n            min2 = min1;\n            min1 = num;\n        } else if (num < min2) {\n            min2 = num;\n        }\n    }\n\n    \/\/ Calculate the product of the two largest numbers and two smallest numbers\n    long product_max_pair = max1 * max2;\n    long product_min_pair = min1 * min2;\n\n    \/\/ Return the pair with the highest product\n    if (product_max_pair > product_min_pair) {\n        return std::make_tuple(max1, max2);\n    } else {\n        return std::make_tuple(min1, min2);\n    }\n}\n```"}
{"name":"mbpp_417_group_tuples","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find common first element in given vector of vectors.\nstd::vector<std::vector<std::string>> group_tuples(std::vector<std::vector<std::string>> Input) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_417_group_tuples.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = group_tuples;\n    assert(candidate((std::vector<std::vector<std::string>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"x\", (std::string)\"y\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"x\", (std::string)\"z\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"w\", (std::string)\"t\"})}))) == (std::vector<std::vector<std::string>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"w\", (std::string)\"t\"})})));\n    assert(candidate((std::vector<std::vector<std::string>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"a\", (std::string)\"b\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"a\", (std::string)\"c\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"d\", (std::string)\"e\"})}))) == (std::vector<std::vector<std::string>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"d\", (std::string)\"e\"})})));\n    assert(candidate((std::vector<std::vector<std::string>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"f\", (std::string)\"g\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"f\", (std::string)\"g\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"h\", (std::string)\"i\"})}))) == (std::vector<std::vector<std::string>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"f\", (std::string)\"g\", (std::string)\"g\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"h\", (std::string)\"i\"})})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_417_group_tuples","gpt_solution":"```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\n\/\/ Function to group vectors by their first elements\nstd::vector<std::vector<std::string>> group_tuples(std::vector<std::vector<std::string>> Input) {\n    std::unordered_map<std::string, std::vector<std::vector<std::string>>> groups;\n    for (auto& vec : Input) {\n        \/\/ Ensure each vector is not empty before accessing its first element\n        assert(!vec.empty());\n        \/\/ Group vectors by their first element\n        groups[vec[0]].push_back(vec);\n    }\n\n    std::vector<std::vector<std::string>> result;\n    for (auto& pair : groups) {\n        \/\/ Flatten each group and append it to the result vector\n        for (auto& vec : pair.second) {\n            result.push_back(vec);\n        }\n    }\n    \n    return result;\n}\n```\n\nThis function `group_tuples` groups the given vectors by their first elements. It ensures that each vector is not empty using an `assert` statement. The vectors are then grouped by their first elements using an unordered map. Finally, the grouped vectors are flattened and returned in a single result vector."}
{"name":"mbpp_418_Find_Max","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the element of a vector having maximum length.\nstd::vector<std::any> Find_Max(std::vector<std::vector<std::any>> lst) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_418_Find_Max.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = Find_Max;\n    assert(candidate((std::vector<std::vector<std::any>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"A\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"A\", (std::string)\"B\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"A\", (std::string)\"B\", (std::string)\"C\"})}))) == (std::vector<std::any>({(std::string)\"A\", (std::string)\"B\", (std::string)\"C\"})));\n    assert(candidate((std::vector<std::vector<std::any>>({(std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})}))) == (std::vector<std::any>({(long)1, (long)2, (long)3})));\n    assert(candidate((std::vector<std::vector<std::any>>({(std::vector<long>)std::vector<long>({(long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)1, (long)5, (long)6, (long)1})}))) == (std::vector<std::any>({(long)1, (long)5, (long)6, (long)1})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_418_Find_Max","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to find the element of a vector having maximum length\nstd::vector<std::any> Find_Max(std::vector<std::vector<std::any>> lst) {\n    \/\/ Initialize the maximum length to zero and an empty vector for the result\n    size_t max_length = 0;\n    std::vector<std::any> max_vector;\n    \n    \/\/ Iterate through the list of vectors\n    for(const auto& vec : lst) {\n        \/\/ Update the maximum length and max_vector if the current vector is longer\n        if(vec.size() > max_length) {\n            max_length = vec.size();\n            max_vector = vec;\n        }\n    }\n    \n    \/\/ Return the vector with the maximum length\n    return max_vector;\n}\n```\n\nThis implementation iterates through the list of vectors, keeping track of the vector with the maximum length encountered so far. It returns this vector once all elements in the list have been considered."}
{"name":"mbpp_419_round_and_sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\nunion Union_float_long{\n    float f0;\n    long f1;    Union_float_long(float _f0) : f0(_f0) {}\n    Union_float_long(long _f1) : f1(_f1) {}\n    ~Union_float_long() {}\n    bool operator==(float f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n\/\/ Write a function to round every number of a given vector of numbers and print the total sum multiplied by the length of the vector.\nlong round_and_sum(std::vector<Union_float_long> list1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_419_round_and_sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = round_and_sum;\n    assert(candidate((std::vector<Union_float_long>({(float)22.4f, (float)4.0f, (float)-16.22f, (float)-9.1f, (float)11.0f, (float)-12.22f, (float)14.2f, (float)-5.2f, (float)17.5f}))) == (243));\n    assert(candidate((std::vector<Union_float_long>({(long)5, (long)2, (long)9, (long)24.3f, (long)29}))) == (345));\n    assert(candidate((std::vector<Union_float_long>({(float)25.0f, (float)56.7f, (float)89.2f}))) == (513));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_419_round_and_sum","gpt_solution":"```cpp\n#include <vector>\n#include <iostream>\n#include <cmath>\n#include <bits\/stdc++.h> \/\/ Include all standard headers\n\nunion Union_float_long {\n    float f0;\n    long f1;\n\n    Union_float_long(float _f0) : f0(_f0) {}\n    Union_float_long(long _f1) : f1(_f1) {}\n    ~Union_float_long() {}\n\n    bool operator==(float f) const {\n        return f0 == f;\n    }\n\n    bool operator==(long f) const {\n        return f1 == f;\n    }\n};\n\n\/\/ Write a function to round every number of a given vector of numbers \n\/\/ and print the total sum multiplied by the length of the vector.\n\nlong round_and_sum(std::vector<Union_float_long> list1) {\n    long sum = 0;\n    for (const auto& item : list1) {\n        if (std::holds_alternative<float>(item)) {\n            sum += std::lround(item.f0);\n        } else {\n            sum += item.f1;\n        }\n    }\n    return sum * list1.size();\n}\n```\n\nNote: The above code assumes the usage of `std::holds_alternative`, which actually does not work directly with unions. Since `std::variant` would be a better alternative, here is a corrected version using `std::variant` instead of union.\n\n```cpp\n#include <vector>\n#include <iostream>\n#include <cmath>\n#include <variant>\n\nusing Union_float_long = std::variant<float, long>;\n\n\/\/ Write a function to round every number of a given vector of numbers \n\/\/ and print the total sum multiplied by the length of the vector.\n\nlong round_and_sum(std::vector<Union_float_long> list1) {\n    long sum = 0;\n    for (const auto& item : list1) {\n        if (std::holds_alternative<float>(item)) {\n            sum += std::lround(std::get<float>(item));\n        } else {\n            sum += std::get<long>(item);\n        }\n    }\n    return sum * list1.size();\n}\n```"}
{"name":"mbpp_420_cube_Sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the cube sum of first n even natural numbers.\nlong cube_Sum(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_420_cube_Sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = cube_Sum;\n    assert(candidate((2)) == (72));\n    assert(candidate((3)) == (288));\n    assert(candidate((4)) == (800));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_420_cube_Sum","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cpp function to find the cube sum of first n even natural numbers.\nlong cube_Sum(long n) {\n    long sum = 0;\n    for (long i = 1; i <= n; ++i) {\n        long even = 2 * i;\n        sum += even * even * even;\n    }\n    return sum;\n}\n\n\/\/ Adding some test assertions to verify the function\nint main() {\n    assert(cube_Sum(1) == 8); \/\/ 2^3 = 8\n    assert(cube_Sum(2) == 72); \/\/ 2^3 + 4^3 = 8 + 64 = 72\n    assert(cube_Sum(3) == 288); \/\/ 2^3 + 4^3 + 6^3 = 8 + 64 + 216 = 288\n    assert(cube_Sum(4) == 800); \/\/ 2^3 + 4^3 + 6^3 + 8^3 = 8 + 64 + 216 + 512 = 800\n    assert(cube_Sum(5) == 1800); \/\/ 2^3 + 4^3 + 6^3 + 8^3 + 10^3 = 8 + 64 + 216 + 512 + 1000 = 1800\n    \n    std::cout << \"All test cases passed!\";\n    return 0;\n}\n```"}
{"name":"mbpp_421_concatenate_tuple","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to concatenate each element of tuple by the delimiter.\nstd::string concatenate_tuple(std::tuple<std::string, std::string, long, std::string> test_tup) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_421_concatenate_tuple.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = concatenate_tuple;\n    assert(candidate((std::make_tuple(\"ID\", \"is\", 4, \"UTS\"))) == (\"ID-is-4-UTS\"));\n    assert(candidate((std::make_tuple(\"QWE\", \"is\", 4, \"RTY\"))) == (\"QWE-is-4-RTY\"));\n    assert(candidate((std::make_tuple(\"ZEN\", \"is\", 4, \"OP\"))) == (\"ZEN-is-4-OP\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_421_concatenate_tuple","gpt_solution":"```cpp\n#include <cassert>\n#include <tuple>\n#include <string>\n#include <sstream>\n\n\/\/ Write a function to concatenate each element of tuple by the delimiter.\nstd::string concatenate_tuple(std::tuple<std::string, std::string, long, std::string> test_tup, const std::string& delimiter) {\n    std::ostringstream oss;\n    oss << std::get<0>(test_tup) << delimiter\n        << std::get<1>(test_tup) << delimiter\n        << std::get<2>(test_tup) << delimiter\n        << std::get<3>(test_tup);\n    return oss.str();\n}\n```"}
{"name":"mbpp_422_find_Average_Of_Cube","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the average of cubes of first n natural numbers.\nfloat find_Average_Of_Cube(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_422_find_Average_Of_Cube.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_Average_Of_Cube;\n    assert(candidate((2)) == (4.5f));\n    assert(candidate((3)) == (float(12)));\n    assert(candidate((1)) == (float(1)));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_422_find_Average_Of_Cube","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a cpp function to find the average of cubes of first n natural numbers.\nfloat find_Average_Of_Cube(long n) {\n    if (n <= 0) return 0.0;\n\n    long long sum_of_cubes = 0;\n    for (long i = 1; i <= n; ++i) {\n        sum_of_cubes += (i * i * i);\n    }\n\n    return static_cast<float>(sum_of_cubes) \/ n;\n}\n```"}
{"name":"mbpp_424_extract_rear","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to extract only the rear index element of each string in the given tuple.\nstd::vector<std::string> extract_rear(std::tuple<std::string, std::string, std::string> test_tuple) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_424_extract_rear.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = extract_rear;\n    assert(candidate((std::make_tuple(\"Mers\", \"for\", \"Vers\"))) == (std::vector<std::string>({(std::string)\"s\", (std::string)\"r\", (std::string)\"s\"})));\n    assert(candidate((std::make_tuple(\"Avenge\", \"for\", \"People\"))) == (std::vector<std::string>({(std::string)\"e\", (std::string)\"r\", (std::string)\"e\"})));\n    assert(candidate((std::make_tuple(\"Gotta\", \"get\", \"go\"))) == (std::vector<std::string>({(std::string)\"a\", (std::string)\"t\", (std::string)\"o\"})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_424_extract_rear","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n#include <tuple>\n#include <vector>\n\n\/\/ Write a function to extract only the rear index element of each string in the given tuple.\nstd::vector<std::string> extract_rear(std::tuple<std::string, std::string, std::string> test_tuple) {\n    std::vector<std::string> result;\n    std::string first = std::get<0>(test_tuple);\n    std::string second = std::get<1>(test_tuple);\n    std::string third = std::get<2>(test_tuple);\n\n    if (!first.empty()) {\n        result.push_back(std::string(1, first.back()));\n    }\n    if (!second.empty()) {\n        result.push_back(std::string(1, second.back()));\n    }\n    if (!third.empty()) {\n        result.push_back(std::string(1, third.back()));\n    }\n\n    return result;\n}\n```"}
{"name":"mbpp_425_count_element_in_list","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to count the number of subvectors containing a particular element.\nlong count_element_in_list(std::vector<std::vector<std::any>> list1, std::any x) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_425_count_element_in_list.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = count_element_in_list;\n    assert(candidate((std::vector<std::vector<std::any>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)5, (long)7}), (std::vector<long>)std::vector<long>({(long)1, (long)11}), (std::vector<long>)std::vector<long>({(long)1, (long)15, (long)7})})), (std::any(1))) == (3));\n    assert(candidate((std::vector<std::vector<std::any>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"A\", (std::string)\"B\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"A\", (std::string)\"C\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"A\", (std::string)\"D\", (std::string)\"E\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"B\", (std::string)\"C\", (std::string)\"D\"})})), (std::any(\"A\"))) == (3));\n    assert(candidate((std::vector<std::vector<std::any>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"A\", (std::string)\"B\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"A\", (std::string)\"C\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"A\", (std::string)\"D\", (std::string)\"E\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"B\", (std::string)\"C\", (std::string)\"D\"})})), (std::any(\"E\"))) == (1));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_425_count_element_in_list","gpt_solution":"```cpp\n#include <cassert>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to count the number of subvectors containing a particular element.\nlong count_element_in_list(std::vector<std::vector<std::any>> list1, std::any x) {\n    long count = 0;\n    for (const auto& subvec : list1) {\n        for (const auto& elem : subvec) {\n            if (elem.type() == x.type()) {\n                if (std::any_cast<int>(elem) == std::any_cast<int>(x)) {\n                    count++;\n                    break;\n                }\n                \/\/ Add other type checks here if needed\n            }\n        }\n    }\n    return count;\n}\n\nvoid test_count_element_in_list() {\n    std::vector<std::vector<std::any>> list1 = {\n        {1, \"foo\", 3.4},\n        {2, 2, \"bar\"},\n        {3, \"baz\", 1},\n        {4}\n    };\n    \n    \/\/ Test case 1: Count sub-vectors containing the integer 1\n    long result1 = count_element_in_list(list1, 1);\n    assert(result1 == 2);\n\n    \/\/ Test case 2: Count sub-vectors containing the string \"bar\"\n    std::string test_str = \"bar\";\n    long result2 = count_element_in_list(list1, test_str);\n    assert(result2 == 1);\n\n    \/\/ Test case 3: Count sub-vectors containing the integer 4\n    long result3 = count_element_in_list(list1, 4);\n    assert(result3 == 1);\n}\n\n\/\/ Test the function\ntest_count_element_in_list();\n```"}
{"name":"mbpp_426_filter_oddnumbers","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to filter odd numbers.\nstd::vector<long> filter_oddnumbers(std::vector<long> nums) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_426_filter_oddnumbers.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = filter_oddnumbers;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (std::vector<long>({(long)1, (long)3, (long)5, (long)7, (long)9})));\n    assert(candidate((std::vector<long>({(long)10, (long)20, (long)45, (long)67, (long)84, (long)93}))) == (std::vector<long>({(long)45, (long)67, (long)93})));\n    assert(candidate((std::vector<long>({(long)5, (long)7, (long)9, (long)8, (long)6, (long)4, (long)3}))) == (std::vector<long>({(long)5, (long)7, (long)9, (long)3})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_426_filter_oddnumbers","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to filter odd numbers.\nstd::vector<long> filter_oddnumbers(std::vector<long> nums) {\n    std::vector<long> result;\n    for(long num : nums) {\n        if(num % 2 != 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n\n\/\/ Function to verify the functionality\nvoid test_filter_oddnumbers() {\n    std::vector<long> nums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    std::vector<long> expected = {1, 3, 5, 7, 9};\n    assert(filter_oddnumbers(nums) == expected);\n\n    nums = {10, 20, 30};\n    expected = {};\n    assert(filter_oddnumbers(nums) == expected);\n\n    nums = {11, 21, 31};\n    expected = {11, 21, 31};\n    assert(filter_oddnumbers(nums) == expected);\n    \n    nums = {};\n    expected = {};\n    assert(filter_oddnumbers(nums) == expected);\n\n    std::cout << \"All test cases passed!\" << std::endl;\n}\n```\n\nIn the provided code, the function `filter_oddnumbers` takes a vector of long integers and returns a new vector containing only the odd numbers from the input vector. Additionally, the `test_filter_oddnumbers` function is provided to verify the correctness of the implementation using assert statements and various test cases."}
{"name":"mbpp_427_change_date_format","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\nstd::string change_date_format(std::string dt) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_427_change_date_format.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = change_date_format;\n    assert(candidate((\"2026-01-02\")) == (\"02-01-2026\"));\n    assert(candidate((\"2020-11-13\")) == (\"13-11-2020\"));\n    assert(candidate((\"2021-04-26\")) == (\"26-04-2021\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_427_change_date_format","gpt_solution":"```cpp\n#include <cassert>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\nstd::string change_date_format(std::string dt) {\n    \/\/ The input date is expected to be in the format yyyy-mm-dd\n    assert(dt.length() == 10); \/\/ Ensure date length is 10\n    assert(dt[4] == '-' && dt[7] == '-'); \/\/ Ensure proper separator locations\n\n    \/\/ Extract year, month, and day from input string\n    std::string year = dt.substr(0, 4);\n    std::string month = dt.substr(5, 2);\n    std::string day = dt.substr(8, 2);\n\n    \/\/ Construct new date in dd-mm-yyyy format\n    std::string new_format = day + \"-\" + month + \"-\" + year;\n\n    return new_format;\n}\n```"}
{"name":"mbpp_428_shell_sort","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to sort the given vector by using shell sort.\nstd::vector<long> shell_sort(std::vector<long> my_list) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_428_shell_sort.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = shell_sort;\n    assert(candidate((std::vector<long>({(long)12, (long)23, (long)4, (long)5, (long)3, (long)2, (long)12, (long)81, (long)56, (long)95}))) == (std::vector<long>({(long)2, (long)3, (long)4, (long)5, (long)12, (long)12, (long)23, (long)56, (long)81, (long)95})));\n    assert(candidate((std::vector<long>({(long)24, (long)22, (long)39, (long)34, (long)87, (long)73, (long)68}))) == (std::vector<long>({(long)22, (long)24, (long)34, (long)39, (long)68, (long)73, (long)87})));\n    assert(candidate((std::vector<long>({(long)32, (long)30, (long)16, (long)96, (long)82, (long)83, (long)74}))) == (std::vector<long>({(long)16, (long)30, (long)32, (long)74, (long)82, (long)83, (long)96})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_428_shell_sort","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to sort the given vector by using shell sort.\nstd::vector<long> shell_sort(std::vector<long> my_list) {\n    int n = my_list.size();\n    for (int gap = n\/2; gap > 0; gap \/= 2) {\n        for (int i = gap; i < n; i++) {\n            long temp = my_list[i];\n            int j;\n            for (j = i; j >= gap && my_list[j - gap] > temp; j -= gap) {\n                my_list[j] = my_list[j - gap];\n            }\n            my_list[j] = temp;\n        }\n    }\n    return my_list;\n}\n```"}
{"name":"mbpp_429_and_tuples","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to extract the elementwise and tuples from the given two tuples.\nstd::tuple<long, long, long, long> and_tuples(std::tuple<long, long, long, long> test_tup1, std::tuple<long, long, long, long> test_tup2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_429_and_tuples.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = and_tuples;\n    assert(candidate((std::make_tuple(10, 4, 6, 9)), (std::make_tuple(5, 2, 3, 3))) == (std::make_tuple(0, 0, 2, 1)));\n    assert(candidate((std::make_tuple(1, 2, 3, 4)), (std::make_tuple(5, 6, 7, 8))) == (std::make_tuple(1, 2, 3, 0)));\n    assert(candidate((std::make_tuple(8, 9, 11, 12)), (std::make_tuple(7, 13, 14, 17))) == (std::make_tuple(0, 9, 10, 0)));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_429_and_tuples","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to extract the elementwise and tuples from the given two tuples.\nstd::tuple<long, long, long, long> and_tuples(std::tuple<long, long, long, long> test_tup1, std::tuple<long, long, long, long> test_tup2) {\n    long a1, b1, c1, d1;\n    long a2, b2, c2, d2;\n\n    \/\/ Unpack the tuples\n    std::tie(a1, b1, c1, d1) = test_tup1;\n    std::tie(a2, b2, c2, d2) = test_tup2;\n\n    \/\/ Perform element-wise 'and' operation\n    long res1 = a1 & a2;\n    long res2 = b1 & b2;\n    long res3 = c1 & c2;\n    long res4 = d1 & d2;\n\n    \/\/ Pack the result into a new tuple and return it\n    return std::make_tuple(res1, res2, res3, res4);\n}\n```"}
{"name":"mbpp_430_parabola_directrix","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the directrix of a parabola.\nlong parabola_directrix(long a, long b, long c) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_430_parabola_directrix.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = parabola_directrix;\n    assert(candidate((5), (3), (2)) == (-198));\n    assert(candidate((9), (8), (4)) == (-2336));\n    assert(candidate((2), (4), (6)) == (-130));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_430_parabola_directrix","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Function to find the directrix of a parabola given by the equation y = ax^2 + bx + c\n\/\/ The directrix of a parabola y = ax^2 + bx + c is given by the equation y = c - (b^2 + 1) \/ 4a\nlong parabola_directrix(long a, long b, long c) {\n    if (a == 0) {\n        throw std::invalid_argument(\"Coefficient a cannot be zero for a parabola.\");\n    }\n    return c - (b * b + 1) \/ (4 * a);\n}\n```\n\nThis implementation assumes the use of integer arithmetic and does not handle floating point operations or rounding explicitly. The function calculates the directrix for the parabola described by the standard form equation \\( y = ax^2 + bx + c \\). The exception is thrown if \\( a \\) is zero, as in this case, the equation does not represent a parabola."}
{"name":"mbpp_431_common_element","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that takes two vectors and returns true if they have at least one common element.\nstd::optional<bool> common_element(std::vector<std::any> list1, std::vector<std::any> list2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_431_common_element.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = common_element;\n    assert(candidate((std::vector<std::any>({(long)1, (long)2, (long)3, (long)4, (long)5})), (std::vector<std::any>({(long)5, (long)6, (long)7, (long)8, (long)9}))) == true);\n    assert(candidate((std::vector<std::any>({(long)1, (long)2, (long)3, (long)4, (long)5})), (std::vector<std::any>({(long)6, (long)7, (long)8, (long)9}))) == std::nullopt);\n    assert(candidate((std::vector<std::any>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})), (std::vector<std::any>({(std::string)\"d\", (std::string)\"b\", (std::string)\"e\"}))) == true);\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_431_common_element","gpt_solution":"```cpp\n#include <cassert>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function that takes two vectors and returns true if they have at least one common element.\nstd::optional<bool> common_element(std::vector<std::any> list1, std::vector<std::any> list2) {\n    \/\/ Use a set to store elements of the first list.\n    std::unordered_set<std::any, std::hash<std::any>, std::equal_to<>> elements_set;\n    \n    \/\/ Insert all elements of the first list into the set.\n    for (const auto& element : list1) {\n        elements_set.insert(element);\n    }\n    \n    \/\/ Check for common elements in the second list.\n    for (const auto& element : list2) {\n        if (elements_set.count(element)) {\n            return std::optional<bool>(true);  \/\/ Return true if a common element is found.\n        }\n    }\n    \n    return std::optional<bool>(false);  \/\/ Return false if no common element is found.\n}\n```\n\nNote: The actual implementation of hashing and comparing `std::any` contained elements might not be directly supported because `std::any` is not hashable. This is a simplified illustration of the technique you might employ with data types that support direct comparison and hashing. Custom handlers might be necessary for certain data types."}
{"name":"mbpp_432_median_trapezium","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the median length of a trapezium.\nfloat median_trapezium(long base1, long base2, long height) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_432_median_trapezium.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = median_trapezium;\n    assert(candidate((15), (25), (35)) == (float(20)));\n    assert(candidate((10), (20), (30)) == (float(15)));\n    assert(candidate((6), (9), (4)) == (7.5f));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_432_median_trapezium","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to find the median length of a trapezium.\nfloat median_trapezium(long base1, long base2, long height) {\n    \/\/ The formula for the median length (m) of a trapezium is: m = (base1 + base2) \/ 2\n    return (base1 + base2) \/ 2.0;\n}\n```"}
{"name":"mbpp_433_check_greater","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check whether the entered number is greater than the elements of the given vector.\nbool check_greater(std::vector<long> arr, long number) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_433_check_greater.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = check_greater;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})), (4)) == (false));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)4, (long)5, (long)6})), (8)) == (true));\n    assert(candidate((std::vector<long>({(long)9, (long)7, (long)4, (long)8, (long)6, (long)1})), (11)) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_433_check_greater","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to check whether the entered number is greater than the elements of the given vector.\nbool check_greater(std::vector<long> arr, long number) {\n    for (long elem : arr) {\n        if (number <= elem) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"name":"mbpp_434_text_match_one","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that matches a string that has an a followed by one or more b's.\nbool text_match_one(std::string text) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_434_text_match_one.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = text_match_one;\n    assert(candidate((\"ac\")) == (false));\n    assert(candidate((\"dc\")) == (false));\n    assert(candidate((\"abba\")) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_434_text_match_one","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Write a function that matches a string that has an a followed by one or more b's.\nbool text_match_one(string text) {\n    \/\/ Regular expression to match 'a' followed by one or more 'b's\n    regex pattern(\"ab+\");\n\n    \/\/ Check if the entire string matches the pattern\n    return regex_match(text, pattern);\n}\n```"}
{"name":"mbpp_435_last_Digit","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the last digit of a given number.\nlong last_Digit(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_435_last_Digit.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = last_Digit;\n    assert(candidate((123)) == (3));\n    assert(candidate((25)) == (5));\n    assert(candidate((30)) == (0));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_435_last_Digit","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cpp function to find the last digit of a given number.\nlong last_Digit(long n) {\n    \/\/ The last digit of n can be found by taking n modulo 10\n    return abs(n % 10);\n}\n```"}
{"name":"mbpp_436_neg_nos","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to return the negative numbers in a vector.\nstd::vector<long> neg_nos(std::vector<long> list1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_436_neg_nos.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = neg_nos;\n    assert(candidate((std::vector<long>({(long)-1, (long)4, (long)5, (long)-6}))) == (std::vector<long>({(long)-1, (long)-6})));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)3, (long)4}))) == (std::vector<long>({(long)-1, (long)-2})));\n    assert(candidate((std::vector<long>({(long)-7, (long)-6, (long)8, (long)9}))) == (std::vector<long>({(long)-7, (long)-6})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_436_neg_nos","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cpp function to return the negative numbers in a vector.\nstd::vector<long> neg_nos(std::vector<long> list1) {\n    std::vector<long> negative_numbers;\n    for(long num : list1) {\n        if(num < 0) {\n            negative_numbers.push_back(num);\n        }\n    }\n    return negative_numbers;\n}\n```"}
{"name":"mbpp_437_remove_odd","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to remove odd characters in a string.\nstd::string remove_odd(std::string str1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_437_remove_odd.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = remove_odd;\n    assert(candidate((\"python\")) == (\"yhn\"));\n    assert(candidate((\"program\")) == (\"rga\"));\n    assert(candidate((\"language\")) == (\"agae\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_437_remove_odd","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to remove odd characters in a string.\nstd::string remove_odd(std::string str1) {\n    std::string result;\n    for (size_t i = 0; i < str1.length(); ++i) {\n        if (i % 2 == 0) {  \/\/ Only include characters with even indices\n            result += str1[i];\n        }\n    }\n    return result;\n}\n```"}
{"name":"mbpp_438_count_bidirectional","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to count bidirectional tuple pairs.\nlong count_bidirectional(std::vector<std::tuple<long, long>> test_list) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_438_count_bidirectional.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = count_bidirectional;\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(5, 6), (std::tuple<long, long>)std::make_tuple(1, 2), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(9, 1), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(2, 1)}))) == (3));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(5, 6), (std::tuple<long, long>)std::make_tuple(1, 3), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(9, 1), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(2, 1)}))) == (2));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(5, 6), (std::tuple<long, long>)std::make_tuple(1, 2), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(9, 2), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(2, 1)}))) == (4));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_438_count_bidirectional","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to count bidirectional tuple pairs.\nlong count_bidirectional(std::vector<std::tuple<long, long>> test_list) {\n    \/\/ Create a set of tuples for fast lookup\n    std::set<std::tuple<long, long>> tuple_set(test_list.begin(), test_list.end());\n    long bidirectional_count = 0;\n\n    \/\/ Iterate through each tuple in the list\n    for (auto& t : test_list) {\n        long first = std::get<0>(t);\n        long second = std::get<1>(t);\n        \/\/ Check if the reverse tuple exists in the set and ensure they are not the same element\n        if (tuple_set.find(std::make_tuple(second, first)) != tuple_set.end() && first != second) {\n            bidirectional_count += 1;\n            tuple_set.erase(std::make_tuple(second, first));  \/\/ To avoid double counting\n        }\n    }\n\n    return bidirectional_count;\n}\n```"}
{"name":"mbpp_439_multiple_to_single","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to join a vector of multiple integers into a single integer.\nlong multiple_to_single(std::vector<long> L) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_439_multiple_to_single.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = multiple_to_single;\n    assert(candidate((std::vector<long>({(long)11, (long)33, (long)50}))) == (113350));\n    assert(candidate((std::vector<long>({(long)-1, (long)2, (long)3, (long)4, (long)5, (long)6}))) == (-123456));\n    assert(candidate((std::vector<long>({(long)10, (long)15, (long)20, (long)25}))) == (10152025));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_439_multiple_to_single","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to join a vector of multiple integers into a single integer.\nlong multiple_to_single(std::vector<long> L) {\n    std::string result_str = \"\";\n    for(long num : L) {\n        result_str += std::to_string(num);\n    }\n    return std::stol(result_str);\n}\n```"}
{"name":"mbpp_440_find_adverb_position","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the first adverb and their positions in a given sentence.\nstd::tuple<long, long, std::string> find_adverb_position(std::string text) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_440_find_adverb_position.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_adverb_position;\n    assert(candidate((\"clearly!! we can see the sky\")) == (std::make_tuple(0, 7, \"clearly\")));\n    assert(candidate((\"seriously!! there are many roses\")) == (std::make_tuple(0, 9, \"seriously\")));\n    assert(candidate((\"unfortunately!! sita is going to home\")) == (std::make_tuple(0, 13, \"unfortunately\")));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_440_find_adverb_position","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\nstd::tuple<long, long, std::string> find_adverb_position(std::string text) {\n    std::istringstream iss(text);\n    std::string word;\n    long start_pos = -1, end_pos = -1;\n    std::string adverb = \"\";\n\n    \/\/ Set of common adverbs\n    std::set<std::string> adverbs = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"sadly\",\n                                     \"angrily\", \"badly\", \"brightly\", \"easily\", \"loudly\", \n                                     \"politely\", \"quietly\"};\n\n    long current_pos = 0;\n    while (iss >> word) {\n        auto it = adverbs.find(word);\n        if (it != adverbs.end()) {\n            start_pos = text.find(word, current_pos);\n            end_pos = start_pos + word.length() - 1;\n            adverb = word;\n            break;\n        }\n        current_pos += word.length() + 1; \/\/ plus one for space\n    }\n\n    if(start_pos == -1) {\n        return std::make_tuple(start_pos, end_pos, \"\");\n    }\n\n    return std::make_tuple(start_pos, end_pos, adverb);\n}\n```\n\nThis code defines a function `find_adverb_position` that searches for the first adverb in a provided sentence, returning the starting and ending positions of the adverb along with the adverb itself. The set of recognized adverbs includes common English adverbs and can be extended as needed."}
{"name":"mbpp_441_surfacearea_cube","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the surface area of a cube of a given size.\nlong surfacearea_cube(long l) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_441_surfacearea_cube.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = surfacearea_cube;\n    assert(candidate((5)) == (150));\n    assert(candidate((3)) == (54));\n    assert(candidate((10)) == (600));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_441_surfacearea_cube","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the surface area of a cube of a given size.\nlong surfacearea_cube(long l) {\n    \/\/ The surface area of a cube is given by 6 * side^2\n    return 6 * l * l;\n}\n```\n\nHere is the implementation of the function `surfacearea_cube` which calculates the surface area of a cube with side length `l`. The formula used is `6 * l^2` where `l` is the length of one side of the cube."}
{"name":"mbpp_442_positive_count","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the ration of positive numbers in a vector of integers.\nfloat positive_count(std::vector<long> nums) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_442_positive_count.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = positive_count;\n    assert(candidate((std::vector<long>({(long)0, (long)1, (long)2, (long)-1, (long)-5, (long)6, (long)0, (long)-3, (long)-2, (long)3, (long)4, (long)6, (long)8}))) == (0.54f));\n    assert(candidate((std::vector<long>({(long)2, (long)1, (long)2, (long)-1, (long)-5, (long)6, (long)4, (long)-3, (long)-2, (long)3, (long)4, (long)6, (long)8}))) == (0.69f));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-6, (long)-9, (long)11, (long)-12, (long)14, (long)-5, (long)17}))) == (0.56f));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_442_positive_count","gpt_solution":"```cpp\n#include <assert.h>\n#include <vector>\n#include <iostream>\n\n\/\/ Write a function to find the ratio of positive numbers in a vector of integers.\nfloat positive_count(const std::vector<long>& nums) {\n    if (nums.empty()) {\n        return 0.0; \/\/ Return 0.0 if the input vector is empty\n    }\n    \n    int positiveNumbers = 0;\n    for (long num : nums) {\n        if (num > 0) {\n            positiveNumbers++;\n        }\n    }\n\n    return static_cast<float>(positiveNumbers) \/ nums.size();\n}\n```"}
{"name":"mbpp_443_largest_neg","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the largest negative number from the given vector.\nlong largest_neg(std::vector<long> list1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_443_largest_neg.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = largest_neg;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)-4, (long)-6}))) == (-6));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)-8, (long)-9}))) == (-9));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)-1}))) == (-1));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_443_largest_neg","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n\n\/\/ Function to find the largest negative number from the given vector.\nlong largest_neg(std::vector<long> list1) {\n    long max_neg = LONG_MIN; \/\/ Initialize to the smallest possible value long can hold\n    bool found_negative = false;\n\n    for (long num : list1) {\n        if (num < 0) {\n            found_negative = true;\n            if (num > max_neg) {\n                max_neg = num;\n            }\n        }\n    }\n\n    \/\/ If no negative number was found, return an appropriate indicator (e.g., LONG_MIN).\n    if (!found_negative) {\n        return LONG_MIN; \/\/ Change this behavior as per requirement or context\n    }\n\n    return max_neg;\n}\n\n\/\/ Example usage and test cases\nassert(largest_neg({-10, -20, -30, 4, 5}) == -10);\nassert(largest_neg({1, 2, 3, 4, 5}) == LONG_MIN);\nassert(largest_neg({-1, -2, -3, -4, -5}) == -1);\n```"}
{"name":"mbpp_444_trim_tuple","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to trim each vector by k in the given vectors.\nstd::vector<std::vector<long>> trim_tuple(std::vector<std::vector<long>> test_list, long K) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_444_trim_tuple.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = trim_tuple;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)3, (long)2, (long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)4, (long)9, (long)2, (long)1}), (std::vector<long>)std::vector<long>({(long)9, (long)1, (long)2, (long)3, (long)5}), (std::vector<long>)std::vector<long>({(long)4, (long)8, (long)2, (long)1, (long)7})})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2}), (std::vector<long>)std::vector<long>({(long)9}), (std::vector<long>)std::vector<long>({(long)2}), (std::vector<long>)std::vector<long>({(long)2})})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)3, (long)2, (long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)4, (long)9, (long)2, (long)1}), (std::vector<long>)std::vector<long>({(long)9, (long)1, (long)2, (long)3, (long)5}), (std::vector<long>)std::vector<long>({(long)4, (long)8, (long)2, (long)1, (long)7})})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)3, (long)2, (long)1}), (std::vector<long>)std::vector<long>({(long)4, (long)9, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)8, (long)2, (long)1})})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)7, (long)8, (long)4, (long)9}), (std::vector<long>)std::vector<long>({(long)11, (long)8, (long)12, (long)4}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)3, (long)6, (long)9, (long)7})})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)4}), (std::vector<long>)std::vector<long>({(long)8, (long)12}), (std::vector<long>)std::vector<long>({(long)1, (long)7}), (std::vector<long>)std::vector<long>({(long)6, (long)9})})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_444_trim_tuple","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to trim each vector by k in the given vectors.\nstd::vector<std::vector<long>> trim_tuple(std::vector<std::vector<long>> test_list, long K) {\n    std::vector<std::vector<long>> result;\n    for(auto &v : test_list) {\n        if (v.size() > 2 * K) {\n            std::vector<long> trimmed(v.begin() + K, v.end() - K);\n            result.push_back(trimmed);\n        } else {\n            \/\/ If the size is not larger than 2*K, we skip trimming to avoid invalid slicing\n            result.push_back({});\n        }\n    }\n    return result;\n}\n```"}
{"name":"mbpp_445_index_multiplication","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to perform index wise multiplication of vector elements in the given two vectors.\nstd::vector<std::vector<long>> index_multiplication(std::vector<std::vector<long>> test_tup1, std::vector<std::vector<long>> test_tup2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_445_index_multiplication.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = index_multiplication;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5}), (std::vector<long>)std::vector<long>({(long)2, (long)9}), (std::vector<long>)std::vector<long>({(long)1, (long)10})})), (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)7}), (std::vector<long>)std::vector<long>({(long)3, (long)9}), (std::vector<long>)std::vector<long>({(long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)7, (long)3})}))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)21}), (std::vector<long>)std::vector<long>({(long)12, (long)45}), (std::vector<long>)std::vector<long>({(long)2, (long)9}), (std::vector<long>)std::vector<long>({(long)7, (long)30})})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)10}), (std::vector<long>)std::vector<long>({(long)2, (long)11})})), (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)4, (long)10}), (std::vector<long>)std::vector<long>({(long)2, (long)2}), (std::vector<long>)std::vector<long>({(long)8, (long)4})}))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)14, (long)32}), (std::vector<long>)std::vector<long>({(long)20, (long)60}), (std::vector<long>)std::vector<long>({(long)6, (long)20}), (std::vector<long>)std::vector<long>({(long)16, (long)44})})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)3, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)7}), (std::vector<long>)std::vector<long>({(long)4, (long)11}), (std::vector<long>)std::vector<long>({(long)3, (long)12})})), (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)5, (long)11}), (std::vector<long>)std::vector<long>({(long)3, (long)3}), (std::vector<long>)std::vector<long>({(long)9, (long)5})}))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)24, (long)45}), (std::vector<long>)std::vector<long>({(long)30, (long)77}), (std::vector<long>)std::vector<long>({(long)12, (long)33}), (std::vector<long>)std::vector<long>({(long)27, (long)60})})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_445_index_multiplication","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n#include <assert.h>\n\nstd::vector<std::vector<long>> index_multiplication(std::vector<std::vector<long>> test_tup1, std::vector<std::vector<long>> test_tup2) {\n    \/\/ Check if the dimensions of both vectors are the same\n    assert(test_tup1.size() == test_tup2.size());\n    assert(test_tup1[0].size() == test_tup2[0].size());\n\n    std::vector<std::vector<long>> result(test_tup1.size(), std::vector<long>(test_tup1[0].size()));\n\n    for (size_t i = 0; i < test_tup1.size(); ++i) {\n        for (size_t j = 0; j < test_tup1[i].size(); ++j) {\n            result[i][j] = test_tup1[i][j] * test_tup2[i][j];\n        }\n    }\n\n    return result;\n}\n```"}
{"name":"mbpp_446_count_Occurrence","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to count the occurence of all elements of vector in a tuple.\nlong count_Occurrence(std::any tup, std::vector<std::any> lst) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_446_count_Occurrence.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = count_Occurrence;\n    assert(candidate(std::make_tuple(\"a\", \"a\", \"c\", \"b\", \"d\"), (std::vector<std::any>({(std::string)\"a\", (std::string)\"b\"}))) == (3));\n    assert(candidate(std::make_tuple(1, 2, 3, 1, 4, 6, 7, 1, 4), (std::vector<std::any>({(long)1, (long)4, (long)7}))) == (6));\n    assert(candidate(std::make_tuple(1, 2, 3, 4, 5, 6), (std::vector<std::any>({(long)1, (long)2}))) == (2));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_446_count_Occurrence","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n\n\/\/ Function to count the occurrence of all elements of a vector in a tuple\nlong count_Occurrence(std::any tup, std::vector<std::any> lst) {\n    \/\/ Verify that tup is actually a tuple\n    try {\n        auto tuple = std::any_cast<std::tuple<std::any, std::any, std::any>>(tup);\n        \/\/ Unpack the tuple elements\n        std::vector<std::any> tuple_elements = { std::get<0>(tuple), std::get<1>(tuple), std::get<2>(tuple) };\n        \n        std::unordered_map<std::string, int> occurrence_map;\n\n        \/\/ Count occurrences of each element in the tuple\n        for (const auto& elem : tuple_elements) {\n            std::string elem_str = std::any_cast<std::string>(elem);\n            occurrence_map[elem_str]++;\n        }\n\n        long total_occurrences = 0;\n\n        \/\/ Count the total occurrences of elements of lst in the tuple\n        for (const auto& item : lst) {\n            std::string item_str = std::any_cast<std::string>(item);\n            if (occurrence_map.find(item_str) != occurrence_map.end()) {\n                total_occurrences += occurrence_map[item_str];\n            }\n        }\n\n        return total_occurrences;\n    } catch (const std::bad_any_cast& e) {\n        \/\/ Handle the case where the input is not a tuple of three elements\n        assert(false && \"Input must be a tuple of three elements\");\n        return -1; \/\/ Return error indicator\n    }\n}\n```\n\nThis function `count_Occurrence` takes a tuple of three elements and a vector, counts the occurrences of each element in the tuple and sums up the occurrences based on the elements present in the vector. The elements in the tuple and the vector are expected to be strings wrapped in `std::any`. The function assumes the input tuple always has three elements. If the input tuple is not correct, it fails with an assertion."}
{"name":"mbpp_447_cube_nums","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find cubes of individual elements in a vector.\nstd::vector<long> cube_nums(std::vector<long> nums) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_447_cube_nums.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = cube_nums;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (std::vector<long>({(long)1, (long)8, (long)27, (long)64, (long)125, (long)216, (long)343, (long)512, (long)729, (long)1000})));\n    assert(candidate((std::vector<long>({(long)10, (long)20, (long)30}))) == (std::vector<long>({(long)1000, (long)8000, (long)27000})));\n    assert(candidate((std::vector<long>({(long)12, (long)15}))) == (std::vector<long>({(long)1728, (long)3375})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_447_cube_nums","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find cubes of individual elements in a vector.\nstd::vector<long> cube_nums(std::vector<long> nums) {\n    std::vector<long> result;\n    for(long num : nums) {\n        result.push_back(num * num * num);\n    }\n    return result;\n}\n```"}
{"name":"mbpp_448_cal_sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to calculate the sum of perrin numbers.\nlong cal_sum(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_448_cal_sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = cal_sum;\n    assert(candidate((9)) == (49));\n    assert(candidate((10)) == (66));\n    assert(candidate((11)) == (88));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_448_cal_sum","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Function to calculate the sum of Perrin numbers up to the n-th term\nlong cal_sum(long n) {\n    if (n < 0) return 0;\n    \n    \/\/ Base cases for Perrin sequence\n    std::vector<long> perrin = {3, 0, 2};\n    \n    \/\/ Calculate remaining Perrin numbers and their sum\n    long sum = perrin[0] + perrin[1] + perrin[2];\n    \n    for (long i = 3; i <= n; ++i) {\n        long next_perrin = perrin[i - 2] + perrin[i - 3];\n        perrin.push_back(next_perrin);\n        sum += next_perrin;\n    }\n    \n    \/\/ If n < 2, adjust the sum by excluding unnecessary elements\n    if (n < 2) return std::accumulate(perrin.begin(), perrin.begin() + n + 1, 0L);\n    return sum;\n}\n```"}
{"name":"mbpp_450_extract_string","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to extract specified size of strings from a given vector of string values.\nstd::vector<std::string> extract_string(std::vector<std::string> str, long l) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_450_extract_string.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = extract_string;\n    assert(candidate((std::vector<std::string>({(std::string)\"Python\", (std::string)\"list\", (std::string)\"exercises\", (std::string)\"practice\", (std::string)\"solution\"})), (8)) == (std::vector<std::string>({(std::string)\"practice\", (std::string)\"solution\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"Python\", (std::string)\"list\", (std::string)\"exercises\", (std::string)\"practice\", (std::string)\"solution\"})), (6)) == (std::vector<std::string>({(std::string)\"Python\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"Python\", (std::string)\"list\", (std::string)\"exercises\", (std::string)\"practice\", (std::string)\"solution\"})), (9)) == (std::vector<std::string>({(std::string)\"exercises\"})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_450_extract_string","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to extract specified size of strings from a given vector of string values.\nstd::vector<std::string> extract_string(std::vector<std::string> str, long l) {\n    std::vector<std::string> result;\n    for (const auto& s : str) {\n        if (s.size() == l) {\n            result.push_back(s);\n        }\n    }\n    return result;\n}\n```"}
{"name":"mbpp_451_remove_whitespaces","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to remove all whitespaces from the given string.\nstd::string remove_whitespaces(std::string text1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_451_remove_whitespaces.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = remove_whitespaces;\n    assert(candidate((\" Google    Flutter \")) == (\"GoogleFlutter\"));\n    assert(candidate((\" Google    Dart \")) == (\"GoogleDart\"));\n    assert(candidate((\" iOS    Swift \")) == (\"iOSSwift\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_451_remove_whitespaces","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to remove all whitespaces from the given string.\nstd::string remove_whitespaces(std::string text1) {\n    text1.erase(remove(text1.begin, text1.end(), ' '), text1.end());\n    return text1;\n}\n```"}
{"name":"mbpp_452_loss_amount","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that gives loss amount on a sale if the given amount has loss else return 0.\nlong loss_amount(long actual_cost, long sale_amount) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_452_loss_amount.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = loss_amount;\n    assert(candidate((1500), (1200)) == (0));\n    assert(candidate((100), (200)) == (100));\n    assert(candidate((2000), (5000)) == (3000));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_452_loss_amount","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function that gives loss amount on a sale if the given amount has loss else return 0.\nlong loss_amount(long actual_cost, long sale_amount) {\n    if(actual_cost > sale_amount) {\n        return actual_cost - sale_amount;\n    } else {\n        return 0;\n    }\n}\n```"}
{"name":"mbpp_453_sumofFactors","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the sum of even factors of a number.\nlong sumofFactors(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_453_sumofFactors.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sumofFactors;\n    assert(candidate((18)) == (26));\n    assert(candidate((30)) == (48));\n    assert(candidate((6)) == (8));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_453_sumofFactors","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the sum of even factors of a number.\n\nlong sumofFactors(long n) {\n    long sum = 0;\n\n    \/\/ Iterate through all numbers from 1 to n\n    for(long i = 1; i <= n; i++) {\n        \/\/ Check if i is a factor of n\n        if(n % i == 0) {\n            \/\/ Check if the factor is even\n            if(i % 2 == 0) {\n                sum += i;\n            }\n        }\n    }\n\n    return sum;\n}\n```"}
{"name":"mbpp_454_text_match_wordz","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that matches a word containing 'z'.\nbool text_match_wordz(std::string text) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_454_text_match_wordz.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = text_match_wordz;\n    assert(candidate((\"pythonz.\")) == (true));\n    assert(candidate((\"xyz.\")) == (true));\n    assert(candidate((\"  lang  .\")) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_454_text_match_wordz","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function that matches a word containing 'z'.\nbool text_match_wordz(std::string text) {\n    std::regex pattern(\"\\\\b\\\\w*z\\\\w*\\\\b\");\n    return std::regex_search(text, pattern);\n}\n\n\/\/ Example usage and test cases\n\nvoid test() {\n    assert(text_match_wordz(\"buzz\") == true);\n    assert(text_match_wordz(\"zoo\") == true);\n    assert(text_match_wordz(\"lazy\") == true);\n    assert(text_match_wordz(\"amazing\") == true);\n    assert(text_match_wordz(\"hello\") == false);\n    assert(text_match_wordz(\"world\") == false);\n    assert(text_match_wordz(\"greatest\") == false);\n    assert(text_match_wordz(\"javascript\") == true);\n}\n\n\/\/ Run the test cases\ntest();\n```"}
{"name":"mbpp_455_check_monthnumb_number","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check whether the given month number contains 31 days or not.\nbool check_monthnumb_number(long monthnum2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_455_check_monthnumb_number.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = check_monthnumb_number;\n    assert(candidate((5)) == (true));\n    assert(candidate((2)) == (false));\n    assert(candidate((6)) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_455_check_monthnumb_number","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check whether the given month number contains 31 days or not.\nbool check_monthnumb_number(long monthnum2) {\n    \/\/ Months with 31 days: January(1), March(3), May(5), July(7), August(8), October(10), December(12)\n    if (monthnum2 == 1 || monthnum2 == 3 || monthnum2 == 5 || \n        monthnum2 == 7 || monthnum2 == 8 || monthnum2 == 10 || monthnum2 == 12) {\n        return true;\n    } else {\n        return false;\n    }\n}\n```\n\nThis function checks if the given month number corresponds to a month that contains 31 days and returns `true` if it does, otherwise it returns `false`. The months with 31 days are January, March, May, July, August, October, and December."}
{"name":"mbpp_456_reverse_string_list","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to reverse each string in a given vector of string values.\nstd::vector<std::string> reverse_string_list(std::vector<std::string> stringlist) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_456_reverse_string_list.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = reverse_string_list;\n    assert(candidate((std::vector<std::string>({(std::string)\"Red\", (std::string)\"Green\", (std::string)\"Blue\", (std::string)\"White\", (std::string)\"Black\"}))) == (std::vector<std::string>({(std::string)\"deR\", (std::string)\"neerG\", (std::string)\"eulB\", (std::string)\"etihW\", (std::string)\"kcalB\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"john\", (std::string)\"amal\", (std::string)\"joel\", (std::string)\"george\"}))) == (std::vector<std::string>({(std::string)\"nhoj\", (std::string)\"lama\", (std::string)\"leoj\", (std::string)\"egroeg\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"jack\", (std::string)\"john\", (std::string)\"mary\"}))) == (std::vector<std::string>({(std::string)\"kcaj\", (std::string)\"nhoj\", (std::string)\"yram\"})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_456_reverse_string_list","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to reverse each string in a given vector of string values.\nstd::vector<std::string> reverse_string_list(std::vector<std::string> stringlist) {\n    for (auto &str : stringlist) {\n        std::reverse(str.begin(), str.end());\n    }\n    return stringlist;\n}\n```\n\nThe above code defines a function `reverse_string_list` that takes a vector of strings as input and reverses each string in place. The function returns the modified vector with all strings reversed. No `main` function is included."}
{"name":"mbpp_457_Find_Min","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the subvector having minimum length.\nstd::vector<std::any> Find_Min(std::vector<std::vector<std::any>> lst) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_457_Find_Min.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = Find_Min;\n    assert(candidate((std::vector<std::vector<std::any>>({(std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})}))) == (std::vector<std::any>({(long)1})));\n    assert(candidate((std::vector<std::vector<std::any>>({(std::vector<long>)std::vector<long>({(long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)7, (long)8})}))) == (std::vector<std::any>({(long)1, (long)1})));\n    assert(candidate((std::vector<std::vector<std::any>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"x\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"x\", (std::string)\"y\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\"})}))) == (std::vector<std::any>({(std::string)\"x\"})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_457_Find_Min","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a cpp function to find the subvector having minimum length.\nstd::vector<std::any> Find_Min(std::vector<std::vector<std::any>> lst) {\n    \/\/ Ensure the input list is not empty\n    assert(!lst.empty());\n\n    \/\/ Initialize the result with the first subvector\n    std::vector<std::any> min_list = lst[0];\n    \n    \/\/ Iterate over the list of vectors to find the one with minimum length\n    for (const auto& sublist : lst) {\n        if (sublist.size() < min_list.size()) {\n            min_list = sublist;\n        }\n    }\n    \n    return min_list;\n}\n```"}
{"name":"mbpp_458_rectangle_area","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the area of a rectangle.\nlong rectangle_area(long l, long b) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_458_rectangle_area.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = rectangle_area;\n    assert(candidate((10), (20)) == (200));\n    assert(candidate((10), (5)) == (50));\n    assert(candidate((4), (2)) == (8));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_458_rectangle_area","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the area of a rectangle.\nlong rectangle_area(long l, long b) {\n    \/\/ The area of a rectangle is calculated as length * breadth.\n    return l * b;\n}\n```\n\nThis function `rectangle_area` takes the length and breadth of a rectangle as inputs and returns the area by multiplying the two values."}
{"name":"mbpp_459_remove_uppercase","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to remove uppercase substrings from a given string.\nstd::string remove_uppercase(std::string str1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_459_remove_uppercase.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = remove_uppercase;\n    assert(candidate((\"cAstyoUrFavoRitETVshoWs\")) == (\"cstyoravoitshos\"));\n    assert(candidate((\"wAtchTheinTernEtrAdIo\")) == (\"wtchheinerntrdo\"));\n    assert(candidate((\"VoicESeaRchAndreComMendaTionS\")) == (\"oiceachndreomendaion\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_459_remove_uppercase","gpt_solution":"```cpp\n#include <cassert>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to remove uppercase substrings from a given string.\nstd::string remove_uppercase(std::string str1) {\n    std::string result;\n    std::string temp;\n    \n    for (char c : str1) {\n        if (isupper(c)) {\n            if (!temp.empty()) {\n                result += temp;\n                temp.clear();\n            }\n            continue;\n        } else {\n            temp += c;\n        }\n    }\n\n    \/\/ Append any remaining lowercase substring.\n    if (!temp.empty()) {\n        result += temp;\n    }\n\n    return result;\n}\n```"}
{"name":"mbpp_460_Extract","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to get the first element of each subvector.\nstd::vector<long> Extract(std::vector<std::vector<long>> lst) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_460_Extract.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = Extract;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)7, (long)8, (long)9})}))) == (std::vector<long>({(long)1, (long)3, (long)6})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5})}))) == (std::vector<long>({(long)1, (long)4})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)9, (long)8, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2})}))) == (std::vector<long>({(long)9, (long)1})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_460_Extract","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cppthon function to get the first element of each subvector.\nstd::vector<long> Extract(std::vector<std::vector<long>> lst) {\n    std::vector<long> result;\n    for (const auto& subvector : lst) {\n        if (!subvector.empty()) {\n            result.push_back(subvector[0]);\n        }\n    }\n    return result;\n}\n```"}
{"name":"mbpp_461_upper_ctr","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to count the upper case characters in a given string.\nlong upper_ctr(std::string str) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_461_upper_ctr.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = upper_ctr;\n    assert(candidate((\"PYthon\")) == (1));\n    assert(candidate((\"BigData\")) == (1));\n    assert(candidate((\"program\")) == (0));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_461_upper_ctr","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to count the upper case characters in a given string.\nlong upper_ctr(std::string str) {\n    long count = 0;\n    for(char ch : str) {\n        if(isupper(ch)) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"name":"mbpp_462_combinations_list","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\nunion Union_std_vector_std_nullopt__std_vector_std_string_{\n    std::vector<std::nullopt> f0;\n    std::vector<std::string> f1;    Union_std_vector_std_nullopt__std_vector_std_string_(std::vector<std::nullopt> _f0) : f0(_f0) {}\n    Union_std_vector_std_nullopt__std_vector_std_string_(std::vector<std::string> _f1) : f1(_f1) {}\n    ~Union_std_vector_std_nullopt__std_vector_std_string_() {}\n    bool operator==(std::vector<std::nullopt> f) {\n        return f0 == f ;\n    }    bool operator==(std::vector<std::string> f) {\n        return f1 == f ;\n    }\n};\n\/\/ Write a function to find all possible combinations of the elements of a given vector.\nstd::vector<Union_std_vector_std_nullopt__std_vector_std_string_> combinations_list(std::vector<std::string> list1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_462_combinations_list.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = combinations_list;\n    assert(candidate((std::vector<std::string>({(std::string)\"orange\", (std::string)\"red\", (std::string)\"green\", (std::string)\"blue\"}))) == (std::vector<Union_std_vector_std_nullopt__std_vector_std_string_>({std::vector<long>(), std::vector<std::string>({(std::string)\"orange\"}), std::vector<std::string>({(std::string)\"red\"}), std::vector<std::string>({(std::string)\"red\", (std::string)\"orange\"}), std::vector<std::string>({(std::string)\"green\"}), std::vector<std::string>({(std::string)\"green\", (std::string)\"orange\"}), std::vector<std::string>({(std::string)\"green\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"green\", (std::string)\"red\", (std::string)\"orange\"}), std::vector<std::string>({(std::string)\"blue\"}), std::vector<std::string>({(std::string)\"blue\", (std::string)\"orange\"}), std::vector<std::string>({(std::string)\"blue\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"blue\", (std::string)\"red\", (std::string)\"orange\"}), std::vector<std::string>({(std::string)\"blue\", (std::string)\"green\"}), std::vector<std::string>({(std::string)\"blue\", (std::string)\"green\", (std::string)\"orange\"}), std::vector<std::string>({(std::string)\"blue\", (std::string)\"green\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"blue\", (std::string)\"green\", (std::string)\"red\", (std::string)\"orange\"})})));\n    assert(candidate((std::vector<std::string>({(std::string)\"red\", (std::string)\"green\", (std::string)\"blue\", (std::string)\"white\", (std::string)\"black\", (std::string)\"orange\"}))) == (std::vector<Union_std_vector_std_nullopt__std_vector_std_string_>({std::vector<long>(), std::vector<std::string>({(std::string)\"red\"}), std::vector<std::string>({(std::string)\"green\"}), std::vector<std::string>({(std::string)\"green\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"blue\"}), std::vector<std::string>({(std::string)\"blue\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"blue\", (std::string)\"green\"}), std::vector<std::string>({(std::string)\"blue\", (std::string)\"green\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"white\"}), std::vector<std::string>({(std::string)\"white\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"white\", (std::string)\"green\"}), std::vector<std::string>({(std::string)\"white\", (std::string)\"green\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"white\", (std::string)\"blue\"}), std::vector<std::string>({(std::string)\"white\", (std::string)\"blue\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"white\", (std::string)\"blue\", (std::string)\"green\"}), std::vector<std::string>({(std::string)\"white\", (std::string)\"blue\", (std::string)\"green\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"black\"}), std::vector<std::string>({(std::string)\"black\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"black\", (std::string)\"green\"}), std::vector<std::string>({(std::string)\"black\", (std::string)\"green\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"black\", (std::string)\"blue\"}), std::vector<std::string>({(std::string)\"black\", (std::string)\"blue\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"black\", (std::string)\"blue\", (std::string)\"green\"}), std::vector<std::string>({(std::string)\"black\", (std::string)\"blue\", (std::string)\"green\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"black\", (std::string)\"white\"}), std::vector<std::string>({(std::string)\"black\", (std::string)\"white\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"black\", (std::string)\"white\", (std::string)\"green\"}), std::vector<std::string>({(std::string)\"black\", (std::string)\"white\", (std::string)\"green\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"black\", (std::string)\"white\", (std::string)\"blue\"}), std::vector<std::string>({(std::string)\"black\", (std::string)\"white\", (std::string)\"blue\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"black\", (std::string)\"white\", (std::string)\"blue\", (std::string)\"green\"}), std::vector<std::string>({(std::string)\"black\", (std::string)\"white\", (std::string)\"blue\", (std::string)\"green\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"orange\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"green\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"green\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"blue\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"blue\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"blue\", (std::string)\"green\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"blue\", (std::string)\"green\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"white\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"white\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"white\", (std::string)\"green\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"white\", (std::string)\"green\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"white\", (std::string)\"blue\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"white\", (std::string)\"blue\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"white\", (std::string)\"blue\", (std::string)\"green\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"white\", (std::string)\"blue\", (std::string)\"green\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"black\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"black\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"black\", (std::string)\"green\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"black\", (std::string)\"green\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"black\", (std::string)\"blue\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"black\", (std::string)\"blue\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"black\", (std::string)\"blue\", (std::string)\"green\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"black\", (std::string)\"blue\", (std::string)\"green\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"black\", (std::string)\"white\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"black\", (std::string)\"white\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"black\", (std::string)\"white\", (std::string)\"green\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"black\", (std::string)\"white\", (std::string)\"green\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"black\", (std::string)\"white\", (std::string)\"blue\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"black\", (std::string)\"white\", (std::string)\"blue\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"black\", (std::string)\"white\", (std::string)\"blue\", (std::string)\"green\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"black\", (std::string)\"white\", (std::string)\"blue\", (std::string)\"green\", (std::string)\"red\"})})));\n    assert(candidate((std::vector<std::string>({(std::string)\"red\", (std::string)\"green\", (std::string)\"black\", (std::string)\"orange\"}))) == (std::vector<Union_std_vector_std_nullopt__std_vector_std_string_>({std::vector<long>(), std::vector<std::string>({(std::string)\"red\"}), std::vector<std::string>({(std::string)\"green\"}), std::vector<std::string>({(std::string)\"green\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"black\"}), std::vector<std::string>({(std::string)\"black\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"black\", (std::string)\"green\"}), std::vector<std::string>({(std::string)\"black\", (std::string)\"green\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"orange\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"green\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"green\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"black\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"black\", (std::string)\"red\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"black\", (std::string)\"green\"}), std::vector<std::string>({(std::string)\"orange\", (std::string)\"black\", (std::string)\"green\", (std::string)\"red\"})})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_462_combinations_list","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n#include <assert.h>\n\n\/\/ Define the union for possible compatibility with different vector types\nunion Union_std_vector_std_nullopt__std_vector_std_string_ {\n    std::vector<std::nullopt_t> f0;\n    std::vector<std::string> f1;\n    \n    Union_std_vector_std_nullopt__std_vector_std_string_(std::vector<std::nullopt_t> _f0) : f0(_f0) {}\n    Union_std_vector_std_nullopt__std_vector_std_string_(std::vector<std::string> _f1) : f1(_f1) {}\n    \n    ~Union_std_vector_std_nullopt__std_vector_std_string_() {}\n    \n    bool operator==(std::vector<std::nullopt_t> f) {\n        return f0 == f;\n    }\n    \n    bool operator==(std::vector<std::string> f) {\n        return f1 == f;\n    }\n};\n\n\/\/ Helper function to generate all combinations\nvoid combinations_helper(std::vector<std::string> &list, std::vector<std::string> &current, int start, std::vector<Union_std_vector_std_nullopt__std_vector_std_string_> &result) {\n    if (current.size() > 0) {\n        result.push_back(Union_std_vector_std_nullopt__std_vector_std_string_(current));\n    }\n    for (int i = start; i < list.size(); ++i) {\n        current.push_back(list[i]);\n        combinations_helper(list, current, i + 1, result);\n        current.pop_back();\n    }\n}\n\n\/\/ Function to find all possible combinations of elements of a given vector\nstd::vector<Union_std_vector_std_nullopt__std_vector_std_string_> combinations_list(std::vector<std::string> list1) {\n    std::vector<Union_std_vector_std_nullopt__std_vector_std_string_> result;\n    std::vector<std::string> current;\n    combinations_helper(list1, current, 0, result);\n    return result;\n}\n```"}
{"name":"mbpp_463_max_subarray_product","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the maximum product subvector of the given vector.\nlong max_subarray_product(std::vector<long> arr) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_463_max_subarray_product.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_463_max_subarray_product","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the maximum product subvector of the given vector.\nlong max_subarray_product(std::vector<long> arr) {\n    \/\/ Initialize variables to store the maximum product, minimum product, and the result\n    long max_product = arr[0];\n    long min_product = arr[0];\n    long result = arr[0];\n    \n    \/\/ Iterate through the array, starting from the second element\n    for (size_t i = 1; i < arr.size(); ++i) {\n        \/\/ If the current element is negative, swap the maximum and minimum products\n        if (arr[i] < 0) {\n            std::swap(max_product, min_product);\n        }\n        \n        \/\/ Update the maximum and minimum products for the current position\n        max_product = std::max(arr[i], max_product * arr[i]);\n        min_product = std::min(arr[i], min_product * arr[i]);\n        \n        \/\/ Update the result with the maximum product found so far\n        result = std::max(result, max_product);\n    }\n    \n    return result;\n}\n```"}
{"name":"mbpp_464_check_value","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check if all values are same in a map.\nbool check_value(std::map<std::string,long> dict, long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_464_check_value.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = check_value;\n    assert(candidate((std::map<std::string,long>({{\"Cierra Vega\", 12}, {\"Alden Cantrell\", 12}, {\"Kierra Gentry\", 12}, {\"Pierre Cox\", 12}})), (10)) == (false));\n    assert(candidate((std::map<std::string,long>({{\"Cierra Vega\", 12}, {\"Alden Cantrell\", 12}, {\"Kierra Gentry\", 12}, {\"Pierre Cox\", 12}})), (12)) == (true));\n    assert(candidate((std::map<std::string,long>({{\"Cierra Vega\", 12}, {\"Alden Cantrell\", 12}, {\"Kierra Gentry\", 12}, {\"Pierre Cox\", 12}})), (5)) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_464_check_value","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to check if all values are same in a map.\nbool check_value(std::map<std::string, long> dict, long n) {\n    for (const auto& pair : dict) {\n        if (pair.second != n) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"name":"mbpp_465_drop_empty","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to drop empty items from a given map.\nstd::map<std::string,std::string> drop_empty(std::map<std::string,std::optional<std::string>> dict1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_465_drop_empty.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = drop_empty;\n    assert(candidate(std::map<std::string,std::string>({{\"c1\", \"Red\"}, {\"c2\", \"Green\"}, {\"c3\", std::nullopt}})) == (std::map<std::string,std::string>({{\"c1\", \"Red\"}, {\"c2\", \"Green\"}})));\n    assert(candidate(std::map<std::string,std::string>({{\"c1\", \"Red\"}, {\"c2\", std::nullopt}, {\"c3\", std::nullopt}})) == (std::map<std::string,std::string>({{\"c1\", \"Red\"}})));\n    assert(candidate(std::map<std::string,std::nullopt>({{\"c1\", std::nullopt}, {\"c2\", \"Green\"}, {\"c3\", std::nullopt}})) == (std::map<std::string,std::string>({{\"c2\", \"Green\"}})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_465_drop_empty","gpt_solution":"```cpp\n#include <map>\n#include <string>\n#include <optional>\n#include <algorithm>\n#include <iterator>\n\nstd::map<std::string, std::string> drop_empty(std::map<std::string, std::optional<std::string>> dict1) {\n    std::map<std::string, std::string> result;\n\n    for (const auto& [key, value] : dict1) {\n        if (value.has_value() && !value->empty()) {\n            result[key] = value.value();\n        }\n    }\n\n    return result;\n}\n```"}
{"name":"mbpp_468_max_product","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_468_max_product.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_468_max_product","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0) return 0;\n\n    \/\/ dp[i] will store the maximum product subsequence ending at index i\n    std::vector<long> dp(n, 0);\n\n    \/\/ Initialize dp array with the values of arr\n    for (int i = 0; i < n; ++i) {\n        dp[i] = arr[i];\n    }\n    \n    long max_prod = arr[0];\n\n    \/\/ Fill dp array using the logic of longest increasing subsequence\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (arr[i] > arr[j] && dp[i] < dp[j] * arr[i]) {\n                dp[i] = dp[j] * arr[i];\n            }\n        }\n        max_prod = std::max(max_prod, dp[i]);\n    }\n\n    return max_prod;\n}\n```\n\nThis code defines a function `max_product` which takes a vector of long integers and returns the maximum product formed by multiplying numbers of an increasing subsequence of that vector. It uses dynamic programming to store the maximum product of increasing subsequences ending at each index and keeps track of the maximum product found."}
{"name":"mbpp_470_add_pairwise","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the pairwise addition of the neighboring elements of the given tuple.\nstd::tuple<long, long, long, long> add_pairwise(std::tuple<long, long, long, long, long> test_tup) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_470_add_pairwise.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = add_pairwise;\n    assert(candidate((std::make_tuple(1, 5, 7, 8, 10))) == (std::make_tuple(6, 12, 15, 18)));\n    assert(candidate((std::make_tuple(2, 6, 8, 9, 11))) == (std::make_tuple(8, 14, 17, 20)));\n    assert(candidate((std::make_tuple(3, 7, 9, 10, 12))) == (std::make_tuple(10, 16, 19, 22)));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_470_add_pairwise","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the pairwise addition of the neighboring elements of the given tuple.\nstd::tuple<long, long, long, long> add_pairwise(std::tuple<long, long, long, long, long> test_tup) {\n    long a, b, c, d, e;\n    std::tie(a, b, c, d, e) = test_tup;\n    \n    long sum1 = a + b;\n    long sum2 = b + c;\n    long sum3 = c + d;\n    long sum4 = d + e;\n    \n    return std::make_tuple(sum1, sum2, sum3, sum4);\n}\n```"}
{"name":"mbpp_471_find_remainder","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the product of the vector multiplication modulo n.\nlong find_remainder(std::vector<long> arr, long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_471_find_remainder.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_remainder;\n    assert(candidate((std::vector<long>({(long)100, (long)10, (long)5, (long)25, (long)35, (long)14})), (11)) == (9));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1})), (1)) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)1})), (2)) == (0));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_471_find_remainder","gpt_solution":"```cpp\n#include <vector>\n\n\/\/ Function to find the product of the vector multiplication modulo n.\nlong find_remainder(std::vector<long> arr, long n) {\n    \/\/ Initialize result as 1\n    long product = 1;\n\n    \/\/ Iterate over each element in the vector\n    for (long num : arr) {\n        product *= num;\n        product %= n; \/\/ Take modulo n at each multiplication step to avoid overflow\n    }\n\n    return product;\n}\n```\n\nThis code defines a function `find_remainder` that takes a vector of long integers and returns the product of the elements modulo `n`. The modulo operation ensures that the multiplication does not result in overflow and keeps the product within the bounds defined by the modulus `n`."}
{"name":"mbpp_472_check_Consecutive","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to check whether the given vector contains consecutive numbers or not.\nbool check_Consecutive(std::vector<long> l) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_472_check_Consecutive.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = check_Consecutive;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)6}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)1}))) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_472_check_Consecutive","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cpp function to check whether the given vector contains consecutive numbers or not.\nbool check_Consecutive(std::vector<long> l) {\n    if(l.size() < 2) return true;  \/\/ A vector with less than 2 elements is trivially consecutive\n\n    \/\/ Find the minimum and maximum values in the vector\n    auto min_max = std::minmax_element(l.begin(), l.end());\n    long min_val = *min_max.first;\n    long max_val = *min_max.second;\n    \n    \/\/ Check if the length of the vector matches the range of values\n    if (max_val - min_val + 1 != l.size()) return false;\n    \n    \/\/ Use a set to check for duplicates\n    std::unordered_set<long> unique_elements;\n    for (long num : l) {\n        if (!unique_elements.insert(num).second) {\n            \/\/ If insertion fails, it means there's a duplicate\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"name":"mbpp_474_replace_char","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to replace characters in a string.\nstd::string replace_char(std::string str1, std::string ch, std::string newch) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_474_replace_char.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = replace_char;\n    assert(candidate((\"polygon\"), (\"y\"), (\"l\")) == (\"pollgon\"));\n    assert(candidate((\"character\"), (\"c\"), (\"a\")) == (\"aharaater\"));\n    assert(candidate((\"python\"), (\"l\"), (\"a\")) == (\"python\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_474_replace_char","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to replace characters in a string.\nstd::string replace_char(std::string str1, std::string ch, std::string newch) {\n    size_t pos = 0;\n    while ((pos = str1.find(ch, pos)) != std::string::npos) {\n        str1.replace(pos, ch.length(), newch);\n        pos += newch.length(); \/\/ Move past the last replaced character\n    }\n    return str1;\n}\n\n\/\/ Example usage\nint main() {\n    std::string original = \"hello world\";\n    std::string result = replace_char(original, \"world\", \"there\");\n    assert(result == \"hello there\");\n\n    original = \"aabbaabb\";\n    result = replace_char(original, \"aa\", \"xx\");\n    assert(result == \"xxbbxxbb\");\n\n    original = \"testing\";\n    result = replace_char(original, \"test\", \"TEST\");\n    assert(result == \"TESTing\");\n\n    original = \"123123123\";\n    result = replace_char(original, \"123\", \"abc\");\n    assert(result == \"abcabcabc\");\n\n    return 0;\n}\n```\n\nThis example includes the function `replace_char` which replaces all occurrences of a substring (`ch`) with another substring (`newch`) within the given string (`str1`). The `main` function is provided for demonstration purposed, but should be removed if you need the `replace_char` function without it."}
{"name":"mbpp_475_sort_counter","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to sort a map by value.\nstd::vector<std::tuple<std::string, long>> sort_counter(std::map<std::string,long> dict1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_475_sort_counter.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sort_counter;\n    assert(candidate((std::map<std::string,long>({{\"Math\", 81}, {\"Physics\", 83}, {\"Chemistry\", 87}}))) == (std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Chemistry\", 87), (std::tuple<std::string, long>)std::make_tuple(\"Physics\", 83), (std::tuple<std::string, long>)std::make_tuple(\"Math\", 81)})));\n    assert(candidate((std::map<std::string,long>({{\"Math\", 400}, {\"Physics\", 300}, {\"Chemistry\", 250}}))) == (std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Math\", 400), (std::tuple<std::string, long>)std::make_tuple(\"Physics\", 300), (std::tuple<std::string, long>)std::make_tuple(\"Chemistry\", 250)})));\n    assert(candidate((std::map<std::string,long>({{\"Math\", 900}, {\"Physics\", 1000}, {\"Chemistry\", 1250}}))) == (std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Chemistry\", 1250), (std::tuple<std::string, long>)std::make_tuple(\"Physics\", 1000), (std::tuple<std::string, long>)std::make_tuple(\"Math\", 900)})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_475_sort_counter","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to sort a map by value.\nstd::vector<std::tuple<std::string, long>> sort_counter(std::map<std::string, long> dict1) {\n    \/\/ Convert map to vector of tuples\n    std::vector<std::tuple<std::string, long>> vec;\n    for (const auto &pair : dict1) {\n        vec.push_back(std::make_tuple(pair.first, pair.second));\n    }\n\n    \/\/ Sort the vector by value (second item in the tuple)\n    std::sort(vec.begin(), vec.end(), [](const std::tuple<std::string, long> &a, const std::tuple<std::string, long> &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n\n    return vec;\n}\n```\n\nThis code defines the function `sort_counter` which accepts a map `dict1` with keys of type `std::string` and values of type `long`. The function converts the map to a vector of tuples, sorts the vector by value in descending order, and then returns the sorted vector."}
{"name":"mbpp_476_big_sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the sum of the largest and smallest value in a given vector.\nlong big_sum(std::vector<long> nums) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_476_big_sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = big_sum;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (4));\n    assert(candidate((std::vector<long>({(long)-1, (long)2, (long)3, (long)4}))) == (3));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)6}))) == (8));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_476_big_sum","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Function to find the sum of the largest and smallest value in a given vector.\nlong big_sum(std::vector<long> nums) {\n    if (nums.empty()) {\n        throw std::invalid_argument(\"The input vector must not be empty.\");\n    }\n\n    long min_val = *std::min_element(nums.begin(), nums.end());\n    long max_val = *std::max_element(nums.begin(), nums.end());\n\n    return min_val + max_val;\n}\n```"}
{"name":"mbpp_477_is_lower","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to convert the given string to lower case.\nstd::string is_lower(std::string string) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_477_is_lower.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = is_lower;\n    assert(candidate((\"InValid\")) == (\"invalid\"));\n    assert(candidate((\"TruE\")) == (\"true\"));\n    assert(candidate((\"SenTenCE\")) == (\"sentence\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_477_is_lower","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to convert the given string to lower case.\nstd::string to_lower(std::string input) {\n    std::string result = input;\n    for (char &c : result) {\n        c = std::tolower(c);\n    }\n    return result;\n}\n\n\/\/ Test cases\nint main() {\n    assert(to_lower(\"HELLO\") == \"hello\");\n    assert(to_lower(\"World\") == \"world\");\n    assert(to_lower(\"CppIsFun\") == \"cppisfun\");\n}\n```"}
{"name":"mbpp_478_remove_lowercase","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to remove lowercase substrings from a given string.\nstd::string remove_lowercase(std::string str1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_478_remove_lowercase.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = remove_lowercase;\n    assert(candidate((\"PYTHon\")) == (\"PYTH\"));\n    assert(candidate((\"FInD\")) == (\"FID\"));\n    assert(candidate((\"STRinG\")) == (\"STRG\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_478_remove_lowercase","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to remove lowercase substrings from a given string.\nstd::string remove_lowercase(std::string str1) {\n    std::string result;\n    bool in_lowercase_substring = false;\n\n    for (char c : str1) {\n        if (std::islower(c)) {\n            in_lowercase_substring = true;\n        } else {\n            if (in_lowercase_substring) {\n                in_lowercase_substring = false;\n            }\n            result += c;\n        }\n    }\n\n    return result;\n}\n```\n\nThis code will remove lowercase substrings from the input string `str1`. If a lowercase character is detected, the function will skip it; otherwise, it adds the character to the result string."}
{"name":"mbpp_479_first_Digit","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the first digit of a given number.\nlong first_Digit(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_479_first_Digit.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = first_Digit;\n    assert(candidate((123)) == (1));\n    assert(candidate((456)) == (4));\n    assert(candidate((12)) == (1));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_479_first_Digit","gpt_solution":"```cpp\n#include <cassert>\n#include <bits\/stdc++.h>\n\n\/\/ Function to find the first digit of a given number.\nlong first_Digit(long n) {\n    \/\/ Make sure n is positive \n    n = abs(n);\n    \n    \/\/ Continue to divide n by 10 until it is less than 10\n    \/\/ This means we are left with the first digit\n    while (n >= 10) {\n        n \/= 10;\n    }\n    \n    return n;\n}\n```"}
{"name":"mbpp_554_Split","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function which takes a vector of integers and only returns the odd ones.\nstd::vector<long> Split(std::vector<long> list) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_554_Split.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = Split;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}))) == (std::vector<long>({(long)1, (long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)10, (long)11, (long)12, (long)13}))) == (std::vector<long>({(long)11, (long)13})));\n    assert(candidate((std::vector<long>({(long)7, (long)8, (long)9, (long)1}))) == (std::vector<long>({(long)7, (long)9, (long)1})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_554_Split","gpt_solution":"```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<long> Split(const std::vector<long>& list) {\n    std::vector<long> oddNumbers;\n    \n    \/\/ Iterate through the list and add odd numbers to the oddNumbers vector\n    for (long num : list) {\n        if (num % 2 != 0) {\n            oddNumbers.push_back(num);\n        }\n    }\n    \n    return oddNumbers;\n}\n```"}
{"name":"mbpp_555_difference","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers.\nlong difference(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_555_difference.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = difference;\n    assert(candidate((3)) == (30));\n    assert(candidate((5)) == (210));\n    assert(candidate((2)) == (6));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_555_difference","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to find the difference between the sum of cubes of the first n natural numbers\n\/\/ and the sum of the first n natural numbers.\nlong difference(long n) {\n    \/\/ Sum of the first n natural numbers\n    long sum_n = n * (n + 1) \/ 2;\n    \n    \/\/ Sum of the cubes of the first n natural numbers\n    long sum_cubes_n = (sum_n * sum_n); \/\/ Using formula: (n*(n+1)\/2)^2\n    \n    \/\/ Difference between the sum of cubes and the sum of the first n natural numbers\n    long diff = sum_cubes_n - sum_n;\n    \n    return diff;\n}\n```"}
{"name":"mbpp_556_find_Odd_Pair","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to count the number of pairs whose xor value is odd.\nlong find_Odd_Pair(std::vector<long> A, long N) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_556_find_Odd_Pair.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_Odd_Pair;\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)7, (long)2, (long)1})), (5)) == (6));\n    assert(candidate((std::vector<long>({(long)7, (long)2, (long)8, (long)1, (long)0, (long)5, (long)11})), (7)) == (12));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (3)) == (2));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_556_find_Odd_Pair","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to count the number of pairs whose xor value is odd.\nlong find_Odd_Pair(std::vector<long> A, long N) {\n    \/\/ Count of odd numbers\n    long odd_count = 0;\n    \/\/ Count of even numbers\n    long even_count = 0;\n    \n    \/\/ Iterate through the array to count odd and even numbers\n    for(long i = 0; i < N; i++) {\n        if(A[i] % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    \n    \/\/ Number of pairs having odd xor value\n    \/\/ An XOR value is odd when one number is odd and the other is even\n    return odd_count * even_count;\n}\n```"}
{"name":"mbpp_557_toggle_string","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to toggle the case of all characters in a string.\nstd::string toggle_string(std::string string) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_557_toggle_string.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = toggle_string;\n    assert(candidate((\"Python\")) == (\"pYTHON\"));\n    assert(candidate((\"Pangram\")) == (\"pANGRAM\"));\n    assert(candidate((\"LIttLE\")) == (\"liTTle\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_557_toggle_string","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to toggle the case of all characters in a string.\nstd::string toggle_string(std::string str) {\n    for (size_t i = 0; i < str.size(); ++i) {\n        \/\/ Check if the character is lowercase, if yes convert to uppercase\n        if (str[i] >= 'a' && str[i] <= 'z') {\n            str[i] = str[i] - 'a' + 'A';\n        }\n        \/\/ Check if the character is uppercase, if yes convert to lowercase\n        else if (str[i] >= 'A' && str[i] <= 'Z') {\n            str[i] = str[i] - 'A' + 'a';\n        }\n    }\n    return str;\n}\n```"}
{"name":"mbpp_558_digit_distance_nums","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the sum of the per-digit difference between two integers.\nlong digit_distance_nums(long n1, long n2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_558_digit_distance_nums.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = digit_distance_nums;\n    assert(candidate((1), (2)) == (1));\n    assert(candidate((23), (56)) == (6));\n    assert(candidate((123), (256)) == (7));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_558_digit_distance_nums","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Function to find the sum of the per-digit difference between two integers\nlong digit_distance_nums(long n1, long n2) {\n    long sum = 0;\n\n    \/\/ Ensure both numbers have the same number of digits by padding with zeros\n    std::string str_n1 = std::to_string(n1),\n                str_n2 = std::to_string(n2);\n\n    \/\/ Padding with leading zeros if necessary\n    while (str_n1.length() < str_n2.length()) {\n        str_n1 = '0' + str_n1;\n    }\n    while (str_n2.length() < str_n1.length()) {\n        str_n2 = '0' + str_n2;\n    }\n\n    \/\/ Calculate the per-digit difference and accumulate the sum\n    for (size_t i = 0; i < str_n1.length(); ++i) {\n        sum += std::abs(str_n1[i] - str_n2[i]);\n    }\n\n    return sum;\n}\n```"}
{"name":"mbpp_559_max_sub_array_sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the sum of the largest contiguous subvector in the given vector.\nlong max_sub_array_sum(std::vector<long> a, long size) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_559_max_sub_array_sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = max_sub_array_sum;\n    assert(candidate((std::vector<long>({(long)-2, (long)-3, (long)4, (long)-1, (long)-2, (long)1, (long)5, (long)-3})), (8)) == (7));\n    assert(candidate((std::vector<long>({(long)-3, (long)-4, (long)5, (long)-2, (long)-3, (long)2, (long)6, (long)-4})), (8)) == (8));\n    assert(candidate((std::vector<long>({(long)-4, (long)-5, (long)6, (long)-3, (long)-4, (long)3, (long)7, (long)-5})), (8)) == (10));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_559_max_sub_array_sum","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to find the sum of the largest contiguous subvector in the given vector.\nlong max_sub_array_sum(std::vector<long> a, long size) {\n    long max_so_far = LONG_MIN, max_ending_here = 0;\n\n    for (long i = 0; i < size; i++) {\n        max_ending_here += a[i];\n        \n        if (max_so_far < max_ending_here)\n            max_so_far = max_ending_here;\n\n        if (max_ending_here < 0)\n            max_ending_here = 0;\n    }\n\n    return max_so_far;\n}\n\n\/\/ Example usage\n\/\/ int main() {\n\/\/     std::vector<long> vec = {-2, -3, 4, -1, -2, 1, 5, -3};\n\/\/     long size = vec.size();\n\/\/     assert(max_sub_array_sum(vec, size) == 7);\n\/\/     return 0;\n\/\/ }\n```"}
{"name":"mbpp_560_union_elements","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the union of the elements of two given vectors and output them in sorted order.\nstd::vector<long> union_elements(std::vector<long> test_tup1, std::vector<long> test_tup2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_560_union_elements.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = union_elements;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)5, (long)7, (long)4, (long)10}))) == (std::vector<long>({(long)3, (long)4, (long)5, (long)6, (long)7, (long)10})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)3, (long)4, (long)5, (long)6}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})));\n    assert(candidate((std::vector<long>({(long)11, (long)12, (long)13, (long)14})), (std::vector<long>({(long)13, (long)15, (long)16, (long)17}))) == (std::vector<long>({(long)11, (long)12, (long)13, (long)14, (long)15, (long)16, (long)17})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_560_union_elements","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to find the union of the elements of two given vectors and output them in sorted order.\nstd::vector<long> union_elements(std::vector<long> test_tup1, std::vector<long> test_tup2) {\n    \/\/ Combine the two vectors\n    std::vector<long> combined = test_tup1;\n    combined.insert(combined.end(), test_tup2.begin(), test_tup2.end());\n\n    \/\/ Sort the combined vector\n    std::sort(combined.begin(), combined.end());\n\n    \/\/ Remove duplicates\n    auto last = std::unique(combined.begin(), combined.end());\n    combined.erase(last, combined.end());\n\n    return combined;\n}\n```"}
{"name":"mbpp_562_Find_Max_Length","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the length of the longest subvectors.\nlong Find_Max_Length(std::vector<std::vector<long>> lst) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_562_Find_Max_Length.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = Find_Max_Length;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7, (long)8})}))) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)1}), (std::vector<long>)std::vector<long>({(long)2, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)2, (long)1})}))) == (3));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)7}), (std::vector<long>)std::vector<long>({(long)22, (long)23}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15}), (std::vector<long>)std::vector<long>({(long)10, (long)20, (long)30, (long)40, (long)50})}))) == (5));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_562_Find_Max_Length","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\nlong Find_Max_Length(std::vector<std::vector<long>> lst) {\n    long max_length = 0;\n    for(const auto& subvector : lst) {\n        if(subvector.size() > max_length) {\n            max_length = subvector.size();\n        }\n    }\n    return max_length;\n}\n```"}
{"name":"mbpp_563_extract_values","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to extract values between quotation marks from a string.\nstd::vector<std::string> extract_values(std::string text) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_563_extract_values.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = extract_values;\n    assert(candidate((\"\"Python\", \"PHP\", \"Java\"\")) == (std::vector<std::string>({(std::string)\"Python\", (std::string)\"PHP\", (std::string)\"Java\"})));\n    assert(candidate((\"\"python\",\"program\",\"language\"\")) == (std::vector<std::string>({(std::string)\"python\", (std::string)\"program\", (std::string)\"language\"})));\n    assert(candidate((\"\"red\",\"blue\",\"green\",\"yellow\"\")) == (std::vector<std::string>({(std::string)\"red\", (std::string)\"blue\", (std::string)\"green\", (std::string)\"yellow\"})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_563_extract_values","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to extract values between quotation marks from a string.\nstd::vector<std::string> extract_values(std::string text) {\n    std::vector<std::string> result;\n    std::string current_value;\n    bool in_quotes = false;\n\n    for (char c : text) {\n        if (c == '\"') {\n            if (in_quotes) {\n                result.push_back(current_value);\n                current_value.clear();\n            }\n            in_quotes = !in_quotes;\n        } else if (in_quotes) {\n            current_value += c;\n        }\n    }\n\n    return result;\n}\n```"}
{"name":"mbpp_564_count_Pairs","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function which takes a vector of integers and counts the number of possible unordered pairs where both elements are unequal.\nlong count_Pairs(std::vector<long> arr, long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_564_count_Pairs.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = count_Pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)1})), (3)) == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1})), (4)) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})), (5)) == (10));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_564_count_Pairs","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function which takes a vector of integers and counts the number of possible unordered pairs where both elements are unequal.\nlong count_Pairs(std::vector<long> arr, long n) {\n    \/\/ Initialize a map to store the frequency of each element\n    std::unordered_map<long, long> freq;\n    \n    \/\/ Calculate the frequency of each element in the array\n    for(long i = 0; i < n; ++i) {\n        freq[arr[i]]++;\n    }\n    \n    \/\/ Calculate the total number of pairs\n    long totalPairs = n * (n - 1) \/ 2;\n    \n    \/\/ Subtract the number of pairs where both elements are equal\n    for(auto& it : freq) {\n        if(it.second > 1) {\n            totalPairs -= (it.second * (it.second - 1) \/ 2);\n        }\n    }\n        \n    return totalPairs;\n}\n```"}
{"name":"mbpp_565_split","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to split a string into characters.\nstd::vector<std::string> split(std::string word) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_565_split.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = split;\n    assert(candidate((\"python\")) == (std::vector<std::string>({(std::string)\"p\", (std::string)\"y\", (std::string)\"t\", (std::string)\"h\", (std::string)\"o\", (std::string)\"n\"})));\n    assert(candidate((\"Name\")) == (std::vector<std::string>({(std::string)\"N\", (std::string)\"a\", (std::string)\"m\", (std::string)\"e\"})));\n    assert(candidate((\"program\")) == (std::vector<std::string>({(std::string)\"p\", (std::string)\"r\", (std::string)\"o\", (std::string)\"g\", (std::string)\"r\", (std::string)\"a\", (std::string)\"m\"})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_565_split","gpt_solution":"```cpp\n#include <vector>\n#include <string>\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a cpp function to split a string into characters.\nstd::vector<std::string> split(std::string word) {\n    std::vector<std::string> result;\n    for(char ch : word) {\n        result.push_back(std::string(1, ch));\n    }\n    return result;\n}\n```"}
{"name":"mbpp_566_sum_digits","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to get the sum of the digits of a non-negative integer.\nlong sum_digits(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_566_sum_digits.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sum_digits;\n    assert(candidate((345)) == (12));\n    assert(candidate((12)) == (3));\n    assert(candidate((97)) == (16));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_566_sum_digits","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to get the sum of the digits of a non-negative integer.\nlong sum_digits(long n) {\n    long sum = 0;\n    while (n > 0) {\n        sum += n % 10;  \/\/ Add the last digit to the sum\n        n \/= 10;        \/\/ Remove the last digit\n    }\n    return sum;\n}\n```\n\nThis code defines a function `sum_digits` that computes the sum of the digits of a non-negative integer. It repeatedly extracts the last digit of the number using the modulus operator, adds it to the sum, and then removes the last digit by dividing the number by 10. This process continues until the number becomes zero, and the sum of the digits is returned."}
{"name":"mbpp_567_issort_list","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check whether a specified vector is sorted or not.\nbool issort_list(std::vector<long> list1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_567_issort_list.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = issort_list;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)6, (long)8, (long)10, (long)12, (long)14, (long)16, (long)17}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)6, (long)8, (long)10, (long)12, (long)14, (long)20, (long)17}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)6, (long)8, (long)10, (long)15, (long)14, (long)20}))) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_567_issort_list","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to check whether a specified vector is sorted or not.\nbool issort_list(std::vector<long> list1) {\n    for (size_t i = 1; i < list1.size(); ++i) {\n        if (list1[i] < list1[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"name":"mbpp_568_empty_list","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to create a vector of N empty dictionaries.\nstd::vector<std::map<std::nullopt,std::nullopt>> empty_list(long length) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_568_empty_list.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = empty_list;\n    assert(candidate((5)) == (std::vector<std::map<std::nullopt,std::nullopt>>({(std::map<long,long>)std::map<long,long>(), (std::map<long,long>)std::map<long,long>(), (std::map<long,long>)std::map<long,long>(), (std::map<long,long>)std::map<long,long>(), (std::map<long,long>)std::map<long,long>()})));\n    assert(candidate((6)) == (std::vector<std::map<std::nullopt,std::nullopt>>({(std::map<long,long>)std::map<long,long>(), (std::map<long,long>)std::map<long,long>(), (std::map<long,long>)std::map<long,long>(), (std::map<long,long>)std::map<long,long>(), (std::map<long,long>)std::map<long,long>(), (std::map<long,long>)std::map<long,long>()})));\n    assert(candidate((7)) == (std::vector<std::map<std::nullopt,std::nullopt>>({(std::map<long,long>)std::map<long,long>(), (std::map<long,long>)std::map<long,long>(), (std::map<long,long>)std::map<long,long>(), (std::map<long,long>)std::map<long,long>(), (std::map<long,long>)std::map<long,long>(), (std::map<long,long>)std::map<long,long>(), (std::map<long,long>)std::map<long,long>()})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_568_empty_list","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to create a vector of N empty dictionaries.\nstd::vector<std::map<int, int>> empty_list(long length) {\n    \/\/ Vector of maps\n    std::vector<std::map<int, int>> result(length); \n    return result;\n}\n```"}
{"name":"mbpp_569_sort_sublists","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to sort each subvector of strings in a given vector of vectors.\nstd::vector<std::vector<std::string>> sort_sublists(std::vector<std::vector<std::string>> list1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_569_sort_sublists.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sort_sublists;\n    assert(candidate((std::vector<std::vector<std::string>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"green\", (std::string)\"orange\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"black\", (std::string)\"white\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"white\", (std::string)\"black\", (std::string)\"orange\"})}))) == (std::vector<std::vector<std::string>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"green\", (std::string)\"orange\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"black\", (std::string)\"white\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"black\", (std::string)\"orange\", (std::string)\"white\"})})));\n    assert(candidate((std::vector<std::vector<std::string>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"green\", (std::string)\"orange\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"black\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"green\", (std::string)\"orange\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"white\"})}))) == (std::vector<std::vector<std::string>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"green\", (std::string)\"orange\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"black\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"green\", (std::string)\"orange\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"white\"})})));\n    assert(candidate((std::vector<std::vector<std::string>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"a\", (std::string)\"b\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"d\", (std::string)\"c\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"g\", (std::string)\"h\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"f\", (std::string)\"e\"})}))) == (std::vector<std::vector<std::string>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"a\", (std::string)\"b\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"c\", (std::string)\"d\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"g\", (std::string)\"h\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"e\", (std::string)\"f\"})})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_569_sort_sublists","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to sort each subvector of strings in a given vector of vectors.\nstd::vector<std::vector<std::string>> sort_sublists(std::vector<std::vector<std::string>> list1) {\n    for(auto &sublist : list1) {\n        std::sort(sublist.begin(), sublist.end());\n    }\n    return list1;\n}\n```"}
{"name":"mbpp_572_two_unique_nums","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to remove duplicate numbers from a given number of vectors.\nstd::vector<long> two_unique_nums(std::vector<long> nums) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_572_two_unique_nums.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = two_unique_nums;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)5})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)3, (long)4, (long)5})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_572_two_unique_nums","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n\n\/\/ Function to remove duplicate numbers from a given vector and return unique numbers\nstd::vector<long> two_unique_nums(std::vector<long> nums) {\n    std::unordered_set<long> unique_nums_set;\n    std::vector<long> unique_nums_vector;\n\n    \/\/ Insert elements into the unordered_set to remove duplicates\n    for (long num : nums) {\n        unique_nums_set.insert(num);\n    }\n\n    \/\/ Copy unique elements to the vector\n    for (long num : unique_nums_set) {\n        unique_nums_vector.push_back(num);\n    }\n\n    \/\/ Return the vector containing unique numbers\n    return unique_nums_vector;\n}\n```"}
{"name":"mbpp_573_unique_product","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to calculate the product of the unique numbers in a given vector.\nlong unique_product(std::vector<long> list_data) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_573_unique_product.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = unique_product;\n    assert(candidate((std::vector<long>({(long)10, (long)20, (long)30, (long)40, (long)20, (long)50, (long)60, (long)40}))) == (720000000));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)1}))) == (6));\n    assert(candidate((std::vector<long>({(long)7, (long)8, (long)9, (long)0, (long)1, (long)1}))) == (0));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_573_unique_product","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cpp function to calculate the product of the unique numbers in a given vector.\nlong unique_product(std::vector<long> list_data) {\n    std::set<long> unique_numbers(list_data.begin(), list_data.end());\n    long product = 1;\n    for (long num : unique_numbers) {\n        product *= num;\n    }\n    return product;\n}\n\n\/\/ Test cases\nvoid test_unique_product() {\n    assert(unique_product({1, 2, 2, 3, 4}) == 24);\n    assert(unique_product({5, 6, 6, 7, 5}) == 210);\n    assert(unique_product({6, 6, 6}) == 6);\n    assert(unique_product({}) == 1);\n    assert(unique_product({0, 1, 2, 3}) == 0);\n    assert(unique_product({1, 2, 3}) == 6);\n}\n\n\/\/ Run the test cases\nint main() {\n    test_unique_product();\n    std::cout << \"All test cases passed!\" << std::endl;\n    return 0;\n}\n```"}
{"name":"mbpp_574_surfacearea_cylinder","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the surface area of a cylinder.\nfloat surfacearea_cylinder(long r, long h) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_574_surfacearea_cylinder.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = surfacearea_cylinder;\n    assert(candidate((10), (5)) == (942.45f));\n    assert(candidate((4), (5)) == (226.18800000000002f));\n    assert(candidate((4), (10)) == (351.848f));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_574_surfacearea_cylinder","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the surface area of a cylinder.\nfloat surfacearea_cylinder(long r, long h) {\n    \/\/ Surface area of cylinder = 2 * pi * r * (r + h)\n    const float pi = 3.14159265358979323846;\n    float surface_area = 2 * pi * r * (r + h);\n    return surface_area;\n}\n```"}
{"name":"mbpp_576_is_Sub_Array","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to check whether a vector is subvector of another or not.\nbool is_Sub_Array(std::vector<long> A, std::vector<long> B) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_576_is_Sub_Array.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = is_Sub_Array;\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)3, (long)5})), (std::vector<long>({(long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)1})), (std::vector<long>({(long)1, (long)2, (long)1}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)2, (long)2})), (std::vector<long>({(long)2, (long)2, (long)0}))) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_576_is_Sub_Array","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Function to check whether a vector is subvector of another or not.\nbool is_Sub_Array(std::vector<long> A, std::vector<long> B) {\n    if (B.size() > A.size()) return false;\n    \n    for (size_t i = 0; i <= A.size() - B.size(); ++i) {\n        bool isSubArray = true;\n        for (size_t j = 0; j < B.size(); ++j) {\n            if (A[i + j] != B[j]) {\n                isSubArray = false;\n                break;\n            }\n        }\n        if (isSubArray) return true;\n    }\n    return false;\n}\n```"}
{"name":"mbpp_577_last_Digit_Factorial","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the last digit in factorial of a given number.\nlong last_Digit_Factorial(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_577_last_Digit_Factorial.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = last_Digit_Factorial;\n    assert(candidate((4)) == (4));\n    assert(candidate((21)) == (0));\n    assert(candidate((30)) == (0));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_577_last_Digit_Factorial","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Write a cpp function to find the last digit in factorial of a given number.\nlong last_Digit_Factorial(long n) {\n    \/\/ If n is 0 or 1, the factorial is 1 and last digit is also 1\n    if (n == 0 || n == 1)\n        return 1;\n\n    \/\/ If n is greater than or equal to 5, the factorial will have at least one trailing zero\n    \/\/ Hence, last non-zero digit would be 0\n    if (n >= 5)\n        return 0;\n\n    \/\/ Compute factorial for n < 5\n    long factorial = 1;\n    for (long i = 1; i <= n; ++i)\n        factorial *= i;\n    \n    \/\/ Return the last digit of the computed factorial\n    return factorial % 10;\n}\n\n\/\/ Test cases to validate the solution\nvoid test() {\n    assert(last_Digit_Factorial(0) == 1);\n    assert(last_Digit_Factorial(1) == 1);\n    assert(last_Digit_Factorial(2) == 2);\n    assert(last_Digit_Factorial(3) == 6);\n    assert(last_Digit_Factorial(4) == 4);\n    assert(last_Digit_Factorial(5) == 0);\n    assert(last_Digit_Factorial(6) == 0);\n    assert(last_Digit_Factorial(7) == 0);\n    assert(last_Digit_Factorial(10) == 0);\n    assert(last_Digit_Factorial(20) == 0);\n    \/\/ Add more test cases if necessary\n}\n\nint main() {\n    test();\n    cout << \"All test cases passed!\" << endl;\n    return 0;\n}\n```"}
{"name":"mbpp_578_interleave_lists","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to interleave 3 vectors of the same length into a single flat vector.\nstd::vector<long> interleave_lists(std::vector<long> list1, std::vector<long> list2, std::vector<long> list3) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_578_interleave_lists.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = interleave_lists;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})), (std::vector<long>({(long)10, (long)20, (long)30, (long)40, (long)50, (long)60, (long)70})), (std::vector<long>({(long)100, (long)200, (long)300, (long)400, (long)500, (long)600, (long)700}))) == (std::vector<long>({(long)1, (long)10, (long)100, (long)2, (long)20, (long)200, (long)3, (long)30, (long)300, (long)4, (long)40, (long)400, (long)5, (long)50, (long)500, (long)6, (long)60, (long)600, (long)7, (long)70, (long)700})));\n    assert(candidate((std::vector<long>({(long)10, (long)20})), (std::vector<long>({(long)15, (long)2})), (std::vector<long>({(long)5, (long)10}))) == (std::vector<long>({(long)10, (long)15, (long)5, (long)20, (long)2, (long)10})));\n    assert(candidate((std::vector<long>({(long)11, (long)44})), (std::vector<long>({(long)10, (long)15})), (std::vector<long>({(long)20, (long)5}))) == (std::vector<long>({(long)11, (long)10, (long)20, (long)44, (long)15, (long)5})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_578_interleave_lists","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to interleave 3 vectors of the same length into a single flat vector.\nstd::vector<long> interleave_lists(std::vector<long> list1, std::vector<long> list2, std::vector<long> list3) {\n    assert(list1.size() == list2.size() && list2.size() == list3.size());\n    \n    std::vector<long> result;\n    result.reserve(list1.size() * 3);\n    \n    for (size_t i = 0; i < list1.size(); ++i) {\n        result.push_back(list1[i]);\n        result.push_back(list2[i]);\n        result.push_back(list3[i]);\n    }\n    \n    return result;\n}\n```"}
{"name":"mbpp_579_find_dissimilar","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the dissimilar elements in the given two tuples.\nstd::tuple<long, long, long, long> find_dissimilar(std::tuple<long, long, long, long> test_tup1, std::tuple<long, long, long, long> test_tup2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_579_find_dissimilar.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_dissimilar;\n    assert(candidate((std::make_tuple(3, 4, 5, 6)), (std::make_tuple(5, 7, 4, 10))) == (std::make_tuple(3, 6, 7, 10)));\n    assert(candidate((std::make_tuple(1, 2, 3, 4)), (std::make_tuple(7, 2, 3, 9))) == (std::make_tuple(1, 4, 7, 9)));\n    assert(candidate((std::make_tuple(21, 11, 25, 26)), (std::make_tuple(26, 34, 21, 36))) == (std::make_tuple(34, 36, 11, 25)));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_579_find_dissimilar","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Function to find the dissimilar elements in the given two tuples.\nstd::tuple<long, long, long, long> find_dissimilar(std::tuple<long, long, long, long> test_tup1, std::tuple<long, long, long, long> test_tup2) {\n    std::vector<long> t1 = { std::get<0>(test_tup1), std::get<1>(test_tup1), std::get<2>(test_tup1), std::get<3>(test_tup1) };\n    std::vector<long> t2 = { std::get<0>(test_tup2), std::get<1>(test_tup2), std::get<2>(test_tup2), std::get<3>(test_tup2) };\n    std::vector<long> result;\n\n    for (int i = 0; i < 4; ++i) {\n        if (t1[i] != t2[i]) {\n            result.push_back(t1[i]);\n        }\n    }\n\n    \/\/ Fill with zeros if dissimilar elements are less than 4\n    while (result.size() < 4) {\n        result.push_back(0);\n    }\n\n    return std::make_tuple(result[0], result[1], result[2], result[3]);\n}\n```"}
{"name":"mbpp_580_extract_even","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to remove uneven elements in the nested mixed tuple.\nstd::any extract_even(std::tuple<long, long, std::tuple<long, long, std::tuple<long, long>>, long, long> test_tuple) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_580_extract_even.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = extract_even;\n    assert(candidate((std::make_tuple(4, 5, std::make_tuple(7, 6, std::make_tuple(2, 4)), 6, 8))) == std::make_tuple(4, std::make_tuple(6, std::make_tuple(2, 4)), 6, 8));\n    assert(candidate((std::make_tuple(5, 6, std::make_tuple(8, 7, std::make_tuple(4, 8)), 7, 9))) == std::make_tuple(6, std::make_tuple(8, std::make_tuple(4, 8))));\n    assert(candidate((std::make_tuple(5, 6, std::make_tuple(9, 8, std::make_tuple(4, 6)), 8, 10))) == std::make_tuple(6, std::make_tuple(8, std::make_tuple(4, 6)), 8, 10));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_580_extract_even","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Recursive function to remove uneven elements in the nested mixed tuple.\ntemplate <std::size_t I = 0, typename... Tp>\ntypename std::enable_if<I == sizeof...(Tp), std::tuple<Tp...>>::type\nextract_even_impl(std::tuple<Tp...> t) {\n    return t;\n}\n\ntemplate <std::size_t I = 0, typename... Tp>\ntypename std::enable_if<I < sizeof...(Tp), std::tuple<Tp...>>::type\nextract_even_impl(std::tuple<Tp...> t) {\n    if constexpr(std::is_same_v<std::tuple_element_t<I, std::tuple<Tp...>>, std::tuple<long, long, std::tuple<long, long>, long, long>>) {\n        t = std::tuple_cat(\n            std::tuple_cat(std::make_tuple((std::get<I>(t) % 2 == 0 ? std::get<I>(t) : 0)...)),\n            extract_even_impl<I + 1>(t)\n        );\n    } else if constexpr(std::is_same_v<std::tuple_element_t<I, std::tuple<Tp...>>, std::tuple<long, long, std::tuple<long, long, std::tuple<long, long>>, long, long>>) {\n        t = std::tuple_cat(\n            std::make_tuple((std::get<I>(t) % 2 == 0 ? extract_even_impl(std::get<I>(t)) : std::make_tuple(0))),\n            extract_even_impl<I + 1>(t)\n        );\n    } else {\n        t = std::tuple_cat(\n            std::make_tuple((std::get<I>(t) % 2 == 0 ? std::get<I>(t) : 0)),\n            extract_even_impl<I + 1>(t)\n        );\n    }\n    return t;\n}\n\nstd::any extract_even(std::tuple<long, long, std::tuple<long, long, std::tuple<long, long>>, long, long> test_tuple) {\n    return extract_even_impl(test_tuple);\n}\n```"}
{"name":"mbpp_581_surface_Area","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the surface area of a square cppramid with a given base edge and height.\nlong surface_Area(long b, long s) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_581_surface_Area.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = surface_Area;\n    assert(candidate((3), (4)) == (33));\n    assert(candidate((4), (5)) == (56));\n    assert(candidate((1), (2)) == (5));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_581_surface_Area","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to find the surface area of a square pyramid with a given base edge and height.\nlong surface_Area(long b, long h) {\n    \/\/ Calculate the slant height of the pyramid using the Pythagorean theorem\n    long s = sqrt((b \/ 2.0) * (b \/ 2.0) + h * h);\n    \n    \/\/ Calculate the area of the base\n    long base_area = b * b;\n    \n    \/\/ Calculate the lateral surface area (4 * (1\/2 * base_edge * slant_height))\n    long lateral_surface_area = 2 * b * s;\n    \n    \/\/ Total surface area is the sum of the base area and the lateral surface area\n    long total_surface_area = base_area + lateral_surface_area;\n    \n    return total_surface_area;\n}\n```"}
{"name":"mbpp_583_catalan_number","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function which returns nth catalan number.\nlong catalan_number(long num) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_583_catalan_number.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = catalan_number;\n    assert(candidate((10)) == (16796));\n    assert(candidate((9)) == (4862));\n    assert(candidate((7)) == (429));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_583_catalan_number","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to return nth catalan number.\nlong catalan_number(long num) {\n    if (num <= 1)\n        return 1;\n    \n    std::vector<long> catalan(num + 1, 0);\n    catalan[0] = 1;\n    catalan[1] = 1;\n    \n    for (long i = 2; i <= num; ++i) {\n        for (long j = 0; j < i; ++j) {\n            catalan[i] += catalan[j] * catalan[i - j - 1];\n        }\n    }\n    return catalan[num];\n}\n```"}
{"name":"mbpp_584_find_adverbs","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the first adverb ending with ly and its positions in a given string.\nstd::string find_adverbs(std::string text) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_584_find_adverbs.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_adverbs;\n    assert(candidate((\"Clearly, he has no excuse for such behavior.\")) == (\"0-7: Clearly\"));\n    assert(candidate((\"Please handle the situation carefuly\")) == (\"28-36: carefuly\"));\n    assert(candidate((\"Complete the task quickly\")) == (\"18-25: quickly\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_584_find_adverbs","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to find the first adverb ending with \"ly\" and its positions in a given string.\nstd::string find_adverbs(std::string text) {\n    std::istringstream iss(text);\n    std::string word;\n    size_t pos = 0, found_pos = std::string::npos;\n    \n    while (iss >> word) {\n        size_t len = word.length();\n        if (len > 2 && word.substr(len - 2) == \"ly\") {\n            found_pos = text.find(word, pos);\n            break;\n        }\n        pos += word.length() + 1; \/\/ +1 to account for the space\n    }\n    \n    if (found_pos != std::string::npos) {\n        return word + \" at position \" + std::to_string(found_pos);\n    }\n    \n    return \"No adverb ending with 'ly' found\";\n}\n```"}
{"name":"mbpp_585_expensive_items","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\nunion Union_std_string_float{\n    std::string f0;\n    float f1;    Union_std_string_float(std::string _f0) : f0(_f0) {}\n    Union_std_string_float(float _f1) : f1(_f1) {}\n    ~Union_std_string_float() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }\n};\n\/\/ Write a function to find the n most expensive items in a given dataset.\nstd::vector<std::map<std::string,Union_std_string_float>> expensive_items(std::vector<std::map<std::string,Union_std_string_float>> items, long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_585_expensive_items.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = expensive_items;\n    assert(candidate((std::vector<std::map<std::string,Union_std_string_float>>({(std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-1\"}, {\"price\", 101.1f}}), (std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-2\"}, {\"price\", 555.22f}})})), (1)) == (std::vector<std::map<std::string,Union_std_string_float>>({(std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-2\"}, {\"price\", 555.22f}})})));\n    assert(candidate((std::vector<std::map<std::string,Union_std_string_float>>({(std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-1\"}, {\"price\", 101.1f}}), (std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-2\"}, {\"price\", 555.22f}}), (std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-3\"}, {\"price\", 45.09f}})})), (2)) == (std::vector<std::map<std::string,Union_std_string_float>>({(std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-2\"}, {\"price\", 555.22f}}), (std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-1\"}, {\"price\", 101.1f}})})));\n    assert(candidate((std::vector<std::map<std::string,Union_std_string_float>>({(std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-1\"}, {\"price\", 101.1f}}), (std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-2\"}, {\"price\", 555.22f}}), (std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-3\"}, {\"price\", 45.09f}}), (std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-4\"}, {\"price\", 22.75f}})})), (1)) == (std::vector<std::map<std::string,Union_std_string_float>>({(std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-2\"}, {\"price\", 555.22f}})})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_585_expensive_items","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n#include <assert.h>\n\nunion Union_std_string_float {\n    std::string f0;\n    float f1;\n\n    Union_std_string_float(std::string _f0) : f0(_f0) {}\n    Union_std_string_float(float _f1) : f1(_f1) {}\n    ~Union_std_string_float() {}\n\n    bool operator==(std::string f) {\n        return f0 == f;\n    }\n\n    bool operator==(float f) {\n        return f1 == f;\n    }\n};\n\n\/\/ Function to find the n most expensive items in a given dataset.\nstd::vector<std::map<std::string, Union_std_string_float>> expensive_items(std::vector<std::map<std::string, Union_std_string_float>> items, long n) {\n    \/\/ A vector to hold pairs of (price, item_map) for sorting\n    std::vector<std::pair<float, std::map<std::string, Union_std_string_float>>> price_item_pairs;\n\n    \/\/ Extract price and item map pairs\n    for (const auto& item : items) {\n        float price;\n        for (const auto& element : item) {\n            if (element.first == \"price\") {\n                price = element.second.f1;\n                break;\n            }\n        }\n        price_item_pairs.push_back(std::make_pair(price, item));\n    }\n\n    \/\/ Sort the pairs based on price in descending order\n    std::sort(price_item_pairs.begin(), price_item_pairs.end(), [](const auto& a, const auto& b) {\n        return b.first < a.first;\n    });\n\n    \/\/ Collect the top n items\n    std::vector<std::map<std::string, Union_std_string_float>> most_expensive_items;\n    for (size_t i = 0; i < n && i < price_item_pairs.size(); ++i) {\n        most_expensive_items.push_back(price_item_pairs[i.second]);\n    }\n\n    return most_expensive_items;\n}\n```"}
{"name":"mbpp_586_split_Arr","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to split a vector at the nth eelment and add the first part to the end.\nstd::vector<long> split_Arr(std::vector<long> l, long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_586_split_Arr.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = split_Arr;\n    assert(candidate((std::vector<long>({(long)12, (long)10, (long)5, (long)6, (long)52, (long)36})), (2)) == (std::vector<long>({(long)5, (long)6, (long)52, (long)36, (long)12, (long)10})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (1)) == (std::vector<long>({(long)2, (long)3, (long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})), (3)) == (std::vector<long>({(long)3, (long)4, (long)5, (long)6, (long)7, (long)0, (long)1, (long)2})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_586_split_Arr","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to split a vector at the nth element and add the first part to the end\nstd::vector<long> split_Arr(std::vector<long> l, long n) {\n    \/\/ Check if n is within the bounds of the vector\n    if (n > l.size() || n < 0) {\n        throw std::out_of_range(\"Index n is out of range.\");\n    }\n\n    \/\/ Create a new vector to store the result\n    std::vector<long> result;\n\n    \/\/ Add the elements from index n to the end of the vector\n    for (long i = n; i < l.size(); ++i) {\n        result.push_back(l[i]);\n    }\n\n    \/\/ Add the elements from the beginning of the vector to index n-1\n    for (long i = 0; i < n; ++i) {\n        result.push_back(l[i]);\n    }\n\n    return result;\n}\n```"}
{"name":"mbpp_587_list_tuple","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to convert a vector to a tuple.\nstd::any list_tuple(std::vector<long> listx) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_587_list_tuple.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = list_tuple;\n    assert(candidate((std::vector<long>({(long)5, (long)10, (long)7, (long)4, (long)15, (long)3}))) == std::make_tuple(5, 10, 7, 4, 15, 3));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)5, (long)6, (long)2, (long)3, (long)4, (long)4, (long)7}))) == std::make_tuple(2, 4, 5, 6, 2, 3, 4, 4, 7));\n    assert(candidate((std::vector<long>({(long)58, (long)44, (long)56}))) == std::make_tuple(58, 44, 56));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_587_list_tuple","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Helper function to convert a vector to a tuple\ntemplate <std::size_t... I>\nauto vector_to_tuple_impl(const std::vector<long>& listx, std::index_sequence<I...>) {\n    return std::make_tuple(listx[I]...);\n}\n\n\/\/ Function to convert a vector to a tuple\nstd::any list_tuple(std::vector<long> listx) {\n    constexpr std::size_t N = 3; \/\/ assuming we want to convert the first 3 elements\n    assert(listx.size() >= N); \/\/ ensure that the vector has at least N elements\n\n    return vector_to_tuple_impl(listx, std::make_index_sequence<N>{});\n}\n```"}
{"name":"mbpp_588_big_diff","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the difference between largest and smallest value in a given vector.\nlong big_diff(std::vector<long> nums) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_588_big_diff.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = big_diff;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (3));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)12}))) == (8));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)3}))) == (7));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_588_big_diff","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cpp function to find the difference between largest and smallest value in a given vector.\nlong big_diff(std::vector<long> nums) {\n    \/\/ Check if the vector is empty\n    if (nums.empty()) {\n        throw std::invalid_argument(\"The input vector is empty\");\n    }\n\n    \/\/ Find the minimum and maximum values in the vector\n    long min_val = *std::min_element(nums.begin(), nums.end());\n    long max_val = *std::max_element(nums.begin(), nums.end());\n\n    \/\/ Return the difference between the largest and smallest value\n    return max_val - min_val;\n}\n```"}
{"name":"mbpp_589_perfect_squares","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find perfect squares between two given numbers.\nstd::vector<long> perfect_squares(long a, long b) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_589_perfect_squares.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = perfect_squares;\n    assert(candidate((1), (30)) == (std::vector<long>({(long)1, (long)4, (long)9, (long)16, (long)25})));\n    assert(candidate((50), (100)) == (std::vector<long>({(long)64, (long)81, (long)100})));\n    assert(candidate((100), (200)) == (std::vector<long>({(long)100, (long)121, (long)144, (long)169, (long)196})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_589_perfect_squares","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to find perfect squares between two given numbers.\nstd::vector<long> perfect_squares(long a, long b) {\n    std::vector<long> result;\n    long start = std::ceil(std::sqrt(a));\n    long end = std::floor(std::sqrt(b));\n\n    for (long i = start; i <= end; ++i) {\n        result.push_back(i * i);\n    }\n\n    return result;\n}\n```"}
{"name":"mbpp_591_swap_List","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to interchange the first and last elements in a vector.\nstd::vector<long> swap_List(std::vector<long> newList) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_591_swap_List.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = swap_List;\n    assert(candidate((std::vector<long>({(long)12, (long)35, (long)9, (long)56, (long)24}))) == (std::vector<long>({(long)24, (long)35, (long)9, (long)56, (long)12})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)3, (long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6}))) == (std::vector<long>({(long)6, (long)5, (long)4})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_591_swap_List","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cppfunction to interchange the first and last elements in a vector.\nstd::vector<long> swap_List(std::vector<long> newList) {\n    \/\/ Check if the vector is empty or has only one element.\n    if(newList.size() <= 1) {\n        return newList;\n    }\n\n    \/\/ Swap the first and last elements\n    std::swap(newList[0], newList[newList.size() - 1]);\n\n    return newList;\n}\n```"}
{"name":"mbpp_592_sum_Of_product","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the sum of the product of consecutive binomial co-efficients.\nlong sum_Of_product(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_592_sum_Of_product.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sum_Of_product;\n    assert(candidate((3)) == (15));\n    assert(candidate((4)) == (56));\n    assert(candidate((1)) == (1));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_592_sum_Of_product","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to find the sum of the product of consecutive binomial coefficients\nlong sum_Of_product(long n) {\n    \/\/ Since (C(n, k) * C(n, k+1)) = C(n, k) * (C(n, k) * (n-k)\/(k+1))\n    \/\/                             = C(n, k)^2 * (n-k)\/(k+1)\n    \/\/ The sum of the products of consecutive binomial coefficients is equal to:\n    \/\/ sum(C(n, k) * C(n, k+1)) for k = 0 to n-1 is n * 2^(n-2)\n\n    \/\/ Handle edge cases\n    if (n < 1) {\n        return 0;\n    }\n  \n    \/\/ Compute the sum of products\n    return n * pow(2, n-2);\n}\n```\n\nThis function calculates the sum of the products of consecutive binomial coefficients without explicitly computing each product. Instead, it leverages the mathematical insight that the sum equals \\( n \\times 2^{n-2} \\)."}
{"name":"mbpp_593_removezero_ip","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to remove leading zeroes from an ip address.\nstd::string removezero_ip(std::string ip) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_593_removezero_ip.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = removezero_ip;\n    assert(candidate((\"216.08.094.196\")) == (\"216.8.94.196\"));\n    assert(candidate((\"12.01.024\")) == (\"12.1.24\"));\n    assert(candidate((\"216.08.094.0196\")) == (\"216.8.94.196\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_593_removezero_ip","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to remove leading zeroes from an ip address.\nstd::string removezero_ip(std::string ip) {\n    std::stringstream ss(ip);\n    std::string segment;\n    std::vector<std::string> segments;\n\n    \/\/ Split the IP address by '.'\n    while (std::getline(ss, segment, '.')) {\n        \/\/ Remove leading zeros from each segment\n        int num = stoi(segment);\n        segments.push_back(std::to_string(num));\n    }\n\n    \/\/ Join the segments back with '.'\n    std::string result = segments[0];\n    for (int i = 1; i < segments.size(); ++i) {\n        result += \".\" + segments[i];\n    }\n\n    return result;\n}\n\n\/\/ Test cases to verify the functionality\nvoid test_removezero_ip() {\n    assert(removezero_ip(\"192.168.001.001\") == \"192.168.1.1\");\n    assert(removezero_ip(\"010.000.030.003\") == \"10.0.30.3\");\n    assert(removezero_ip(\"000.003.000.245\") == \"0.3.0.245\");\n    assert(removezero_ip(\"255.024.01.001\") == \"255.24.1.1\");\n    assert(removezero_ip(\"000.000.000.000\") == \"0.0.0.0\");\n}\n\n\/\/ Ensure tests are run\nstruct RunTests {\n    RunTests() {\n        test_removezero_ip();\n    }\n} runTests;\n```"}
{"name":"mbpp_594_diff_even_odd","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the difference of the first even and first odd number of a given vector.\nlong diff_even_odd(std::vector<long> list1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_594_diff_even_odd.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = diff_even_odd;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)7, (long)4, (long)1, (long)6, (long)8}))) == (3));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)5, (long)7, (long)9, (long)10}))) == (9));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_594_diff_even_odd","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to find the difference of the first even and first odd number of a given vector.\nlong diff_even_odd(std::vector<long> list1) {\n    long first_even = -1;\n    long first_odd = -1;\n\n    for (long num : list1) {\n        if (num % 2 == 0 && first_even == -1) {\n            first_even = num;\n        } else if (num % 2 != 0 && first_odd == -1) {\n            first_odd = num;\n        }\n\n        if (first_even != -1 && first_odd != -1) {\n            break;\n        }\n    }\n\n    return first_even - first_odd;\n}\n```"}
{"name":"mbpp_595_min_Swaps","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to count minimum number of swaps required to convert one binary number represented as a string to another.\nstd::any min_Swaps(std::string str1, std::string str2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_595_min_Swaps.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = min_Swaps;\n    assert(candidate((\"1101\"), (\"1110\")) == (std::any(1)));\n    assert(candidate((\"111\"), (\"000\")) == (std::any(\"Not Possible\")));\n    assert(candidate((\"111\"), (\"110\")) == (std::any(\"Not Possible\")));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_595_min_Swaps","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\nint min_Swaps(std::string str1, std::string str2) {\n    int n = str1.length();\n    if (str2.length() != n) {\n        throw std::invalid_argument(\"Binary strings must be of equal length\");\n    }\n\n    int count0 = 0, count1 = 0;\n    for (int i = 0; i < n; i++) {\n        if (str1[i] != str2[i]) {\n            if (str1[i] == '0') count0++;\n            else count1++;\n        }\n    }\n\n    if (count0 != count1) {\n        return -1; \/\/ No possible way to make one string similar to other.\n    }\n\n    return count0;\n}\n```"}
{"name":"mbpp_597_find_kth","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find kth element from the given two sorted vectors.\nlong find_kth(std::vector<long> arr1, std::vector<long> arr2, long k) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_597_find_kth.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_kth;\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)6, (long)7, (long)9})), (std::vector<long>({(long)1, (long)4, (long)8, (long)10})), (5)) == (6));\n    assert(candidate((std::vector<long>({(long)100, (long)112, (long)256, (long)349, (long)770})), (std::vector<long>({(long)72, (long)86, (long)113, (long)119, (long)265, (long)445, (long)892})), (7)) == (256));\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)7, (long)8, (long)10})), (std::vector<long>({(long)2, (long)5, (long)9, (long)11})), (6)) == (8));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_597_find_kth","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Write a function to find kth element from the given two sorted vectors.\nlong find_kth(std::vector<long> arr1, std::vector<long> arr2, long k) {\n    long n1 = arr1.size();\n    long n2 = arr2.size();\n    \n    if (n1 > n2) {\n        return find_kth(arr2, arr1, k);\n    }\n    \n    long lo = 0;\n    long hi = n1;\n    \n    while (lo <= hi) {\n        long mid1 = (lo + hi) \/ 2;\n        long mid2 = k - mid1;\n        \n        long left1 = mid1 == 0 ? LONG_MIN : arr1[mid1 - 1];\n        long left2 = mid2 == 0 ? LONG_MIN : arr2[mid2 - 1];\n        long right1 = mid1 == n1 ? LONG_MAX : arr1[mid1];\n        long right2 = mid2 == n2 ? LONG_MAX : arr2[mid2];\n        \n        if (left1 <= right2 && left2 <= right1) {\n            return max(left1, left2);\n        } else if (left1 > right2) {\n            hi = mid1 - 1;\n        } else {\n            lo = mid1 + 1;\n        }\n    }\n    \n    return -1;  \/\/ k is out of bounds\n}\n```"}
{"name":"mbpp_598_armstrong_number","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check whether the given number is armstrong or not.\nbool armstrong_number(long number) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_598_armstrong_number.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = armstrong_number;\n    assert(candidate((153)) == (true));\n    assert(candidate((259)) == (false));\n    assert(candidate((4458)) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_598_armstrong_number","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to check whether the given number is armstrong or not.\nbool armstrong_number(long number) {\n    long originalNumber = number;\n    int digits = 0;\n\n    \/\/ Get the number of digits\n    while (originalNumber != 0) {\n        originalNumber \/= 10;\n        digits++;\n    }\n\n    originalNumber = number; \/\/ Reset the number to original\n    long sum = 0;\n\n    \/\/ Calculate the sum of digits raised to the power of the number of digits\n    while (originalNumber != 0) {\n        int digit = originalNumber % 10;\n        sum += pow(digit, digits);\n        originalNumber \/= 10;\n    }\n\n    \/\/ Check if the sum is equal to the original number\n    return sum == number;\n}\n```\n\nThis function checks whether a given number is an Armstrong number or not. It first determines the number of digits in the number, and then it calculates the sum of each digit raised to the power of the number of digits. If this sum is equal to the original number, the function returns true, indicating that it is an Armstrong number. Otherwise, it returns false."}
{"name":"mbpp_599_sum_average","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find sum and average of first n natural numbers.\nstd::tuple<long, float> sum_average(long number) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_599_sum_average.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sum_average;\n    assert(candidate((10)) == (std::make_tuple(55, 5.5f)));\n    assert(candidate((15)) == (std::make_tuple(120, 8.0f)));\n    assert(candidate((20)) == (std::make_tuple(210, 10.5f)));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_599_sum_average","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find sum and average of first n natural numbers.\nstd::tuple<long, float> sum_average(long number) {\n    \/\/ Ensure the number is non-negative\n    assert(number >= 0);\n\n    \/\/ Calculate the sum of first n natural numbers\n    long sum = (number * (number + 1)) \/ 2;\n\n    \/\/ Calculate the average of first n natural numbers\n    float average = static_cast<float>(sum) \/ number;\n\n    return std::make_tuple(sum, average);\n}\n```\n\nThis code provides a function `sum_average` that calculates both the sum and average of the first `n` natural numbers and returns them as a tuple. The function ensures that the input number is non-negative through the usage of an assertion. Additionally, the average calculation uses static casting to ensure proper floating-point division."}
{"name":"mbpp_600_is_Even","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to check whether the given number is even or not.\nbool is_Even(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_600_is_Even.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = is_Even;\n    assert(candidate((1)) == (false));\n    assert(candidate((2)) == (true));\n    assert(candidate((3)) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_600_is_Even","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cpp function to check whether the given number is even or not.\nbool is_Even(long n) {\n    \/\/ If the number is divisible by 2, it's even\n    return (n % 2 == 0);\n}\n```"}
{"name":"mbpp_602_first_repeated_char","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the first repeated character in a given string.\nstd::optional<std::string> first_repeated_char(std::string str1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_602_first_repeated_char.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = first_repeated_char;\n    assert(candidate((\"abcabc\")) == \"a\");\n    assert(candidate((\"abc\")) == std::nullopt);\n    assert(candidate((\"123123\")) == \"1\");\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_602_first_repeated_char","gpt_solution":"```cpp\n#include <iostream>\n#include <unordered_map>\n#include <optional>\n#include <string>\n\n\/\/ Write a cpp function to find the first repeated character in a given string.\nstd::optional<std::string> first_repeated_char(std::string str1) {\n    std::unordered_map<char, int> char_count;\n    for (char ch : str1) {\n        if (char_count[ch] > 0) {\n            return std::string(1, ch);\n        }\n        char_count[ch]++;\n    }\n    return std::nullopt;\n}\n```\n\nThis function takes a string `str1` and uses an unordered map to count the characters. It returns the first repeated character wrapped in `std::optional<std::string>`, and if no character is repeated, it returns `std::nullopt`."}
{"name":"mbpp_603_get_ludic","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to get all lucid numbers smaller than or equal to a given integer.\nstd::vector<long> get_ludic(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_603_get_ludic.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = get_ludic;\n    assert(candidate((10)) == (std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)7})));\n    assert(candidate((25)) == (std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)23, (long)25})));\n    assert(candidate((45)) == (std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)23, (long)25, (long)29, (long)37, (long)41, (long)43})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_603_get_ludic","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to get all ludic numbers smaller than or equal to a given integer.\nstd::vector<long> get_ludic(long n) {\n    std::vector<long> ludicNumbers;\n    if (n < 1) {\n        return ludicNumbers;\n    }\n\n    \/\/ Initialize the list with numbers from 1 to n\n    std::vector<long> numbers(n);\n    std::iota(numbers.begin(), numbers.end(), 1); \n\n    size_t index = 1; \/\/ start with the second element (since first element is 1)\n    while (index < numbers.size() && index < numbers[index]) {\n        long current = numbers[index];\n\n        \/\/ Keep only elements that are not in positions current, 2*current, 3*current, ...\n        auto it = std::remove_if(numbers.begin() + index + 1, numbers.end(),\n                    [&index, &current](long val) { \n                        return ((&val - &numbers[index+1]) % current == 0);\n                    });\n        numbers.erase(it, numbers.end());\n\n        index++;\n    }\n\n    return numbers;\n}\n```\n\nThis code defines a function `get_ludic` that computes all Ludic numbers smaller than or equal to the given integer `n`. The Ludic numbers are found using a process similar to the Sieve of Eratosthenes, but with a different sieving step."}
{"name":"mbpp_604_reverse_words","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to reverse words seperated by spaces in a given string.\nstd::string reverse_words(std::string s) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_604_reverse_words.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = reverse_words;\n    assert(candidate((\"python program\")) == (\"program python\"));\n    assert(candidate((\"java language\")) == (\"language java\"));\n    assert(candidate((\"indian man\")) == (\"man indian\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_604_reverse_words","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to reverse words separated by spaces in a given string.\nstd::string reverse_words(std::string s) {\n    std::stringstream ss(s);\n    std::string word, result;\n\n    \/\/ Split the string into words and store them in a stack\n    std::stack<std::string> words;\n    while (ss >> word) {\n        words.push(word);\n    }\n\n    \/\/ Pop words from the stack to form the reversed sentence\n    while (!words.empty()) {\n        result += words.top();\n        words.pop();\n        if (!words.empty()) {\n            result += \" \";\n        }\n    }\n\n    return result;\n}\n```"}
{"name":"mbpp_605_prime_num","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check if the given integer is a prime number.\nbool prime_num(long num) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_605_prime_num.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = prime_num;\n    assert(candidate((13)) == (true));\n    assert(candidate((7)) == (true));\n    assert(candidate((-1010)) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_605_prime_num","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to check if the given integer is a prime number.\nbool prime_num(long num) {\n    \/\/ Handle edge cases\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n\n    \/\/ Check for factors from 5 to sqrt(num)\n    for (long i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    \n    return true;\n}\n```"}
{"name":"mbpp_606_radian_degree","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to convert degrees to radians.\nfloat radian_degree(long degree) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_606_radian_degree.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = radian_degree;\n    assert(candidate((90)) == (1.5707963267948966f));\n    assert(candidate((60)) == (1.0471975511965976f));\n    assert(candidate((120)) == (2.0943951023931953f));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_606_radian_degree","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n#include <assert.h>\n\n\/\/ Write a function to convert degrees to radians.\nfloat radian_degree(long degree) {\n    \/\/ Conversion factor for degrees to radians\n    const float PI = 3.14159265358979323846;\n    return degree * (PI \/ 180.0f);\n}\n```"}
{"name":"mbpp_607_find_literals","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to search a string for a regex pattern. The function should return the matching subtring, a start index and an end index.\nstd::tuple<std::string, long, long> find_literals(std::string text, std::string pattern) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_607_find_literals.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_literals;\n    assert(candidate((\"The quick brown fox jumps over the lazy dog.\"), (\"fox\")) == (std::make_tuple(\"fox\", 16, 19)));\n    assert(candidate((\"Its been a very crazy procedure right\"), (\"crazy\")) == (std::make_tuple(\"crazy\", 16, 21)));\n    assert(candidate((\"Hardest choices required strongest will\"), (\"will\")) == (std::make_tuple(\"will\", 35, 39)));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_607_find_literals","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n#include<regex>\n\n\/\/ Write a function to search a string for a regex pattern. The function should return the matching substring, a start index and an end index.\nstd::tuple<std::string, long, long> find_literals(std::string text, std::string pattern) {\n    std::regex re(pattern);\n    std::smatch match;\n    \n    if (std::regex_search(text, match, re)) {\n        std::string matched_string = match.str(0);\n        long start_index = match.position(0);\n        long end_index = start_index + matched_string.length() - 1;\n        \n        return std::make_tuple(matched_string, start_index, end_index);\n    } else {\n        return std::make_tuple(\"\", -1, -1);\n    }\n}\n```\n\nThe function `find_literals` takes a `text` string and a `pattern` string representing a regex pattern, and searches the `text` for the pattern. It returns a tuple containing the matching substring, the start index, and the end index of the match. If no match is found, it returns a tuple with an empty string and indices set to `-1`."}
{"name":"mbpp_608_bell_Number","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find nth bell number.\nlong bell_Number(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_608_bell_Number.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = bell_Number;\n    assert(candidate((2)) == (2));\n    assert(candidate((3)) == (5));\n    assert(candidate((4)) == (15));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_608_bell_Number","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to find nth Bell number\nlong bell_Number(long n) {\n    \/\/ Create a 2D array to store Bell numbers \n    vector<vector<long>> bell(n + 1, vector<long>(n + 1, 0));\n    \n    \/\/ Initialize the first Bell number\n    bell[0][0] = 1;\n    \n    \/\/ Fill the Bell triangle according to the formula\n    for (long i = 1; i <= n; i++) {\n        \/\/ Explicitly put the last element of the previous row at the first position of the new row\n        bell[i][0] = bell[i - 1][i - 1];\n        \n        \/\/ Fill the rest of the entries in the current row\n        for (long j = 1; j <= i; j++) {\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1];\n        }\n    }\n    \n    return bell[n][0];\n}\n```"}
{"name":"mbpp_610_remove_kth_element","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function which takes a vector and returns a vector with the same elements, but the k'th element removed.\nstd::vector<long> remove_kth_element(std::vector<long> list1, long L) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_610_remove_kth_element.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = remove_kth_element;\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)3, (long)4, (long)4, (long)5, (long)1})), (3)) == (std::vector<long>({(long)1, (long)1, (long)3, (long)4, (long)4, (long)5, (long)1})));\n    assert(candidate((std::vector<long>({(long)0, (long)0, (long)1, (long)2, (long)3, (long)4, (long)4, (long)5, (long)6, (long)6, (long)6, (long)7, (long)8, (long)9, (long)4, (long)4})), (4)) == (std::vector<long>({(long)0, (long)0, (long)1, (long)3, (long)4, (long)4, (long)5, (long)6, (long)6, (long)6, (long)7, (long)8, (long)9, (long)4, (long)4})));\n    assert(candidate((std::vector<long>({(long)10, (long)10, (long)15, (long)19, (long)18, (long)18, (long)17, (long)26, (long)26, (long)17, (long)18, (long)10})), (5)) == (std::vector<long>({(long)10, (long)10, (long)15, (long)19, (long)18, (long)17, (long)26, (long)26, (long)17, (long)18, (long)10})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_610_remove_kth_element","gpt_solution":"```cpp\n#include <vector>\n#include <stdexcept>\n\n\/\/ Write a cpp function which takes a vector and returns a vector with the same elements, but the k'th element removed.\nstd::vector<long> remove_kth_element(std::vector<long> list1, long k) {\n    if (k < 0 || k >= list1.size()) {\n        throw std::out_of_range(\"k is out of range of the list\");\n    }\n    list1.erase(list1.begin() + k);\n    return list1;\n}\n```"}
{"name":"mbpp_611_max_of_nth","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function which given a matrix represented as a vector of vectors returns the max of the n'th column.\nlong max_of_nth(std::vector<std::vector<long>> test_list, long N) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_611_max_of_nth.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = max_of_nth;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7}), (std::vector<long>)std::vector<long>({(long)1, (long)3, (long)5}), (std::vector<long>)std::vector<long>({(long)8, (long)9, (long)19})})), (2)) == (19));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)2, (long)4, (long)6}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)20})})), (1)) == (10));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)3, (long)5, (long)7}), (std::vector<long>)std::vector<long>({(long)10, (long)11, (long)21})})), (1)) == (11));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_611_max_of_nth","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function which given a matrix represented as a vector of vectors returns the max of the n'th column.\nlong max_of_nth(std::vector<std::vector<long>> test_list, long N) {\n    long max_value = LONG_MIN;\n    \n    \/\/ Iterate over each row in the matrix\n    for (const auto& row : test_list) {\n        if (N < row.size()) {\n            \/\/ Update the maximum value if a larger element is found in the N'th column\n            max_value = std::max(max_value, row[N]);\n        } else {\n            \/\/ Handle cases where N is out of bounds for the given row\n            throw std::out_of_range(\"Column index exceeds row size\");\n        }\n    }\n\n    return max_value;\n}\n```\n\nThis code defines a function `max_of_nth` that takes a matrix (represented as a vector of vectors) and an integer `N`, then returns the maximum value in the N'th column of the matrix. An `out_of_range` exception is thrown if `N` exceeds the number of columns in any row."}
{"name":"mbpp_612_merge","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function which takes a vector of vectors, where each subvector has two elements, and returns a vector of two vectors where the first vector has the first element of each subvector and the second one has the second.\nstd::vector<std::vector<std::any>> merge(std::vector<std::vector<std::any>> lst) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_612_merge.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = merge;\n    assert(candidate((std::vector<std::vector<std::any>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"x\", (std::string)\"y\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"a\", (std::string)\"b\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"m\", (std::string)\"n\"})}))) == (std::vector<std::vector<std::any>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"x\", (std::string)\"a\", (std::string)\"m\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"y\", (std::string)\"b\", (std::string)\"n\"})})));\n    assert(candidate((std::vector<std::vector<std::any>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8})}))) == (std::vector<std::vector<std::any>>({(std::vector<long>)std::vector<long>({(long)1, (long)3, (long)5, (long)7}), (std::vector<long>)std::vector<long>({(long)2, (long)4, (long)6, (long)8})})));\n    assert(candidate((std::vector<std::vector<std::any>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"m\", (std::string)\"n\", (std::string)\"o\"})}))) == (std::vector<std::vector<std::any>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"x\", (std::string)\"a\", (std::string)\"m\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"y\", (std::string)\"b\", (std::string)\"n\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"z\", (std::string)\"c\", (std::string)\"o\"})})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_612_merge","gpt_solution":"```cpp\n#include <vector>\n#include <any>\n#include <iostream>\n#include <cassert>\n\n\/\/ Write a cpp function which takes a vector of vectors, \n\/\/ where each subvector has two elements, \n\/\/ and returns a vector of two vectors where the first vector \n\/\/ has the first element of each subvector and the second one \n\/\/ has the second.\nstd::vector<std::vector<std::any>> merge(std::vector<std::vector<std::any>> lst) {\n    std::vector<std::any> first_elements;\n    std::vector<std::any> second_elements;\n\n    for (const auto& subvector : lst) {\n        assert(subvector.size() == 2); \/\/ Each subvector must have exactly 2 elements\n        first_elements.push_back(subvector[0]);\n        second_elements.push_back(subvector[1]);\n    }\n\n    return {first_elements, second_elements};\n}\n```"}
{"name":"mbpp_614_cummulative_sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the cumulative sum of all the values that are present in the given vector of vectors.\nlong cummulative_sum(std::vector<std::vector<long>> test_list) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_614_cummulative_sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = cummulative_sum;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7}), (std::vector<long>)std::vector<long>({(long)2, (long)6})}))) == (30));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)4}), (std::vector<long>)std::vector<long>({(long)6, (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)3, (long)7})}))) == (37));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)3, (long)5}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)4, (long)8})}))) == (44));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_614_cummulative_sum","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the cumulative sum of all the values that are present in the given vector of vectors.\nlong cummulative_sum(std::vector<std::vector<long>> test_list) {\n    long total_sum = 0;\n    for (const auto& inner_vector : test_list) {\n        for (const auto& value : inner_vector) {\n            total_sum += value;\n        }\n    }\n    return total_sum;\n}\n```"}
{"name":"mbpp_615_average_tuple","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function which takes a vectors of vectors and returns the average value for each subvector as a vector.\nstd::vector<float> average_tuple(std::vector<std::vector<long>> nums) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_615_average_tuple.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = average_tuple;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)10, (long)10, (long)10, (long)12}), (std::vector<long>)std::vector<long>({(long)30, (long)45, (long)56, (long)45}), (std::vector<long>)std::vector<long>({(long)81, (long)80, (long)39, (long)32}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4})}))) == (std::vector<float>({(float)30.5f, (float)34.25f, (float)27.0f, (float)23.25f})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)-5}), (std::vector<long>)std::vector<long>({(long)30, (long)-15, (long)56}), (std::vector<long>)std::vector<long>({(long)81, (long)-60, (long)-39}), (std::vector<long>)std::vector<long>({(long)-10, (long)2, (long)3})}))) == (std::vector<float>({(float)25.5f, (float)-18.0f, (float)3.75f})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)100, (long)100, (long)100, (long)120}), (std::vector<long>)std::vector<long>({(long)300, (long)450, (long)560, (long)450}), (std::vector<long>)std::vector<long>({(long)810, (long)800, (long)390, (long)320}), (std::vector<long>)std::vector<long>({(long)10, (long)20, (long)30, (long)40})}))) == (std::vector<float>({(float)305.0f, (float)342.5f, (float)270.0f, (float)232.5f})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_615_average_tuple","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Write a function which takes a vectors of vectors and returns the average value for each subvector as a vector.\nstd::vector<float> average_tuple(std::vector<std::vector<long>> nums) {\n    std::vector<float> averages;\n    for (const auto& subvec : nums) {\n        if (!subvec.empty()) {\n            long sum = std::accumulate(subvec.begin(), subvec.end(), 0L);\n            float avg = static_cast<float>(sum) \/ subvec.size();\n            averages.push_back(avg);\n        } else {\n            \/\/ If the subvector is empty, push back 0.0 (assuming 0 as average for empty subvector)\n            averages.push_back(0.0);\n        }\n    }\n    return averages;\n}\n```"}
{"name":"mbpp_616_tuple_modulo","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function which takes two tuples of the same length and performs the element wise modulo.\nstd::tuple<long, long, long, long> tuple_modulo(std::tuple<long, long, long, long> test_tup1, std::tuple<long, long, long, long> test_tup2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_616_tuple_modulo.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = tuple_modulo;\n    assert(candidate((std::make_tuple(10, 4, 5, 6)), (std::make_tuple(5, 6, 7, 5))) == (std::make_tuple(0, 4, 5, 1)));\n    assert(candidate((std::make_tuple(11, 5, 6, 7)), (std::make_tuple(6, 7, 8, 6))) == (std::make_tuple(5, 5, 6, 1)));\n    assert(candidate((std::make_tuple(12, 6, 7, 8)), (std::make_tuple(7, 8, 9, 7))) == (std::make_tuple(5, 6, 7, 1)));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_616_tuple_modulo","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function which takes two tuples of the same length and performs the element wise modulo.\nstd::tuple<long, long, long, long> tuple_modulo(std::tuple<long, long, long, long> test_tup1, std::tuple<long, long, long, long> test_tup2) {\n    \/\/ Unpacking the tuples\n    long a1, b1, c1, d1;\n    long a2, b2, c2, d2;\n    \n    std::tie(a1, b1, c1, d1) = test_tup1;\n    std::tie(a2, b2, c2, d2) = test_tup2;\n    \n    \/\/ Performing element wise modulo and creating a new tuple\n    long res1 = a1 % a2;\n    long res2 = b1 % b2;\n    long res3 = c1 % c2;\n    long res4 = d1 % d2;\n    \n    return std::make_tuple(res1, res2, res3, res4);\n}\n```"}
{"name":"mbpp_617_min_Jumps","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfloat min_Jumps(std::tuple<long, long> steps, long d) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_617_min_Jumps.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = min_Jumps;\n    assert(candidate((std::make_tuple(3, 4)), (11)) == (3.5f));\n    assert(candidate((std::make_tuple(3, 4)), (0)) == (float(0)));\n    assert(candidate((std::make_tuple(11, 14)), (11)) == (float(1)));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_617_min_Jumps","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfloat min_Jumps(std::tuple<long, long> steps, long d) {\n    long dx = std::get<0>(steps);\n    long dy = std::get<1>(steps);\n    double jumpDistance = sqrt(dx * dx + dy * dy);\n    \n    \/\/ Calculate number of jumps required\n    double jumps = d \/ jumpDistance;\n\n    return ceil(jumps);\n}\n```\n\nThis function `min_Jumps` calculates the minimum number of jumps required to reach a point (d, 0) from the origin in a 2D plane, given the length of each jump as defined by the tuple `steps` containing the x and y components of the jump. The result is the smallest integer greater than or equal to the exact number of jumps required to ensure we reach or exceed the distance d."}
{"name":"mbpp_618_div_list","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to divide two vectors element wise.\nstd::vector<float> div_list(std::vector<long> nums1, std::vector<long> nums2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_618_div_list.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = div_list;\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6})), (std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<float>({(float)4.0f, (float)2.5f, (float)2.0f})));\n    assert(candidate((std::vector<long>({(long)3, (long)2})), (std::vector<long>({(long)1, (long)4}))) == (std::vector<float>({(float)3.0f, (float)0.5f})));\n    assert(candidate((std::vector<long>({(long)90, (long)120})), (std::vector<long>({(long)50, (long)70}))) == (std::vector<float>({(float)1.8f, (float)1.7142857142857142f})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_618_div_list","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to divide two vectors element wise.\nstd::vector<float> div_list(const std::vector<long>& nums1, const std::vector<long>& nums2) {\n    \/\/ Make sure both vectors are of the same size\n    assert(nums1.size() == nums2.size());\n\n    std::vector<float> result(nums1.size());\n    \n    for (size_t i = 0; i < nums1.size(); ++i) {\n        \/\/ Assert to ensure no division by zero\n        assert(nums2[i] != 0);\n        result[i] = static_cast<float>(nums1[i]) \/ nums2[i];\n    }\n\n    return result;\n}\n```"}
{"name":"mbpp_619_move_num","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to move all the numbers to the end of the given string.\nstd::string move_num(std::string test_str) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_619_move_num.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = move_num;\n    assert(candidate((\"I1love143you55three3000thousand\")) == (\"Iloveyouthreethousand1143553000\"));\n    assert(candidate((\"Avengers124Assemble\")) == (\"AvengersAssemble124\"));\n    assert(candidate((\"Its11our12path13to14see15things16do17things\")) == (\"Itsourpathtoseethingsdothings11121314151617\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_619_move_num","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to move all the numbers to the end of the given string.\nstd::string move_num(std::string test_str) {\n    std::string letters = \"\";\n    std::string numbers = \"\";\n\n    for (char ch : test_str) {\n        if (isdigit(ch)) {\n            numbers += ch;\n        } else {\n            letters += ch;\n        }\n    }\n    \n    return letters + numbers;\n}\n```"}
{"name":"mbpp_622_get_median","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the median of two sorted vectors of same size.\nfloat get_median(std::vector<long> arr1, std::vector<long> arr2, long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_622_get_median.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = get_median;\n    assert(candidate((std::vector<long>({(long)1, (long)12, (long)15, (long)26, (long)38})), (std::vector<long>({(long)2, (long)13, (long)17, (long)30, (long)45})), (5)) == (16.0f));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)9})), (std::vector<long>({(long)7, (long)13, (long)19, (long)28})), (4)) == (8.5f));\n    assert(candidate((std::vector<long>({(long)3, (long)6, (long)14, (long)23, (long)36, (long)42})), (std::vector<long>({(long)2, (long)18, (long)27, (long)39, (long)49, (long)55})), (6)) == (25.0f));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_622_get_median","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Write a function to find the median of two sorted vectors of same size.\nfloat get_median(std::vector<long> arr1, std::vector<long> arr2, long n) {\n    \/\/ Merging the two arrays into one sorted array\n    std::vector<long> merged;\n    long i = 0, j = 0;\n    while (i < n && j < n) {\n        if (arr1[i] <= arr2[j]) {\n            merged.push_back(arr1[i]);\n            i++;\n        } else {\n            merged.push_back(arr2[j]);\n            j++;\n        }\n    }\n\n    \/\/ Append the remaining elements of arr1\n    while (i < n) {\n        merged.push_back(arr1[i]);\n        i++;\n    }\n\n    \/\/ Append the remaining elements of arr2\n    while (j < n) {\n        merged.push_back(arr2[j]);\n        j++;\n    }\n\n    \/\/ Calculate the median\n    long size = merged.size();\n    if (size % 2 == 0) {\n        \/\/ If even, median is the average of the two middle numbers\n        return (merged[size\/2 - 1] + merged[size\/2]) \/ 2.0;\n    } else {\n        \/\/ If odd, median is the middle number\n        return merged[size\/2];\n    }\n}\n```"}
{"name":"mbpp_623_nth_nums","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to compute the n-th power of each number in a vector.\nstd::vector<long> nth_nums(std::vector<long> nums, long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_623_nth_nums.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = nth_nums;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10})), (2)) == (std::vector<long>({(long)1, (long)4, (long)9, (long)16, (long)25, (long)36, (long)49, (long)64, (long)81, (long)100})));\n    assert(candidate((std::vector<long>({(long)10, (long)20, (long)30})), (3)) == (std::vector<long>({(long)1000, (long)8000, (long)27000})));\n    assert(candidate((std::vector<long>({(long)12, (long)15})), (5)) == (std::vector<long>({(long)248832, (long)759375})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_623_nth_nums","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Write a function to compute the n-th power of each number in a vector.\nstd::vector<long> nth_nums(std::vector<long> nums, long n) {\n    std::vector<long> result;\n    for(long num : nums) {\n        long powered_num = pow(num, n);\n        result.push_back(powered_num);\n    }\n    return result;\n}\n```"}
{"name":"mbpp_624_is_upper","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to convert a given string to uppercase.\nstd::string is_upper(std::string string) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_624_is_upper.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = is_upper;\n    assert(candidate((\"person\")) == (\"PERSON\"));\n    assert(candidate((\"final\")) == (\"FINAL\"));\n    assert(candidate((\"Valid\")) == (\"VALID\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_624_is_upper","gpt_solution":"```cpp\n#include <cassert>\n#include <bits\/stdc++.h>\n\n\/\/ Write a cpp function to convert a given string to uppercase.\nstd::string to_upper(std::string str) {\n    std::transform(str.begin(), str.end(), str.begin(), ::toupper);\n    return str;\n}\n\n\/\/ Function to test the to_upper function\nvoid test_to_upper() {\n    assert(to_upper(\"hello\") == \"HELLO\");\n    assert(to_upper(\"world\") == \"WORLD\");\n    assert(to_upper(\"Test123\") == \"TEST123\");\n    assert(to_upper(\"CPP\") == \"CPP\");\n}\n\n\/\/ Run the tests\ntest_to_upper();\n```"}
{"name":"mbpp_625_swap_List","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to interchange the first and last element in a given vector.\nstd::vector<long> swap_List(std::vector<long> newList) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_625_swap_List.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = swap_List;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)3, (long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)4}))) == (std::vector<long>({(long)4, (long)2, (long)3, (long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6}))) == (std::vector<long>({(long)6, (long)5, (long)4})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_625_swap_List","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cppthon function to interchange the first and last element in a given vector.\nstd::vector<long> swap_List(std::vector<long> newList) {\n    \/\/ There should be at least 2 elements to swap\n    if(newList.size() > 1) {\n        std::swap(newList[0], newList[newList.size() - 1]);\n    }\n    return newList;\n}\n```"}
{"name":"mbpp_626_triangle_area","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius.\nstd::optional<long> triangle_area(long r) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_626_triangle_area.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = triangle_area;\n    assert(candidate((-1)) == std::nullopt);\n    assert(candidate((0)) == 0);\n    assert(candidate((2)) == 4);\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_626_triangle_area","gpt_solution":"```cpp\n#include <cmath>\n#include <optional>\n\n\/\/ Function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius\nstd::optional<long> triangle_area(long r) {\n    if (r < 0) {\n        \/\/ Return std::nullopt if the radius is negative\n        return std::nullopt;\n    }\n    \n    \/\/ The largest triangle that can be inscribed in a semicircle is a right triangle,\n    \/\/ with the diameter of the semicircle being the hypotenuse.\n    \/\/ The other two sides (a and b) of the triangle form the base and the height of the semicircle.\n    \/\/ So, a = b = r, and the hypotenuse is the diameter = 2r.\n    \n    \/\/ Area of the triangle\n    long area = (r * r) \/ 2;\n    \n    return area;\n}\n```"}
{"name":"mbpp_627_find_First_Missing","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the smallest missing number from a sorted vector of natural numbers.\nlong find_First_Missing(std::vector<long> array) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_627_find_First_Missing.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_First_Missing;\n    assert(candidate((std::vector<long>({(long)0, (long)1, (long)2, (long)3}))) == (4));\n    assert(candidate((std::vector<long>({(long)0, (long)1, (long)2, (long)6, (long)9}))) == (3));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)5, (long)8, (long)9}))) == (0));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_627_find_First_Missing","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to find the smallest missing number from a sorted vector of natural numbers.\nlong find_First_Missing(std::vector<long> array) {\n    long left = 0, right = array.size() - 1;\n\n    while (left <= right) {\n        long mid = left + (right - left) \/ 2;\n        \n        \/\/ Check if the mid index is equal to the value at the mid index\n        if (array[mid] == mid) {\n            \/\/ If they are equal, then the missing number must be in the right half\n            left = mid + 1;\n        } else {\n            \/\/ Otherwise, it must be in the left half, or could be the mid itself\n            right = mid - 1;\n        }\n    }\n\n    \/\/ The smallest missing number will be equal to the left index\n    return left;\n}\n```\n\nThis function `find_First_Missing` uses binary search to efficiently find the smallest missing number in a sorted vector of natural numbers. The idea here is that if the index matches the value at that index, it implies that all numbers up to that index are present and the first missing number must be in the right half. Otherwise, the first missing number is in the left half or could be the current middle index itself. This method ensures an O(log n) time complexity."}
{"name":"mbpp_628_replace_spaces","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to replace all spaces in the given string with '%20'.\nstd::string replace_spaces(std::string string) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_628_replace_spaces.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = replace_spaces;\n    assert(candidate((\"My Name is Dawood\")) == (\"My%20Name%20is%20Dawood\"));\n    assert(candidate((\"I am a Programmer\")) == (\"I%20am%20a%20Programmer\"));\n    assert(candidate((\"I love Coding\")) == (\"I%20love%20Coding\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_628_replace_spaces","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to replace all spaces in the given string with '%20'.\nstd::string replace_spaces(std::string str) {\n    std::string result;\n    for (char c : str) {\n        if (c == ' ') {\n            result += \"%20\";\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"name":"mbpp_629_Split","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find even numbers from a vector of numbers.\nstd::vector<long> Split(std::vector<long> list) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_629_Split.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = Split;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)2, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)7, (long)8, (long)0, (long)1}))) == (std::vector<long>({(long)4, (long)6, (long)8, (long)0})));\n    assert(candidate((std::vector<long>({(long)8, (long)12, (long)15, (long)19}))) == (std::vector<long>({(long)8, (long)12})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_629_Split","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to find even numbers from a vector of numbers.\nstd::vector<long> Split(std::vector<long> list) {\n    std::vector<long> evenNumbers;\n    \n    \/\/ Loop through all numbers in the input list\n    for(long number : list) {\n        \/\/ Check if the number is even\n        if(number % 2 == 0) {\n            \/\/ If even, add to the result list\n            evenNumbers.push_back(number);\n        }\n    }\n\n    return evenNumbers;\n}\n```"}
{"name":"mbpp_630_get_coordinates","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nstd::vector<std::vector<long>> get_coordinates(std::tuple<long, long> test_tup) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_630_get_coordinates.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = get_coordinates;\n    assert(candidate((std::make_tuple(3, 4))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)2, (long)4}), (std::vector<long>)std::vector<long>({(long)2, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)5}), (std::vector<long>)std::vector<long>({(long)4, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)4}), (std::vector<long>)std::vector<long>({(long)4, (long)5})})));\n    assert(candidate((std::make_tuple(4, 5))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)4, (long)4}), (std::vector<long>)std::vector<long>({(long)4, (long)5}), (std::vector<long>)std::vector<long>({(long)4, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)5}), (std::vector<long>)std::vector<long>({(long)5, (long)6})})));\n    assert(candidate((std::make_tuple(5, 6))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)4, (long)5}), (std::vector<long>)std::vector<long>({(long)4, (long)6}), (std::vector<long>)std::vector<long>({(long)4, (long)7}), (std::vector<long>)std::vector<long>({(long)5, (long)5}), (std::vector<long>)std::vector<long>({(long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)7}), (std::vector<long>)std::vector<long>({(long)6, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)6}), (std::vector<long>)std::vector<long>({(long)6, (long)7})})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_630_get_coordinates","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nstd::vector<std::vector<long>> get_coordinates(std::tuple<long, long> test_tup){\n    long x = std::get<0>(test_tup);\n    long y = std::get<1>(test_tup);\n    \n    std::vector<std::vector<long>> adjacent_coordinates = {\n        {x-1, y}, {x+1, y}, {x, y-1}, {x, y+1},\n        {x-1, y-1}, {x-1, y+1}, {x+1, y-1}, {x+1, y+1}\n    };\n\n    return adjacent_coordinates;\n}\n```"}
{"name":"mbpp_631_replace_spaces","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to replace whitespaces with an underscore and vice versa in a given string.\nstd::string replace_spaces(std::string text) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_631_replace_spaces.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = replace_spaces;\n    assert(candidate((\"Jumanji The Jungle\")) == (\"Jumanji_The_Jungle\"));\n    assert(candidate((\"The_Avengers\")) == (\"The Avengers\"));\n    assert(candidate((\"Fast and Furious\")) == (\"Fast_and_Furious\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_631_replace_spaces","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to replace whitespaces with an underscore and vice versa in a given string.\nstd::string replace_spaces(std::string text) {\n    for (char& c : text) {\n        if (c == ' ') {\n            c = '_';\n        } else if (c == '_') {\n            c = ' ';\n        }\n    }\n    return text;\n}\n```\n\nYou can test this function by calling it with different string inputs to see the replacements in action, but you need to do this outside of the provided code snippet since it shouldn't include a main function."}
{"name":"mbpp_632_move_zero","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to move all zeroes to the end of the given vector.\nstd::vector<long> move_zero(std::vector<long> num_list) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_632_move_zero.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = move_zero;\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)2, (long)0, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)0, (long)0})));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)2, (long)0, (long)0, (long)4, (long)0, (long)5, (long)0}))) == (std::vector<long>({(long)2, (long)3, (long)2, (long)4, (long)5, (long)0, (long)0, (long)0, (long)0})));\n    assert(candidate((std::vector<long>({(long)0, (long)1, (long)0, (long)1, (long)1}))) == (std::vector<long>({(long)1, (long)1, (long)1, (long)0, (long)0})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_632_move_zero","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cpp function to move all zeroes to the end of the given vector.\nstd::vector<long> move_zero(std::vector<long> num_list) {\n    int insert_pos = 0; \/\/ Position to insert a non-zero element\n    for(int i = 0; i < num_list.size(); i++) {\n        if(num_list[i] != 0) {\n            num_list[insert_pos++] = num_list[i];\n        }\n    }\n    \/\/ Fill remaining positions with zeroes\n    while(insert_pos < num_list.size()) {\n        num_list[insert_pos++] = 0;\n    }\n    return num_list;\n}\n\n\/\/ Test cases\nvoid test_move_zero() {\n    assert((move_zero({0, 1, 0, 3, 12}) == std::vector<long>({1, 3, 12, 0, 0})));\n    assert((move_zero({0, 0, 0, 0, 1}) == std::vector<long>({1, 0, 0, 0, 0})));\n    assert((move_zero({1, 2, 3, 4, 5}) == std::vector<long>({1, 2, 3, 4, 5})));\n    assert((move_zero({}) == std::vector<long>({})));\n    assert((move_zero({0, 0, 0, 0, 0}) == std::vector<long>({0, 0, 0, 0, 0})));\n    std::cout << \"All test cases pass!\" << std::endl;\n}\n\n\/\/ Uncomment to run the test cases\n\/\/ test_move_zero();\n```"}
{"name":"mbpp_633_pair_xor_Sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the sum of xor of all pairs of numbers in the given vector.\nlong pair_xor_Sum(std::vector<long> arr, long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_633_pair_xor_Sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = pair_xor_Sum;\n    assert(candidate((std::vector<long>({(long)5, (long)9, (long)7, (long)6})), (4)) == (47));\n    assert(candidate((std::vector<long>({(long)7, (long)3, (long)5})), (3)) == (12));\n    assert(candidate((std::vector<long>({(long)7, (long)3})), (2)) == (4));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_633_pair_xor_Sum","gpt_solution":"```cpp\n#include <vector>\n#include <bits\/stdc++.h>\n\n\/\/ Function to find the sum of xor of all pairs of numbers in the given vector.\nlong pair_xor_Sum(std::vector<long> arr, long n) {\n    long sum = 0; \n    \n    \/\/ Calculating sum of all pairs' XOR\n    for (long i = 0; i < n; ++i) {\n        for (long j = i + 1; j < n; ++j) {\n            sum += (arr[i] ^ arr[j]);\n        }\n    }\n    \n    return sum;\n}\n```\n\nIn this code, the function `pair_xor_Sum` calculates the sum of the XOR for all pairs of numbers in the given vector `arr`. It iterates over all pairs `(i, j)` where `i < j` and sums their XOR value."}
{"name":"mbpp_635_heap_sort","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to sort the given vector.\nstd::vector<long> heap_sort(std::vector<long> iterable) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_635_heap_sort.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = heap_sort;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)7, (long)9, (long)2, (long)4, (long)6, (long)8, (long)0}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9})));\n    assert(candidate((std::vector<long>({(long)25, (long)35, (long)22, (long)85, (long)14, (long)65, (long)75, (long)25, (long)58}))) == (std::vector<long>({(long)14, (long)22, (long)25, (long)25, (long)35, (long)58, (long)65, (long)75, (long)85})));\n    assert(candidate((std::vector<long>({(long)7, (long)1, (long)9, (long)5}))) == (std::vector<long>({(long)1, (long)5, (long)7, (long)9})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_635_heap_sort","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to sort the given vector.\nstd::vector<long> heap_sort(std::vector<long> iterable) {\n    \/\/ Convert the vector to a max heap\n    std::make_heap(iterable.begin(), iterable.end());\n\n    \/\/ Sort the elements in ascending order using the heap\n    std::sort_heap(iterable.begin(), iterable.end());\n\n    return iterable;\n}\n```"}
{"name":"mbpp_637_noprofit_noloss","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check whether the given amount has no profit and no loss\nbool noprofit_noloss(long actual_cost, long sale_amount) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_637_noprofit_noloss.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = noprofit_noloss;\n    assert(candidate((1500), (1200)) == (false));\n    assert(candidate((100), (100)) == (true));\n    assert(candidate((2000), (5000)) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_637_noprofit_noloss","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to check whether the given amount has no profit and no loss\nbool noprofit_noloss(long actual_cost, long sale_amount) {\n    return actual_cost == sale_amount;\n}\n```"}
{"name":"mbpp_638_wind_chill","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to calculate the wind chill index rounded to the next integer given the wind velocity in km\/h and a temperature in celsius.\nlong wind_chill(long v, long t) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_638_wind_chill.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = wind_chill;\n    assert(candidate((120), (35)) == (40));\n    assert(candidate((40), (20)) == (19));\n    assert(candidate((10), (8)) == (6));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_638_wind_chill","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to calculate the wind chill index rounded to the next integer given the wind velocity in km\/h and a temperature in celsius.\nlong wind_chill(long v, long t) {\n    \/\/ Wind chill index formula as per the National Weather Service (NWS) of the United States\n    \/\/ WCI = 13.12 + 0.6215*T - 11.37*v^0.16 + 0.3965*T*v^0.16\n    if (v < 0 || t > 10) {\n        throw std::invalid_argument(\"Invalid input: velocity should be non-negative and temperature should be <= 10 C\");\n    }\n    double wci = 13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16);\n    return std::round(wci);\n}\n```\n\n- In this code, a function `wind_chill` is defined that calculates the wind chill index based on the given wind velocity (`v`) and temperature (`t`).\n- The wind velocity must be a non-negative value, and the temperature must be less than or equal to 10\u00b0C.\n- The formula used is the one provided by the National Weather Service (NWS) of the United States.\n- The wind chill index is calculated and then rounded to the nearest integer using the `std::round` function.\n\nThis code doesn't include a main function and properly adheres to the specified requirements."}
{"name":"mbpp_639_sample_nam","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to sum the length of the names of a given vector of names after removing the names that start with a lowercase letter.\nlong sample_nam(std::vector<std::string> sample_names) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_639_sample_nam.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sample_nam;\n    assert(candidate((std::vector<std::string>({(std::string)\"sally\", (std::string)\"Dylan\", (std::string)\"rebecca\", (std::string)\"Diana\", (std::string)\"Joanne\", (std::string)\"keith\"}))) == (16));\n    assert(candidate((std::vector<std::string>({(std::string)\"php\", (std::string)\"res\", (std::string)\"Python\", (std::string)\"abcd\", (std::string)\"Java\", (std::string)\"aaa\"}))) == (10));\n    assert(candidate((std::vector<std::string>({(std::string)\"abcd\", (std::string)\"Python\", (std::string)\"abba\", (std::string)\"aba\"}))) == (6));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_639_sample_nam","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to sum the length of the names of a given vector of names \n\/\/ after removing the names that start with a lowercase letter.\nlong sample_nam(std::vector<std::string> sample_names) {\n    long sum_length = 0;\n    for (const auto& name : sample_names) {\n        if (!name.empty() && isupper(name[0])) {\n            sum_length += name.length();\n        }\n    }\n    return sum_length;\n}\n```"}
{"name":"mbpp_640_remove_parenthesis","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to remove the parenthesis and what is inbetween them from a string.\nstd::string remove_parenthesis(std::vector<std::string> items) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_640_remove_parenthesis.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = remove_parenthesis;\n    assert(candidate((std::vector<std::string>({(std::string)\"python (chrome)\"}))) == (\"python\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"string(.abc)\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"alpha(num)\"}))) == (\"alpha\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_640_remove_parenthesis","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to remove the parenthesis and what is inbetween them from a string.\nstd::string remove_parenthesis(std::string str) {\n    std::stack<char> s;\n    std::string result = \"\";\n    for (char c : str) {\n        if (c == '(') {\n            s.push(c);\n        } else if (c == ')') {\n            if (!s.empty()) {\n                s.pop();\n            }\n        } else {\n            if (s.empty()) {\n                result += c;\n            }\n        }\n    }\n    return result;\n}\n\n\/\/ Adding tests to check the function\nvoid test_remove_parenthesis() {\n    assert(remove_parenthesis(\"example(unwanted thing)example\") == \"exampleexample\");\n    assert(remove_parenthesis(\"a(b(c)d)e\") == \"ae\");\n    assert(remove_parenthesis(\"abc(d)e(fgh(ij)k)l\") == \"abcel\");\n    assert(remove_parenthesis(\"(first group)(second group)none\") == \"none\");\n    assert(remove_parenthesis(\"no(parentheses)here\") == \"nohere\");\n}\n\n\/\/ Calling test function manually (if not using a framework)\ntest_remove_parenthesis();\n```"}
{"name":"mbpp_641_is_nonagonal","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the nth nonagonal number.\nlong is_nonagonal(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_641_is_nonagonal.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = is_nonagonal;\n    assert(candidate((10)) == (325));\n    assert(candidate((15)) == (750));\n    assert(candidate((18)) == (1089));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_641_is_nonagonal","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the nth nonagonal number.\nlong is_nonagonal(long n) {\n    \/\/ Nonagonal number can be found using the formula: n * (7n - 5) \/ 2\n    return n * (7 * n - 5) \/ 2;\n}\n```\n\nThis code defines a function `is_nonagonal` that calculates the nth nonagonal number using the formula \\( n \\times (7n - 5) \/ 2 \\)."}
{"name":"mbpp_643_text_match_wordz_middle","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that checks if a strings contains 'z', except at the start and end of the word.\nbool text_match_wordz_middle(std::string text) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_643_text_match_wordz_middle.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = text_match_wordz_middle;\n    assert(candidate((\"pythonzabc.\")) == (true));\n    assert(candidate((\"zxyabc.\")) == (false));\n    assert(candidate((\"  lang  .\")) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_643_text_match_wordz_middle","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\nbool text_match_wordz_middle(std::string text) {\n    \/\/ Size of the string should be greater than 2 to have 'z' in the middle\n    if (text.length() <= 2) {\n        return false;\n    }\n\n    \/\/ Iterate over the string except the first and last character\n    for (int i = 1; i < text.length() - 1; ++i) {\n        if (text[i] == 'z') {\n            return true;\n        }\n    }\n\n    \/\/ If no 'z' found return false\n    return false;\n}\n\n\/\/ Sample unit test to verify the implementation\nvoid test_text_match_wordz_middle() {\n    assert(text_match_wordz_middle(\"azb\"));  \/\/ True: 'z' is in the middle\n    assert(text_match_wordz_middle(\"baz\"));  \/\/ True: 'z' is in the middle\n    assert(!text_match_wordz_middle(\"zbc\")); \/\/ False: 'z' is in the start\n    assert(!text_match_wordz_middle(\"bzc\")); \/\/ False: 'z' is in the end\n    assert(!text_match_wordz_middle(\"bz\"));  \/\/ False: 'z' can only be in 1st or last position\n    assert(!text_match_wordz_middle(\"ab\"));  \/\/ False: 'z' is not present\n    assert(!text_match_wordz_middle(\"szjtz\")); \/\/ True: 'z' is neither in the start nor end\n    std::cout << \"All test cases passed!\\n\";\n}\n\nvoid run_tests() {\n    test_text_match_wordz_middle();\n}\n```"}
{"name":"mbpp_644_reverse_Array_Upto_K","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to reverse a vector upto a given position.\nstd::vector<long> reverse_Array_Upto_K(std::vector<long> input, long k) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_644_reverse_Array_Upto_K.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = reverse_Array_Upto_K;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (4)) == (std::vector<long>({(long)4, (long)3, (long)2, (long)1, (long)5, (long)6})));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)7})), (2)) == (std::vector<long>({(long)5, (long)4, (long)6, (long)7})));\n    assert(candidate((std::vector<long>({(long)9, (long)8, (long)7, (long)6, (long)5})), (3)) == (std::vector<long>({(long)7, (long)8, (long)9, (long)6, (long)5})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_644_reverse_Array_Upto_K","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\nstd::vector<long> reverse_Array_Upto_K(std::vector<long> input, long k) {\n    \/\/ Ensure that k is within the bounds of the vector\n    if (k > input.size()) {\n        std::cerr << \"Error: k is larger than the size of the vector\" << std::endl;\n        return input;\n    }\n    \/\/ Reverse elements up to the k-th position\n    std::reverse(input.begin(), input.begin() + k);\n    return input;\n}\n```"}
{"name":"mbpp_720_add_dict_to_tuple","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to add a map to the tuple. The output should be a tuple.\nstd::tuple<long, long, long, std::map<std::string,long>> add_dict_to_tuple(std::tuple<long, long, long> test_tup, std::map<std::string,long> test_dict) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_720_add_dict_to_tuple.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = add_dict_to_tuple;\n    assert(candidate((std::make_tuple(4, 5, 6)), (std::map<std::string,long>({{\"MSAM\", 1}, {\"is\", 2}, {\"best\", 3}}))) == (std::make_tuple(4, 5, 6, std::map<std::string,long>({{\"MSAM\", 1}, {\"is\", 2}, {\"best\", 3}}))));\n    assert(candidate((std::make_tuple(1, 2, 3)), (std::map<std::string,long>({{\"UTS\", 2}, {\"is\", 3}, {\"Worst\", 4}}))) == (std::make_tuple(1, 2, 3, std::map<std::string,long>({{\"UTS\", 2}, {\"is\", 3}, {\"Worst\", 4}}))));\n    assert(candidate((std::make_tuple(8, 9, 10)), (std::map<std::string,long>({{\"POS\", 3}, {\"is\", 4}, {\"Okay\", 5}}))) == (std::make_tuple(8, 9, 10, std::map<std::string,long>({{\"POS\", 3}, {\"is\", 4}, {\"Okay\", 5}}))));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_720_add_dict_to_tuple","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to add a map to the tuple. The output should be a tuple.\nstd::tuple<long, long, long, std::map<std::string,long>> add_dict_to_tuple(std::tuple<long, long, long> test_tup, std::map<std::string,long> test_dict) {\n    \/\/ Use std::tuple_cat to concatenate the input tuple and a new tuple containing the map\n    return std::tuple_cat(test_tup, std::make_tuple(test_dict));\n}\n```"}
{"name":"mbpp_721_maxAverageOfPath","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfloat maxAverageOfPath(std::vector<std::vector<long>> cost) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_721_maxAverageOfPath.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = maxAverageOfPath;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)6, (long)5, (long)4}), (std::vector<long>)std::vector<long>({(long)7, (long)3, (long)9})}))) == (5.2f));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)7, (long)6, (long)5}), (std::vector<long>)std::vector<long>({(long)8, (long)4, (long)10})}))) == (6.2f));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)3, (long)4, (long)5}), (std::vector<long>)std::vector<long>({(long)8, (long)7, (long)6}), (std::vector<long>)std::vector<long>({(long)9, (long)5, (long)11})}))) == (7.2f));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})}))) == (5.8f));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_721_maxAverageOfPath","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. \n\/\/ A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. \n\/\/ We want to find a path with the maximum average over all existing paths. \n\/\/ Average is computed as total cost divided by the number of cells visited in the path.\nfloat maxAverageOfPath(std::vector<std::vector<long>> cost) {\n    int N = cost.size();\n    if (N == 0) return 0.0;\n\n    \/\/ Create dp array where dp[i][j] will store the maximum sum of costs to reach cell (i, j)\n    std::vector<std::vector<long>> dp(N, std::vector<long>(N, INT_MIN));\n    dp[0][0] = cost[0][0];\n\n    \/\/ Fill the dp array\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (i > 0) {\n                dp[i][j] = std::max(dp[i][j], dp[i-1][j] + cost[i][j]);\n            }\n            if (j > 0) {\n                dp[i][j] = std::max(dp[i][j], dp[i][j-1] + cost[i][j]);\n            }\n        }\n    }\n\n    \/\/ The number of cells in the best path will always be 2N-1 (including both start and end points)\n    int numberOfCells = 2 * N - 1;\n\n    \/\/ The average of the best path cost-wise\n    float maxAverage = (float)dp[N-1][N-1] \/ numberOfCells;\n\n    return maxAverage;\n}\n```"}
{"name":"mbpp_722_filter_data","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ The input is given as - a map with a student name as a key and a tuple of float (student_height, student_weight) as a value, - minimal height, - minimal weight. Write a function to filter students that have height and weight above the minimum.\nstd::map<std::string,std::tuple<float, long>> filter_data(std::map<std::string,std::tuple<float, long>> students, float h, long w) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_722_filter_data.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = filter_data;\n    assert(candidate((std::map<std::string,std::tuple<float, long>>({{\"Cierra Vega\", std::make_tuple(6.2f, 70)}, {\"Alden Cantrell\", std::make_tuple(5.9f, 65)}, {\"Kierra Gentry\", std::make_tuple(6.0f, 68)}, {\"Pierre Cox\", std::make_tuple(5.8f, 66)}})), (6.0f), (70)) == (std::map<std::string,std::tuple<float, long>>({{\"Cierra Vega\", std::make_tuple(6.2f, 70)}})));\n    assert(candidate((std::map<std::string,std::tuple<float, long>>({{\"Cierra Vega\", std::make_tuple(6.2f, 70)}, {\"Alden Cantrell\", std::make_tuple(5.9f, 65)}, {\"Kierra Gentry\", std::make_tuple(6.0f, 68)}, {\"Pierre Cox\", std::make_tuple(5.8f, 66)}})), (5.9f), (67)) == (std::map<std::string,std::tuple<float, long>>({{\"Cierra Vega\", std::make_tuple(6.2f, 70)}, {\"Kierra Gentry\", std::make_tuple(6.0f, 68)}})));\n    assert(candidate((std::map<std::string,std::tuple<float, long>>({{\"Cierra Vega\", std::make_tuple(6.2f, 70)}, {\"Alden Cantrell\", std::make_tuple(5.9f, 65)}, {\"Kierra Gentry\", std::make_tuple(6.0f, 68)}, {\"Pierre Cox\", std::make_tuple(5.8f, 66)}})), (5.7f), (64)) == (std::map<std::string,std::tuple<float, long>>({{\"Cierra Vega\", std::make_tuple(6.2f, 70)}, {\"Alden Cantrell\", std::make_tuple(5.9f, 65)}, {\"Kierra Gentry\", std::make_tuple(6.0f, 68)}, {\"Pierre Cox\", std::make_tuple(5.8f, 66)}})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_722_filter_data","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ The input is given as:\n\/\/ - a map with a student name as a key and a tuple of float (student_height, student_weight) as a value,\n\/\/ - minimal height,\n\/\/ - minimal weight.\n\/\/\n\/\/ Write a function to filter students that have height and weight above the minimum.\nstd::map<std::string, std::tuple<float, long>> filter_data(std::map<std::string, std::tuple<float, long>> students, float min_height, long min_weight) {\n    std::map<std::string, std::tuple<float, long>> filtered_students;\n    \n    for (const auto& [name, data] : students) {\n        float height = std::get<0>(data);\n        long weight = std::get<1>(data);\n\n        if (height > min_height && weight > min_weight) {\n            filtered_students[name] = data;\n        }\n    }\n    \n    return filtered_students;\n}\n```"}
{"name":"mbpp_723_count_same_pair","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ The input is defined as two vectors of the same length. Write a function to count indices where the vectors have the same values.\nlong count_same_pair(std::vector<long> nums1, std::vector<long> nums2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_723_count_same_pair.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = count_same_pair;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8})), (std::vector<long>({(long)2, (long)2, (long)3, (long)1, (long)2, (long)6, (long)7, (long)9}))) == (4));\n    assert(candidate((std::vector<long>({(long)0, (long)1, (long)2, (long)-1, (long)-5, (long)6, (long)0, (long)-3, (long)-2, (long)3, (long)4, (long)6, (long)8})), (std::vector<long>({(long)2, (long)1, (long)2, (long)-1, (long)-5, (long)6, (long)4, (long)-3, (long)-2, (long)3, (long)4, (long)6, (long)8}))) == (11));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-6, (long)-9, (long)11, (long)-12, (long)14, (long)-5, (long)17})), (std::vector<long>({(long)2, (long)1, (long)2, (long)-1, (long)-5, (long)6, (long)4, (long)-3, (long)-2, (long)3, (long)4, (long)6, (long)8}))) == (1));\n    assert(candidate((std::vector<long>({(long)0, (long)1, (long)1, (long)2})), (std::vector<long>({(long)0, (long)1, (long)2, (long)2}))) == (3));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_723_count_same_pair","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ The input is defined as two vectors of the same length.\n\/\/ Write a function to count indices where the vectors have the same values.\nlong count_same_pair(std::vector<long> nums1, std::vector<long> nums2) {\n    assert(nums1.size() == nums2.size()); \/\/ Ensure that both vectors are of the same length\n\n    long count = 0;\n    for (size_t i = 0; i < nums1.size(); ++i) {\n        if (nums1[i] == nums2[i]) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```"}
{"name":"mbpp_724_power_base_sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that takes base and power as arguments and calculate the sum of all digits of the base to the specified power.\nlong power_base_sum(long base, long power) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_724_power_base_sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = power_base_sum;\n    assert(candidate((2), (100)) == (115));\n    assert(candidate((8), (10)) == (37));\n    assert(candidate((8), (15)) == (62));\n    assert(candidate((3), (3)) == (9));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_724_power_base_sum","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function that takes base and power as arguments and calculate the sum of all digits of the base to the specified power.\nlong power_base_sum(long base, long power) {\n    \/\/ Calculate base^power\n    std::string result = std::to_string(std::pow(base, power));\n    \n    \/\/ Calculate sum of all digits in the result\n    long sum = 0;\n    for(char digit: result) {\n        if(isdigit(digit)) {\n            sum += digit - '0';\n        }\n    }\n    return sum;\n}\n```"}
{"name":"mbpp_725_extract_quotation","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to extract values between quotation marks \" \" of the given string.\nstd::vector<std::any> extract_quotation(std::string text1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_725_extract_quotation.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = extract_quotation;\n    assert(candidate((\"Cortex \"A53\" Based \"multi\" tasking \"Processor\"\")) == (std::vector<std::any>({(std::string)\"A53\", (std::string)\"multi\", (std::string)\"Processor\"})));\n    assert(candidate((\"Cast your \"favorite\" entertainment \"apps\"\")) == (std::vector<std::any>({(std::string)\"favorite\", (std::string)\"apps\"})));\n    assert(candidate((\"Watch content \"4k Ultra HD\" resolution with \"HDR 10\" Support\")) == (std::vector<std::any>({(std::string)\"4k Ultra HD\", (std::string)\"HDR 10\"})));\n    assert(candidate((\"Watch content '4k Ultra HD' resolution with 'HDR 10' Support\")) == (std::vector<std::any>()));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_725_extract_quotation","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to extract values between quotation marks \" \" of the given string.\nstd::vector<std::string> extract_quotation(std::string text1) {\n    std::vector<std::string> values;\n    std::regex re(\"\\\"([^\\\"]*)\\\"\");\n    std::smatch match;\n\n    while (std::regex_search(text1, match, re)) {\n        values.push_back(match[1].str());\n        text1 = match.suffix().str();\n    }\n\n    return values;\n}\n```\n\nThis function `extract_quotation` uses regular expressions to find and extract all substrings enclosed in quotation marks from the input string `text1`. The extracted substrings are stored in a vector of strings which is returned as the result."}
{"name":"mbpp_726_multiply_elements","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that takes as input a vector of numbers (t_1,...,t_{N+1}) and returns a vector of length N where the i-th element of the tuple is equal to t_i * t_{i+1}.\nstd::vector<std::any> multiply_elements(std::vector<long> test_tup) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_726_multiply_elements.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = multiply_elements;\n    assert(candidate((std::vector<long>({(long)1, (long)5, (long)7, (long)8, (long)10}))) == (std::vector<std::any>({(long)5, (long)35, (long)56, (long)80})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)5, (long)6, (long)7}))) == (std::vector<std::any>({(long)8, (long)20, (long)30, (long)42})));\n    assert(candidate((std::vector<long>({(long)12, (long)13, (long)14, (long)9, (long)15}))) == (std::vector<std::any>({(long)156, (long)182, (long)126, (long)135})));\n    assert(candidate((std::vector<long>({(long)12}))) == (std::vector<std::any>()));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_726_multiply_elements","gpt_solution":"```cpp\n#include <vector>\n#include <any>\n\nstd::vector<std::any> multiply_elements(std::vector<long> test_tup) {\n    std::vector<std::any> result;\n    if(test_tup.size() < 2) return result; \/\/ If the input vector has less than 2 elements, return an empty vector.\n    \n    for (size_t i = 0; i < test_tup.size() - 1; ++i) {\n        result.push_back(test_tup[i] * test_tup[i + 1]);\n    }\n    return result;\n}\n```\n\nThis function `multiply_elements` correctly takes a vector of `long` numbers as input and returns a vector of `std::any` where each element is the product of consecutive elements of the input vector."}
{"name":"mbpp_728_sum_list","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function takes as input two vectors [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\nstd::vector<long> sum_list(std::vector<long> lst1, std::vector<long> lst2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_728_sum_list.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sum_list;\n    assert(candidate((std::vector<long>({(long)10, (long)20, (long)30})), (std::vector<long>({(long)15, (long)25, (long)35}))) == (std::vector<long>({(long)25, (long)45, (long)65})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (std::vector<long>({(long)5, (long)6, (long)7}))) == (std::vector<long>({(long)6, (long)8, (long)10})));\n    assert(candidate((std::vector<long>({(long)15, (long)20, (long)30})), (std::vector<long>({(long)15, (long)45, (long)75}))) == (std::vector<long>({(long)30, (long)65, (long)105})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_728_sum_list","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function that takes as input two vectors [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\nstd::vector<long> sum_list(std::vector<long> lst1, std::vector<long> lst2) {\n    assert(lst1.size() == lst2.size()); \/\/ Ensure both vectors are of the same length\n    \n    std::vector<long> result(lst1.size());\n    \n    for (size_t i = 0; i < lst1.size(); ++i) {\n        result[i] = lst1[i] + lst2[i];\n    }\n    \n    return result;\n}\n``` \n\nThis function assumes that both input vectors have the same length and will return a new vector where each element is the sum of the corresponding elements from the input vectors. The `assert` statement ensures that the function will only work if the vectors are of the same length."}
{"name":"mbpp_730_consecutive_duplicates","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to remove consecutive duplicates of a given vector.\nstd::vector<std::any> consecutive_duplicates(std::vector<std::any> nums) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_730_consecutive_duplicates.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = consecutive_duplicates;\n    assert(candidate((std::vector<std::any>({(long)0, (long)0, (long)1, (long)2, (long)3, (long)4, (long)4, (long)5, (long)6, (long)6, (long)6, (long)7, (long)8, (long)9, (long)4, (long)4}))) == (std::vector<std::any>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)4})));\n    assert(candidate((std::vector<std::any>({(long)10, (long)10, (long)15, (long)19, (long)18, (long)18, (long)17, (long)26, (long)26, (long)17, (long)18, (long)10}))) == (std::vector<std::any>({(long)10, (long)15, (long)19, (long)18, (long)17, (long)26, (long)17, (long)18, (long)10})));\n    assert(candidate((std::vector<std::any>({(std::string)\"a\", (std::string)\"a\", (std::string)\"b\", (std::string)\"c\", (std::string)\"d\", (std::string)\"d\"}))) == (std::vector<std::any>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\", (std::string)\"d\"})));\n    assert(candidate((std::vector<std::any>({(std::string)\"a\", (std::string)\"a\", (std::string)\"b\", (std::string)\"c\", (std::string)\"d\", (std::string)\"d\", (std::string)\"a\", (std::string)\"a\"}))) == (std::vector<std::any>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\", (std::string)\"d\", (std::string)\"a\"})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_730_consecutive_duplicates","gpt_solution":"```cpp\n#include <any>\n#include <vector>\n#include <iostream>\n\nstd::vector<std::any> consecutive_duplicates(std::vector<std::any> nums) {\n    if (nums.empty()) {\n        return nums;\n    }\n\n    std::vector<std::any> result;\n    result.push_back(nums[0]);\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        if (nums[i] != nums[i - 1]) {\n            result.push_back(nums[i]);\n        }\n    }\n\n    return result;\n}\n```\n\nThis function checks for consecutive duplicates in the given vector and removes them. The function starts by adding the first element to the result vector and then iterates through the input vector starting from the second element. For each element, it compares it with the previous element and only adds it to the result vector if it is not a duplicate of the previous element."}
{"name":"mbpp_731_lateralsurface_cone","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the lateral surface area of a cone given radius r and the height h.\nfloat lateralsurface_cone(long r, long h) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_731_lateralsurface_cone.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = lateralsurface_cone;\n    assert(candidate((5), (12)) == (204.20352248333654f));\n    assert(candidate((10), (15)) == (566.3586699569488f));\n    assert(candidate((19), (17)) == (1521.8090132193388f));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_731_lateralsurface_cone","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\nfloat lateralsurface_cone(long r, long h) {\n    \/\/ lateral surface area of a cone is given by the formula: \u03c0 * r * l\n    \/\/ where l is the slant height of the cone\n    \/\/ l = sqrt(r^2 + h^2)\n    float l = sqrt(r * r + h * h);\n    float lateral_surface_area = M_PI * r * l;\n    return lateral_surface_area;\n}\n```"}
{"name":"mbpp_732_replace_specialchar","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to replace all occurrences of spaces, commas, or dots with a colon.\nstd::string replace_specialchar(std::string text) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_732_replace_specialchar.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = replace_specialchar;\n    assert(candidate((\"Python language, Programming language.\")) == (\"Python:language::Programming:language:\"));\n    assert(candidate((\"a b c,d e f\")) == (\"a:b:c:d:e:f\"));\n    assert(candidate((\"ram reshma,ram rahim\")) == (\"ram:reshma:ram:rahim\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_732_replace_specialchar","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to replace all occurrences of spaces, commas, or dots with a colon.\nstd::string replace_specialchar(std::string text) {\n    for (int i = 0; i < text.length(); ++i) {\n        if (text[i] == ' ' || text[i] == ',' || text[i] == '.') {\n            text[i] = ':';\n        }\n    }\n    return text;\n}\n```"}
{"name":"mbpp_733_find_first_occurrence","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the index of the first occurrence of a given number in a sorted vector.\nlong find_first_occurrence(std::vector<long> A, long x) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_733_find_first_occurrence.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_first_occurrence;\n    assert(candidate((std::vector<long>({(long)2, (long)5, (long)5, (long)5, (long)6, (long)6, (long)8, (long)9, (long)9, (long)9})), (5)) == (1));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)5, (long)5, (long)6, (long)6, (long)8, (long)9, (long)9, (long)9})), (5)) == (2));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)5, (long)6, (long)6, (long)8, (long)9, (long)9, (long)9})), (6)) == (4));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_733_find_first_occurrence","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to find the index of the first occurrence of a given number in a sorted vector.\nlong find_first_occurrence(std::vector<long> A, long x) {\n    long left = 0;\n    long right = A.size() - 1;\n    long result = -1;  \/\/ Initialize result to -1 to indicate not found\n\n    while (left <= right) {\n        long mid = left + (right - left) \/ 2;\n\n        if (A[mid] == x) {\n            result = mid;  \/\/ Update result to current mid index\n            right = mid - 1;  \/\/ Move to the left subarray to find earlier occurrence\n        } else if (A[mid] < x) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return result;\n}\n```"}
{"name":"mbpp_734_sum_Of_Subarray_Prod","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find sum of products of all possible subvectors of a given vector. https:\/\/www.geeksforgeeks.org\/sum-of-products-of-all-possible-subvectors\/\nlong sum_Of_Subarray_Prod(std::vector<long> arr) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_734_sum_Of_Subarray_Prod.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sum_Of_Subarray_Prod;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (20));\n    assert(candidate((std::vector<long>({(long)1, (long)2}))) == (5));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (84));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_734_sum_Of_Subarray_Prod","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to find the sum of products of all possible subvectors of a given vector\nlong sum_Of_Subarray_Prod(std::vector<long> arr) {\n    int n = arr.size();\n    long result = 0;\n    for (int i = 0; i < n; i++) {\n        long product = 1;\n        for (int j = i; j < n; j++) {\n            product *= arr[j];\n            result += product;\n        }\n    }\n    return result;\n}\n```\n\nThis code defines a function `sum_Of_Subarray_Prod` that returns the sum of products of all possible subvectors of a given vector `arr`. The function iterates through each starting index `i` and calculates the product of all subarrays starting from index `i` to `j`, then adds these products to the result."}
{"name":"mbpp_735_toggle_middle_bits","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to toggle bits of the number except the first and the last bit. https:\/\/www.geeksforgeeks.org\/toggle-bits-number-expect-first-last-bits\/\nlong toggle_middle_bits(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_735_toggle_middle_bits.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = toggle_middle_bits;\n    assert(candidate((9)) == (15));\n    assert(candidate((10)) == (12));\n    assert(candidate((11)) == (13));\n    assert(candidate((65)) == (127));\n    assert(candidate((77)) == (115));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_735_toggle_middle_bits","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cpp function to toggle bits of the number except the \n\/\/ first and the last bit. https:\/\/www.geeksforgeeks.org\/toggle-bits-number-expect-first-last-bits\/\nlong toggle_middle_bits(long n) {\n    \/\/ If the number has only one bit or two bits, nothing can be toggled\n    if (n < 3) return n;\n\n    \/\/ Find the number of bits in `n` excluding the first and last bit\n    int num_bits = floor(log2(n)) - 1;\n\n    \/\/ Calculate the mask for the middle bits\n    long mask = ((1L << num_bits) - 1) << 1; \n\n    \/\/ Toggle the middle bits\n    long result = n ^ mask;\n\n    return result;\n}\n```\n\nIn the above code:\n1. For numbers less than `3` (i.e., `0`, `1`, and `2`), no bits can be toggled as they either have no middle bits or only one middle bit.\n2. Calculate the number of bits in `n` excluding the first and last bit.\n3. Create a mask for the middle bits and then toggle those bits in `n` using XOR.\n\nThis should satisfy the problem requirement of toggling bits except the first and last bit."}
{"name":"mbpp_736_left_insertion","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to locate the left insertion point for a specified value in sorted order. https:\/\/www.w3resource.com\/cppthon-exercises\/data-structures-and-algorithms\/cppthon-data-structure-exercise-24.php\nlong left_insertion(std::vector<long> a, long x) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_736_left_insertion.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = left_insertion;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5})), (6)) == (4));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5})), (3)) == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5})), (7)) == (4));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_736_left_insertion","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to locate the left insertion point for a specified value in sorted order. https:\/\/www.w3resource.com\/cppthon-exercises\/data-structures-and-algorithms\/cppthon-data-structure-exercise-24.php\nlong left_insertion(std::vector<long> a, long x) {\n    return std::lower_bound(a.begin(), a.end(), x) - a.begin();\n}\n```\n\nExplanation:\n- The `left_insertion` function takes a sorted vector `a` of type `long` and a value `x` of type `long`.\n- It uses the `std::lower_bound` function to find the first position where `x` can be inserted without changing the order of the elements in the vector.\n- `std::lower_bound` returns an iterator pointing to the first element not less than `x`. \n- By subtracting `a.begin()` from this iterator, we get the index (position) of the left insertion point.\n"}
{"name":"mbpp_737_check_str","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check whether the given string is starting with a vowel or not using regex.\nbool check_str(std::string string) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_737_check_str.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = check_str;\n    assert(candidate((\"annie\")) == (true));\n    assert(candidate((\"dawood\")) == (false));\n    assert(candidate((\"Else\")) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_737_check_str","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n#include<regex>\n\n\/\/ Write a function to check whether the given string is starting with a vowel or not using regex.\nbool check_str(std::string string) {\n    \/\/ Define the regex pattern to match strings starting with a vowel (case insensitive)\n    std::regex pattern(\"^[aeiouAEIOU].*\");\n    \/\/ Return true if the string matches the regex pattern, otherwise false\n    return std::regex_match(string, pattern);\n}\n```"}
{"name":"mbpp_738_geometric_sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to calculate the geometric sum of n-1. https:\/\/www.w3resource.com\/cppthon-exercises\/data-structures-and-algorithms\/cppthon-recursion-exercise-9.php\nfloat geometric_sum(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_738_geometric_sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = geometric_sum;\n    assert(candidate((7)) == (1.9921875f));\n    assert(candidate((4)) == (1.9375f));\n    assert(candidate((8)) == (1.99609375f));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_738_geometric_sum","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n#include <assert.h>\n\n\/\/ Write a function to calculate the geometric sum of n-1. https:\/\/www.w3resource.com\/cppthon-exercises\/data-structures-and-algorithms\/cppthon-recursion-exercise-9.php\nfloat geometric_sum(long n) {\n    \/\/ Base Case: when n is 0\n    if (n == 0) return 1.0;\n\n    \/\/ Recursive Case\n    return 1.0 \/ pow(2, n) + geometric_sum(n - 1);\n}\n```"}
{"name":"mbpp_739_find_Index","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the index of smallest triangular number with n digits. https:\/\/www.geeksforgeeks.org\/index-of-smallest-triangular-number-with-n-digits\/\nlong find_Index(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_739_find_Index.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_Index;\n    assert(candidate((2)) == (4));\n    assert(candidate((3)) == (14));\n    assert(candidate((4)) == (45));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_739_find_Index","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\nusing namespace std;\n\nlong find_Index(long n) {\n    \/\/ A utility function to count number of digits in a number x\n    auto countDigits = [](long long x) {\n        return (long long)log10(x) + 1;\n    };\n\n    \/\/ Initialize lower and upper limits for the binary search\n    long long low = 1, high = 2e8; \/\/ This range is sufficiently large for practical purposes\n\n    \/\/ Perform binary search\n    while (low < high) {\n        long long mid = low + (high - low) \/ 2;\n\n        \/\/ Calculate mid-th triangular number\n        long long triangularNumber = (mid * (mid + 1)) \/ 2;\n\n        \/\/ Get the number of digits in the triangular number\n        long long digits = countDigits(triangularNumber);\n\n        if (digits < n) {\n            low = mid + 1; \/\/ Move to the right half\n        } else {\n            high = mid; \/\/ Move to the left half\n        }\n    }\n\n    \/\/ After the loop, low should be the smallest index yielding n-digit triangular number\n    return low;\n}\n```"}
{"name":"mbpp_740_tuple_to_dict","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to convert the given tuple to a key-value map using adjacent elements. https:\/\/www.geeksforgeeks.org\/cppthon-convert-tuple-to-adjacent-pair-map\/\nstd::map<long,long> tuple_to_dict(std::tuple<long, long, long, long, long, long> test_tup) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_740_tuple_to_dict.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = tuple_to_dict;\n    assert(candidate((std::make_tuple(1, 5, 7, 10, 13, 5))) == (std::map<long,long>({{1, 5}, {7, 10}, {13, 5}})));\n    assert(candidate((std::make_tuple(1, 2, 3, 4, 5, 6))) == (std::map<long,long>({{1, 2}, {3, 4}, {5, 6}})));\n    assert(candidate((std::make_tuple(7, 8, 9, 10, 11, 12))) == (std::map<long,long>({{7, 8}, {9, 10}, {11, 12}})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_740_tuple_to_dict","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to convert the given tuple to a key-value map using adjacent elements. \n\/\/ https:\/\/www.geeksforgeeks.org\/cppthon-convert-tuple-to-adjacent-pair-map\/\nstd::map<long, long> tuple_to_dict(std::tuple<long, long, long, long, long, long> test_tup) {\n    std::map<long, long> result;\n    result[std::get<0>(test_tup)] = std::get<1>(test_tup);\n    result[std::get<2>(test_tup)] = std::get{3}(test_tup);\n    result[std::get{4](test_tup)] = std::get{5}(test_tup);\n    return result;\n}\n```\n\nPlease note that the function `tuple_to_dict` has been implemented to convert a given tuple of six `long` integers into a map of keys and values based on adjacent elements in the tuple.\n"}
{"name":"mbpp_741_all_Characters_Same","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to check whether all the characters are same or not.\nbool all_Characters_Same(std::string s) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_741_all_Characters_Same.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = all_Characters_Same;\n    assert(candidate((\"python\")) == (false));\n    assert(candidate((\"aaa\")) == (true));\n    assert(candidate((\"data\")) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_741_all_Characters_Same","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cpp function to check whether all the characters are same or not.\nbool all_Characters_Same(std::string s) {\n    if (s.empty()) {\n        return true; \/\/ Consider empty string as true\n    }\n    char first_char = s[0];\n    for (char c : s) {\n        if (c != first_char) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"name":"mbpp_742_area_tetrahedron","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to caluclate the area of a tetrahedron.\nfloat area_tetrahedron(long side) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_742_area_tetrahedron.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = area_tetrahedron;\n    assert(candidate((3)) == (15.588457268119894f));\n    assert(candidate((20)) == (692.8203230275509f));\n    assert(candidate((10)) == (173.20508075688772f));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_742_area_tetrahedron","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Write a function to calculate the area of a tetrahedron.\nfloat area_tetrahedron(long side) {\n    \/\/ Area of a tetrahedron with side length 'a' is \u221a3 * a^2.\n    return sqrt(3) * side * side;\n}\n```\n\nThis function calculates the area of a tetrahedron given the length of its side. The formula used is:\n\\[ \\text{Area} = \\sqrt{3} \\times (\\text{side})^2 \\]"}
{"name":"mbpp_743_rotate_right","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to rotate a given vector by specified number of items to the right direction. https:\/\/www.geeksforgeeks.org\/cppthon-program-right-rotate-vector-n\/\nstd::vector<long> rotate_right(std::vector<long> list, long m) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_743_rotate_right.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = rotate_right;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10})), (3)) == (std::vector<long>({(long)8, (long)9, (long)10, (long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10})), (2)) == (std::vector<long>({(long)9, (long)10, (long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10})), (5)) == (std::vector<long>({(long)6, (long)7, (long)8, (long)9, (long)10, (long)1, (long)2, (long)3, (long)4, (long)5})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_743_rotate_right","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to rotate a given vector by specified number of items to the right direction. https:\/\/www.geeksforgeeks.org\/cppthon-program-right-rotate-vector-n\/\nstd::vector<long> rotate_right(std::vector<long> list, long m) {\n    long n = list.size();\n    if (n == 0) return list; \/\/ if list is empty, return it as is\n    m = m % n; \/\/ handle the cases where m >= n\n\n    std::reverse(list.begin(), list.end());\n    std::reverse(list.begin(), list.begin() + m);\n    std::reverse(list.begin() + m, list.end());\n\n    return list;\n}\n```"}
{"name":"mbpp_744_check_none","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check if the given tuple has any none value or not.\nbool check_none(std::any test_tup) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_744_check_none.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = check_none;\n    assert(candidate(std::make_tuple(std::optional<long>(10), std::optional<long>(4), std::optional<long>(5), std::optional<long>(6), std::optional<long>(std::nullopt))) == (true));\n    assert(candidate(std::make_tuple(7, 8, 9, 11, 14)) == (false));\n    assert(candidate(std::make_tuple(std::optional<long>(1), std::optional<long>(2), std::optional<long>(3), std::optional<long>(4), std::optional<long>(std::nullopt))) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_744_check_none","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to check if the given tuple has any none value or not.\nbool check_none(const std::vector<std::any>& test_tup) {\n    for (const auto& elem : test_tup) {\n        if (!elem.has_value()) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\nNote: Since C++ does not have a direct `None` equivalent like Python, this code checks if any element in the tuple (represented here by a `std::vector<std::any>`) does not contain any value using `std::any::has_value()` method."}
{"name":"mbpp_745_divisible_by_digits","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. https:\/\/www.w3resource.com\/cppthon-exercises\/lambda\/cppthon-lambda-exercise-24.php\nstd::vector<long> divisible_by_digits(long startnum, long endnum) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_745_divisible_by_digits.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = divisible_by_digits;\n    assert(candidate((1), (22)) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)11, (long)12, (long)15, (long)22})));\n    assert(candidate((1), (15)) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)11, (long)12, (long)15})));\n    assert(candidate((20), (25)) == (std::vector<long>({(long)22, (long)24})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_745_divisible_by_digits","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to check if a number is divisible by each of its digits\nbool isDivisibleByDigits(long num) {\n    long originalNum = num;\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit == 0 || originalNum % digit != 0) {\n            return false;\n        }\n        num \/= 10;\n    }\n    return true;\n}\n\n\/\/ Function to find numbers within a given range from startnum to endnum where every number is divisible by every digit it contains\nstd::vector<long> divisible_by_digits(long startnum, long endnum) {\n    std::vector<long> result;\n    for (long num = startnum; num <= endnum; ++num) {\n        if (isDivisibleByDigits(num)) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"name":"mbpp_746_sector_area","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find area of a sector. The function takes the radius and angle as inputs. Function should return None if the angle is larger than 360 degrees.\nstd::optional<float> sector_area(long r, long a) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_746_sector_area.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sector_area;\n    assert(candidate((4), (45)) == 6.283185307179586f);\n    assert(candidate((9), (45)) == 31.808625617596654f);\n    assert(candidate((9), (361)) == std::nullopt);\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_746_sector_area","gpt_solution":"```cpp\n#include <cassert>\n#include <bits\/stdc++.h>\n\n\/\/ Function to find area of a sector. The function takes the radius and angle\n\/\/ as inputs. Function should return None if the angle is larger than 360 degrees.\nstd::optional<float> sector_area(long r, long a) {\n    if (a > 360) {\n        return std::nullopt; \/\/ Return None if angle is larger than 360 degrees\n    }\n    \n    \/\/ Calculate the area of the sector using the formula: (angle\/360) * \u03c0 * r^2\n    float area = (a \/ 360.0) * M_PI * r * r;\n    \n    return area; \/\/ Return the calculated area\n}\n```\n\nThis code defines the `sector_area` function which calculates the area of a sector based on the given radius and angle. If the angle provided is greater than 360 degrees, the function returns `std::nullopt` indicating no value. Otherwise, it calculates and returns the area."}
{"name":"mbpp_747_lcs_of_three","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the longest common subsequence for the given three string sequence. https:\/\/www.geeksforgeeks.org\/lcs-longest-common-subsequence-three-strings\/\nlong lcs_of_three(std::string X, std::string Y, std::string Z) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_747_lcs_of_three.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = lcs_of_three;\n    assert(candidate((\"AGGT12\"), (\"12TXAYB\"), (\"12XBA\")) == (2));\n    assert(candidate((\"Reels\"), (\"Reelsfor\"), (\"ReelsforReels\")) == (5));\n    assert(candidate((\"abcd1e2\"), (\"bc12ea\"), (\"bd1ea\")) == (3));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_747_lcs_of_three","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to find the longest common subsequence for the given three string sequence\nlong lcs_of_three(std::string X, std::string Y, std::string Z) {\n    int m = X.length();\n    int n = Y.length();\n    int o = Z.length();\n\n    \/\/ Create a 3D array to store the lengths of longest common subsequence.\n    int dp[m+1][n+1][o+1];\n\n    \/\/ Initialize the dp array with 0s\n    memset(dp, 0, sizeof(dp));\n\n    \/\/ Fill the dp array\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            for (int k = 1; k <= o; k++) {\n                if (X[i-1] == Y[j-1] && X[i-1] == Z[k-1])\n                    dp[i][j][k] = dp[i-1][j-1][k-1] + 1;\n                else\n                    dp[i][j][k] = max(max(dp[i-1][j][k], dp[i][j-1][k]), dp[i][j][k-1]);\n            }\n        }\n    }\n    \/\/ The length of the longest common subsequence will be present at dp[m][n][o]\n    return dp[m][n][o];\n}\n```"}
{"name":"mbpp_748_capital_words_spaces","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to put spaces between words starting with capital letters in a given string.\nstd::string capital_words_spaces(std::string str1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_748_capital_words_spaces.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = capital_words_spaces;\n    assert(candidate((\"Python\")) == (\"Python\"));\n    assert(candidate((\"PythonProgrammingExamples\")) == (\"Python Programming Examples\"));\n    assert(candidate((\"GetReadyToBeCodingFreak\")) == (\"Get Ready To Be Coding Freak\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_748_capital_words_spaces","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to put spaces between words starting with capital letters in a given string.\nstd::string capital_words_spaces(std::string str1) {\n    \/\/ Define an output string stream\n    std::ostringstream oss;\n\n    \/\/ Iterate through the input string\n    for (size_t i = 0; i < str1.length(); ++i) {\n        \/\/ If the current character is an uppercase letter and it's not the first character,\n        \/\/ add a space before adding the letter to the output string\n        if (isupper(str1[i]) && i != 0) {\n            oss << ' ';\n        }\n        \/\/ Add the current character to the output string\n        oss << str1[i];\n    }\n\n    \/\/ Return the resulting string\n    return oss.str();\n}\n```"}
{"name":"mbpp_749_sort_numeric_strings","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to sort a given vector of strings of numbers numerically. https:\/\/www.geeksforgeeks.org\/cppthon-sort-numeric-strings-in-a-vector\/\nstd::vector<long> sort_numeric_strings(std::vector<std::string> nums_str) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_749_sort_numeric_strings.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sort_numeric_strings;\n    assert(candidate((std::vector<std::string>({(std::string)\"4\", (std::string)\"12\", (std::string)\"45\", (std::string)\"7\", (std::string)\"0\", (std::string)\"100\", (std::string)\"200\", (std::string)\"-12\", (std::string)\"-500\"}))) == (std::vector<long>({(long)-500, (long)-12, (long)0, (long)4, (long)7, (long)12, (long)45, (long)100, (long)200})));\n    assert(candidate((std::vector<std::string>({(std::string)\"2\", (std::string)\"3\", (std::string)\"8\", (std::string)\"4\", (std::string)\"7\", (std::string)\"9\", (std::string)\"8\", (std::string)\"2\", (std::string)\"6\", (std::string)\"5\", (std::string)\"1\", (std::string)\"6\", (std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"6\", (std::string)\"9\", (std::string)\"1\", (std::string)\"2\"}))) == (std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)2, (long)2, (long)2, (long)3, (long)3, (long)4, (long)4, (long)5, (long)6, (long)6, (long)6, (long)7, (long)8, (long)8, (long)9, (long)9})));\n    assert(candidate((std::vector<std::string>({(std::string)\"1\", (std::string)\"3\", (std::string)\"5\", (std::string)\"7\", (std::string)\"1\", (std::string)\"3\", (std::string)\"13\", (std::string)\"15\", (std::string)\"17\", (std::string)\"5\", (std::string)\"7 \", (std::string)\"9\", (std::string)\"1\", (std::string)\"11\"}))) == (std::vector<long>({(long)1, (long)1, (long)1, (long)3, (long)3, (long)5, (long)5, (long)7, (long)7, (long)9, (long)11, (long)13, (long)15, (long)17})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_749_sort_numeric_strings","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to sort a given vector of strings of numbers numerically. https:\/\/www.geeksforgeeks.org\/cppthon-sort-numeric-strings-in-a-vector\/\nstd::vector<long> sort_numeric_strings(std::vector<std::string> nums_str) {\n    std::vector<long> nums;\n    \n    \/\/ Convert strings to numbers\n    for (const auto& str : nums_str) {\n        nums.push_back(std::stol(str)); \/\/ converting string to long\n    }\n    \n    \/\/ Sort numbers\n    std::sort(nums.begin(), nums.end());\n    \n    return nums;\n}\n```\n\nThis code defines a function `sort_numeric_strings` which takes a vector of strings representing numbers and returns a vector of those numbers sorted in ascending order. The strings are first converted to long integers, then sorted, and the sorted vector is returned."}
{"name":"mbpp_750_add_tuple","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to add the given tuple to the given vector.\nstd::vector<long> add_tuple(std::vector<long> test_list, std::tuple<long, long> test_tup) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_750_add_tuple.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = add_tuple;\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7})), (std::make_tuple(9, 10))) == (std::vector<long>({(long)5, (long)6, (long)7, (long)9, (long)10})));\n    assert(candidate((std::vector<long>({(long)6, (long)7, (long)8})), (std::make_tuple(10, 11))) == (std::vector<long>({(long)6, (long)7, (long)8, (long)10, (long)11})));\n    assert(candidate((std::vector<long>({(long)7, (long)8, (long)9})), (std::make_tuple(11, 12))) == (std::vector<long>({(long)7, (long)8, (long)9, (long)11, (long)12})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_750_add_tuple","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to add the given tuple to the given vector.\nstd::vector<long> add_tuple(std::vector<long> test_list, std::tuple<long, long> test_tup) {\n    \/\/ Extract elements from the tuple\n    long first = std::get<0>(test_tup);\n    long second = std::get<1>(test_tup);\n    \n    \/\/ Add elements to the vector\n    test_list.push_back(first);\n    test_list.push_back(second);\n    \n    return test_list;\n}\n```"}
{"name":"mbpp_751_check_min_heap","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check if the given vector represents min heap or not. https:\/\/www.geeksforgeeks.org\/how-to-check-if-a-given-vector-represents-a-binary-heap\/\nbool check_min_heap(std::vector<long> arr) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_751_check_min_heap.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = check_min_heap;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}))) == (true));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)4, (long)5, (long)10, (long)15}))) == (true));\n    assert(candidate((std::vector<long>({(long)2, (long)10, (long)4, (long)5, (long)3, (long)15}))) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_751_check_min_heap","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to check if the given vector represents min heap or not. \n\/\/ https:\/\/www.geeksforgeeks.org\/how-to-check-if-a-given-vector-represents-a-binary-heap\/\nbool check_min_heap(std::vector<long> arr) {\n    int n = arr.size();\n    \n    \/\/ Traverse the array from the root to the last internal node\n    for (int i = 0; i <= (n - 2) \/ 2; i++) {\n        \/\/ If left child is greater, return false\n        if (arr[2 * i + 1] < arr[i])\n            return false;\n\n        \/\/ If right child exists and is greater, return false\n        if (2 * i + 2 < n && arr[2 * i + 2] < arr[i])\n            return false;\n    }\n\n    \/\/ If we reach here means the array represents a min-heap\n    return true;\n}\n```"}
{"name":"mbpp_752_jacobsthal_num","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the nth jacobsthal number. https:\/\/www.geeksforgeeks.org\/jacobsthal-and-jacobsthal-lucas-numbers\/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\nlong jacobsthal_num(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_752_jacobsthal_num.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = jacobsthal_num;\n    assert(candidate((5)) == (11));\n    assert(candidate((2)) == (1));\n    assert(candidate((4)) == (5));\n    assert(candidate((13)) == (2731));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_752_jacobsthal_num","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Write a function to find the nth jacobsthal number. https:\/\/www.geeksforgeeks.org\/jacobsthal-and-jacobsthal-lucas-numbers\/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\nlong jacobsthal_num(long n) {\n    if(n == 0)\n        return 0;\n    else if(n == 1)\n        return 1;\n    else {\n        long a = 0;\n        long b = 1;\n        for(long i = 2; i <= n; i++) {\n            long c = b + 2 * a;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n}\n\n\/\/ Example usage\nint main() {\n    assert(jacobsthal_num(0) == 0);\n    assert(jacobsthal_num(1) == 1);\n    assert(jacobsthal_num(2) == 1);\n    assert(jacobsthal_num(3) == 3);\n    assert(jacobsthal_num(4) == 5);\n    assert(jacobsthal_num(5) == 11);\n    assert(jacobsthal_num(6) == 21);\n    assert(jacobsthal_num(7) == 43);\n    assert(jacobsthal_num(8) == 85);\n    \n    cout << \"All test cases passed!\" << endl;\n\n    return 0;\n}\n```"}
{"name":"mbpp_753_min_k","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find minimum k records from tuple vector. https:\/\/www.geeksforgeeks.org\/cppthon-find-minimum-k-records-from-tuple-vector\/ - in this case a verbatim cocpp of test cases\nstd::vector<std::tuple<std::string, long>> min_k(std::vector<std::tuple<std::string, long>> test_list, long K) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_753_min_k.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = min_k;\n    assert(candidate((std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Manjeet\", 10), (std::tuple<std::string, long>)std::make_tuple(\"Akshat\", 4), (std::tuple<std::string, long>)std::make_tuple(\"Akash\", 2), (std::tuple<std::string, long>)std::make_tuple(\"Nikhil\", 8)})), (2)) == (std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Akash\", 2), (std::tuple<std::string, long>)std::make_tuple(\"Akshat\", 4)})));\n    assert(candidate((std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Sanjeev\", 11), (std::tuple<std::string, long>)std::make_tuple(\"Angat\", 5), (std::tuple<std::string, long>)std::make_tuple(\"Akash\", 3), (std::tuple<std::string, long>)std::make_tuple(\"Nepin\", 9)})), (3)) == (std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Akash\", 3), (std::tuple<std::string, long>)std::make_tuple(\"Angat\", 5), (std::tuple<std::string, long>)std::make_tuple(\"Nepin\", 9)})));\n    assert(candidate((std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"tanmay\", 14), (std::tuple<std::string, long>)std::make_tuple(\"Amer\", 11), (std::tuple<std::string, long>)std::make_tuple(\"Ayesha\", 9), (std::tuple<std::string, long>)std::make_tuple(\"SKD\", 16)})), (1)) == (std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Ayesha\", 9)})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_753_min_k","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to find minimum k records from tuple vector.\nstd::vector<std::tuple<std::string, long>> min_k(std::vector<std::tuple<std::string, long>> test_list, long K) {\n    \/\/ Sort the tuple vector based on the second value (long) in ascending order\n    std::sort(test_list.begin(), test_list.end(), [](const std::tuple<std::string, long>& a, const std::tuple<std::string, long>& b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n\n    \/\/ Get the first K elements from the sorted vector\n    std::vector<std::tuple<std::string, long>> result;\n    for (long i = 0; i < K && i < test_list.size(); ++i) {\n        result.push_back(test_list[i]);\n    }\n\n    return result;\n}\n```\n\nThis code defines the `min_k` function that takes a vector of tuples and a value `K` and returns the first `K` elements from the vector sorted by the second element of the tuples in ascending order. The function first sorts the vector using a lambda function that compares the second elements of the tuples, then collects the first `K` elements in a result vector, which is returned."}
{"name":"mbpp_754_extract_index_list","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ We say that an element is common for vectors l1, l2, l3 if it appears in all three vectors under the same index. Write a function to find common elements from three vectors. The function should return a vector.\nstd::vector<std::any> extract_index_list(std::vector<long> l1, std::vector<long> l2, std::vector<long> l3) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_754_extract_index_list.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = extract_index_list;\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)3, (long)4, (long)5, (long)6, (long)7})), (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5, (long)7})), (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5, (long)7}))) == (std::vector<std::any>({(long)1, (long)7})));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)3, (long)4, (long)5, (long)6, (long)7})), (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)6, (long)5})), (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)6, (long)7}))) == (std::vector<std::any>({(long)1, (long)6})));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)3, (long)4, (long)6, (long)5, (long)6})), (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5, (long)7})), (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5, (long)7}))) == (std::vector<std::any>({(long)1, (long)5})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)6, (long)6, (long)6})), (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5, (long)7})), (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5, (long)7}))) == (std::vector<std::any>()));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_754_extract_index_list","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ We say that an element is common for vectors l1, l2, l3 if it appears in all three vectors under the same index. \n\/\/ Write a function to find common elements from three vectors. The function should return a vector.\n\nstd::vector<long> extract_index_list(std::vector<long> l1, std::vector<long> l2, std::vector<long> l3) {\n    \/\/ Ensure all vectors have the same length\n    assert(l1.size() == l2.size() && l2.size() == l3.size());\n\n    std::vector<long> common_elements;\n\n    for (size_t i = 0; i < l1.size(); ++i) {\n        if (l1[i] == l2[i] && l2[i] == l3[i]) {\n            common_elements.push_back(l1[i]);\n        }\n    }\n\n    return common_elements;\n}\n```"}
{"name":"mbpp_755_second_smallest","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\nunion Union_long_float{\n    long f0;\n    float f1;    Union_long_float(long _f0) : f0(_f0) {}\n    Union_long_float(float _f1) : f1(_f1) {}\n    ~Union_long_float() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }\n};\n\/\/ Write a function to find the second smallest number in a vector.\nstd::optional<float> second_smallest(std::vector<Union_long_float> numbers) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_755_second_smallest.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = second_smallest;\n    assert(candidate((std::vector<Union_long_float>({(long)1, (long)2, (long)-8, (long)-2, (long)0, (long)-2}))) == -2);\n    assert(candidate((std::vector<Union_long_float>({(long)1, (long)1, (long)-0.5f, (long)0, (long)2, (long)-2, (long)-2}))) == -0.5f);\n    assert(candidate((std::vector<Union_long_float>({(long)2, (long)2}))) == std::nullopt);\n    assert(candidate((std::vector<Union_long_float>({(long)2, (long)2, (long)2}))) == std::nullopt);\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_755_second_smallest","gpt_solution":"```cpp\n#include <cassert>\n#include <bits\/stdc++.h>\n#include <optional>\n\nunion Union_long_float {\n    long f0;\n    float f1;\n    Union_long_float(long _f0) : f0(_f0) {}\n    Union_long_float(float _f1) : f1(_f1) {}\n    ~Union_long_float() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }\n    bool operator==(float f) {\n        return f1 == f ;\n    }\n};\n\nstd::optional<float> second_smallest(std::vector<Union_long_float> numbers) {\n    \/\/ Function to find the second smallest number in a vector.\n    \n    if (numbers.size() < 2) {\n        \/\/ If there are less than 2 elements, return std::nullopt\n        return std::nullopt;\n    }\n\n    std::optional<float> smallest = std::nullopt;\n    std::optional<float> second_smallest = std::nullopt;\n\n    for (auto& num : numbers) {\n        float value = num.f1; \/\/ Assuming we want to find the second smallest based on the float value\n        if (!smallest.has_value() || value < smallest.value()) {\n            second_smallest = smallest;\n            smallest = value;\n        } else if ((!second_smallest.has_value() || value < second_smallest.value()) && value != smallest.value()) {\n            second_smallest = value;\n        }\n    }\n\n    return second_smallest;\n}\n```"}
{"name":"mbpp_756_text_match_zero_one","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that matches a string that has an 'a' followed by one or more 'b's. https:\/\/www.w3resource.com\/cppthon-exercises\/re\/cppthon-re-exercise-3.php\nbool text_match_zero_one(std::string text) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_756_text_match_zero_one.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = text_match_zero_one;\n    assert(candidate((\"ac\")) == (false));\n    assert(candidate((\"dc\")) == (false));\n    assert(candidate((\"abbbba\")) == (true));\n    assert(candidate((\"dsabbbba\")) == (true));\n    assert(candidate((\"asbbbba\")) == (false));\n    assert(candidate((\"abaaa\")) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_756_text_match_zero_one","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n#include<regex>\n\n\/\/ Write a function that matches a string that has an 'a' followed by one or more 'b's.\nbool text_match_zero_one(std::string text) {\n    std::regex pattern(\"ab+\");\n    return std::regex_match(text, pattern);\n}\n```"}
{"name":"mbpp_757_count_reverse_pairs","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to count the pairs of reverse strings in the given string vector. https:\/\/www.geeksforgeeks.org\/cppthon-program-to-count-the-pairs-of-reverse-strings\/\nlong count_reverse_pairs(std::vector<std::string> test_list) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_757_count_reverse_pairs.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = count_reverse_pairs;\n    assert(candidate((std::vector<std::string>({(std::string)\"julia\", (std::string)\"best\", (std::string)\"tseb\", (std::string)\"for\", (std::string)\"ailuj\"}))) == (2));\n    assert(candidate((std::vector<std::string>({(std::string)\"geeks\", (std::string)\"best\", (std::string)\"for\", (std::string)\"skeeg\"}))) == (1));\n    assert(candidate((std::vector<std::string>({(std::string)\"makes\", (std::string)\"best\", (std::string)\"sekam\", (std::string)\"for\", (std::string)\"rof\"}))) == (2));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_757_count_reverse_pairs","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to count the pairs of reverse strings in the given string vector. \n\/\/ https:\/\/www.geeksforgeeks.org\/cppthon-program-to-count-the-pairs-of-reverse-strings\/\nlong count_reverse_pairs(std::vector<std::string> test_list) {\n    std::unordered_map<std::string, int> string_count;\n    long pair_count = 0;\n    \n    for (const auto& str : test_list) {\n        std::string rev_str = str;\n        std::reverse(rev_str.begin(), rev_str.end());\n        \n        \/\/ Check if the reversed string has already been seen\n        if (string_count.find(rev_str) != string_count.end()) {\n            pair_count += string_count[rev_str];\n        }\n        \n        \/\/ Increment the count of the current string\n        string_count[str]++;\n    }\n    \n    return pair_count;\n}\n```\n\nHere's an explanation of the code:\n1. A map (`string_count`) stores the count of each string encountered.\n2. For each string, its reverse is computed and checked in the map.\n3. If the reverse string is found in the map, it means there exists a reverse pair. The count of pairs is updated accordingly.\n4. The current string is then added to the map or its count incremented if it's already present."}
{"name":"mbpp_759_is_decimal","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check whether a given string is a decimal number with a precision of 2.\nbool is_decimal(std::string num) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_759_is_decimal.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = is_decimal;\n    assert(candidate((\"123.11\")) == (true));\n    assert(candidate((\"e666.86\")) == (false));\n    assert(candidate((\"3.124587\")) == (false));\n    assert(candidate((\"1.11\")) == (true));\n    assert(candidate((\"1.1.11\")) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_759_is_decimal","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to check whether a given string is a decimal number with a precision of 2.\nbool is_decimal(const std::string& num) {\n    \/\/ Check if the string is empty\n    if (num.empty()) {\n        return false;\n    }\n\n    \/\/ Use regex to match a decimal number with precision of 2\n    std::regex decimal_regex(R\"(^-?\\d+(\\.\\d{1,2})?$)\");\n\n    return std::regex_match(num, decimal_regex);\n}\n\n\/\/ Example usage\n\/\/ int main() {\n\/\/     assert(is_decimal(\"123.45\") == true);\n\/\/     assert(is_decimal(\"-123.45\") == true);\n\/\/     assert(is_decimal(\"123.4\") == true);\n\/\/     assert(is_decimal(\"123\") == true);\n\/\/     assert(is_decimal(\"123.\") == false);\n\/\/     assert(is_decimal(\"123.456\") == false);\n\/\/     assert(is_decimal(\"abc\") == false);\n\/\/     return 0;\n\/\/ }\n```"}
{"name":"mbpp_760_unique_Element","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to check whether a vector of numbers contains only one distinct element or not.\nbool unique_Element(std::vector<long> arr) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_760_unique_Element.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = unique_Element;\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_760_unique_Element","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Write a cppthon function to check whether a vector of numbers contains only one distinct element or not.\nbool unique_Element(std::vector<long> arr) {\n    if (arr.empty()) return false; \/\/ If the array is empty, there can't be one distinct element\n    long first_element = arr[0];\n    for (const auto& el : arr) {\n        if (el != first_element) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"name":"mbpp_762_check_monthnumber_number","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check whether the given month number contains 30 days or not. Months are given as number from 1 to 12.\nbool check_monthnumber_number(long monthnum3) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_762_check_monthnumber_number.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = check_monthnumber_number;\n    assert(candidate((6)) == (true));\n    assert(candidate((2)) == (false));\n    assert(candidate((12)) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_762_check_monthnumber_number","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to check whether the given month number contains 30 days or not. \n\/\/ Months are given as number from 1 to 12.\nbool check_monthnumber_number(long monthnum3) {\n    \/\/ Months with 30 days: April(4), June(6), September(9), November(11)\n    if (monthnum3 == 4 || monthnum3 == 6 || monthnum3 == 9 || monthnum3 == 11) {\n        return true;\n    } else {\n        return false;\n    }\n}\n```"}
{"name":"mbpp_763_find_min_diff","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the minimum difference between any two elements in a given vector. https:\/\/www.geeksforgeeks.org\/find-minimum-difference-pair\/\nlong find_min_diff(std::vector<long> arr, long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_763_find_min_diff.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_min_diff;\n    assert(candidate((std::vector<long>({(long)1, (long)5, (long)3, (long)19, (long)18, (long)25})), (6)) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)6})), (4)) == (1));\n    assert(candidate((std::vector<long>({(long)30, (long)5, (long)20, (long)9})), (4)) == (4));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_763_find_min_diff","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cpp function to find the minimum difference between any two elements in a given vector.\n\/\/ https:\/\/www.geeksforgeeks.org\/find-minimum-difference-pair\/\nlong find_min_diff(std::vector<long> arr, long n) {\n    if (n < 2) {\n        return -1;  \/\/ Not enough elements to compare\n    }\n\n    \/\/ Sort the array\n    std::sort(arr.begin(), arr.end());\n\n    \/\/ Initialize the minimum difference as a large number\n    long min_diff = LONG_MAX;\n\n    \/\/ Find the minimum difference by comparing adjacent sorted elements\n    for (long i = 1; i < n; i++) {\n        long diff = arr[i] - arr[i-1];\n        if (diff < min_diff) {\n            min_diff = diff;\n        }\n    }\n\n    return min_diff;\n}\n```"}
{"name":"mbpp_764_number_ctr","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to count number of digits in a given string.\nlong number_ctr(std::string str) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_764_number_ctr.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = number_ctr;\n    assert(candidate((\"program2bedone\")) == (1));\n    assert(candidate((\"3wonders\")) == (1));\n    assert(candidate((\"123\")) == (3));\n    assert(candidate((\"3wond-1ers2\")) == (3));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_764_number_ctr","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cpp function to count the number of digits in a given string.\nlong number_ctr(std::string str) {\n    long count = 0;\n    for (char c : str) {\n        if (isdigit(c)) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"name":"mbpp_765_is_polite","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find nth polite number. geeksforgeeks.org\/n-th-polite-number\/\nlong is_polite(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_765_is_polite.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = is_polite;\n    assert(candidate((7)) == (11));\n    assert(candidate((4)) == (7));\n    assert(candidate((9)) == (13));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_765_is_polite","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\nusing namespace std;\n\nbool isPowerOfTwo(long x)\n{\n    return x && (!(x & (x - 1)));\n}\n\nlong nth_polite_number(long n) {\n    int count = 0;\n    for (long i = 1; ; ++i) {\n        if (!isPowerOfTwo(i)) {\n            ++count;\n            if (count == n) {\n                return i;\n            }\n        }\n    }\n}\n```\n\nIn this code, we are using a function `isPowerOfTwo` to check if a number is a power of two. Polite numbers are the numbers that are not powers of two. We iterate through the numbers starting from 1, and for each number that is not a power of two, we increment our count. When our count reaches `n`, we return that number as the nth polite number."}
{"name":"mbpp_766_pair_wise","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to return a vector of all pairs of consecutive items in a given vector.\nstd::vector<std::tuple<long, long>> pair_wise(std::vector<long> l1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_766_pair_wise.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = pair_wise;\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)3, (long)3, (long)4, (long)4, (long)5}))) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(1, 1), (std::tuple<long, long>)std::make_tuple(1, 2), (std::tuple<long, long>)std::make_tuple(2, 3), (std::tuple<long, long>)std::make_tuple(3, 3), (std::tuple<long, long>)std::make_tuple(3, 4), (std::tuple<long, long>)std::make_tuple(4, 4), (std::tuple<long, long>)std::make_tuple(4, 5)})));\n    assert(candidate((std::vector<long>({(long)1, (long)5, (long)7, (long)9, (long)10}))) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(1, 5), (std::tuple<long, long>)std::make_tuple(5, 7), (std::tuple<long, long>)std::make_tuple(7, 9), (std::tuple<long, long>)std::make_tuple(9, 10)})));\n    assert(candidate((std::vector<long>({(long)5, (long)1, (long)9, (long)7, (long)10}))) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(5, 1), (std::tuple<long, long>)std::make_tuple(1, 9), (std::tuple<long, long>)std::make_tuple(9, 7), (std::tuple<long, long>)std::make_tuple(7, 10)})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(1, 2), (std::tuple<long, long>)std::make_tuple(2, 3), (std::tuple<long, long>)std::make_tuple(3, 4), (std::tuple<long, long>)std::make_tuple(4, 5), (std::tuple<long, long>)std::make_tuple(5, 6), (std::tuple<long, long>)std::make_tuple(6, 7), (std::tuple<long, long>)std::make_tuple(7, 8), (std::tuple<long, long>)std::make_tuple(8, 9), (std::tuple<long, long>)std::make_tuple(9, 10)})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_766_pair_wise","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to return a vector of all pairs of consecutive items in a given vector.\nstd::vector<std::tuple<long, long>> pair_wise(std::vector<long> l1) {\n    std::vector<std::tuple<long, long>> result;\n    \n    if(l1.size() < 2) {\n        \/\/ If there are less than two elements, return an empty vector\n        return result;\n    }\n    \n    for(size_t i = 0; i < l1.size() - 1; ++i) {\n        result.push_back(std::make_tuple(l1[i], l1[i + 1]));\n    }\n    \n    return result;\n}\n```"}
{"name":"mbpp_767_get_pairs_count","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to count the number of pairs whose sum is equal to \u2018sum\u2019. The funtion gets as input a vector of numbers and the sum,\nlong get_pairs_count(std::vector<long> arr, long sum) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_767_get_pairs_count.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = get_pairs_count;\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1})), (2)) == (6));\n    assert(candidate((std::vector<long>({(long)1, (long)5, (long)7, (long)-1, (long)5})), (6)) == (3));\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)3})), (1)) == (1));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)3})), (-3)) == (1));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_767_get_pairs_count","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\nlong get_pairs_count(std::vector<long> arr, long sum) {\n    \/\/ Create a map to store the frequency of each element in the array\n    std::unordered_map<long, long> freq_map;\n    for (long num : arr) {\n        freq_map[num]++;\n    }\n\n    long count = 0;\n\n    \/\/ Iterate through each element in the array and find pairs\n    for (long num : arr) {\n        long complement = sum - num;\n        \n        \/\/ Check the frequency of the complement in the map\n        if (freq_map.find(complement) != freq_map.end()) {\n            count += freq_map[complement];\n        }\n\n        \/\/ If complement is equal to the current number, \n        \/\/ then we need to decrease the count by one \n        \/\/ because we would have counted the pair (num, num) as valid\n        if (complement == num) {\n            count--;\n        }\n    }\n\n    \/\/ Each pair is counted twice, so divide by 2\n    return count \/ 2;\n}\n```\n\nThis C++ function `get_pairs_count` takes a vector of numbers and a target sum, and returns the count of pairs in the vector that add up to the target sum. The function uses an unordered map to store the frequency of each number and efficiently computes the count of valid pairs by iterating through the array and using the map for look-ups."}
{"name":"mbpp_769_Diff","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to get the difference between two vectors.\nstd::vector<long> Diff(std::vector<long> li1, std::vector<long> li2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_769_Diff.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = Diff;\n    assert(candidate((std::vector<long>({(long)10, (long)15, (long)20, (long)25, (long)30, (long)35, (long)40})), (std::vector<long>({(long)25, (long)40, (long)35}))) == (std::vector<long>({(long)10, (long)20, (long)30, (long)15})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})), (std::vector<long>({(long)6, (long)7, (long)1}))) == (std::vector<long>({(long)2, (long)3, (long)4, (long)5, (long)6, (long)7})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (std::vector<long>({(long)6, (long)7, (long)1}))) == (std::vector<long>({(long)2, (long)3, (long)6, (long)7})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_769_Diff","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a C++ function to get the difference between two vectors.\nstd::vector<long> Diff(std::vector<long> li1, std::vector<long> li2) {\n    std::vector<long> diff_vector;\n    std::unordered_set<long> set_li2(li2.begin(), li2.end());\n\n    for (const auto& item : li1) {\n        if (set_li2.find(item) == set_li2.end()) {\n            diff_vector.push_back(item);\n        }\n    }\n\n    return diff_vector;\n}\n```"}
{"name":"mbpp_770_odd_num_sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the sum of fourth power of first n odd natural numbers.\nlong odd_num_sum(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_770_odd_num_sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = odd_num_sum;\n    assert(candidate((2)) == (82));\n    assert(candidate((3)) == (707));\n    assert(candidate((4)) == (3108));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_770_odd_num_sum","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to find the sum of the fourth power of the first n odd natural numbers.\nlong odd_num_sum(long n) {\n    long sum = 0;\n    long odd_num = 1;\n\n    for (long i = 0; i < n; ++i) {\n        sum += pow(odd_num, 4);\n        odd_num += 2;\n    }\n\n    return sum;\n}\n\n\/\/ Test cases to validate the solution\nvoid test() {\n    assert(odd_num_sum(1) == 1);  \/\/ 1^4 = 1\n    assert(odd_num_sum(2) == 82);  \/\/ 1^4 + 3^4 = 1 + 81 = 82\n    assert(odd_num_sum(3) == 914);  \/\/ 1^4 + 3^4 + 5^4 = 1 + 81 + 625 = 707\n    assert(odd_num_sum(0) == 0);  \/\/ No odd numbers, sum is 0\n    assert(odd_num_sum(4) == 6354); \/\/ 1^4 + 3^4 + 5^4 + 7^4 = 1 + 81 + 625 + 2401 + 2401 = 6354\n}\n\ntest();\n```"}
{"name":"mbpp_771_check_expression","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check if the given expression is balanced or not. https:\/\/www.geeksforgeeks.org\/check-for-balanced-parentheses-in-an-expression\/\nbool check_expression(std::string exp) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_771_check_expression.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = check_expression;\n    assert(candidate((\"{()}[{}]\")) == (true));\n    assert(candidate((\"{()}[{]\")) == (false));\n    assert(candidate((\"{()}[{}][]({})\")) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_771_check_expression","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\nbool check_expression(std::string exp) {\n    std::stack<char> s;\n    for(char& ch : exp) {\n        if(ch == '(' || ch == '[' || ch == '{') {\n            s.push(ch);\n        } else if(ch == ')' || ch == ']' || ch == '}') {\n            if(s.empty()) {\n                return false;\n            } else {\n                char top = s.top();\n                s.pop();\n                if((ch == ')' && top != '(') ||\n                   (ch == ']' && top != '[') ||\n                   (ch == '}' && top != '{')) {\n                    return false;\n                }\n            }\n        }\n    }\n    return s.empty();\n}\n```"}
{"name":"mbpp_772_remove_length","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to remove all the words with k length in the given string.\nstd::string remove_length(std::string test_str, long K) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_772_remove_length.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = remove_length;\n    assert(candidate((\"The person is most value tet\"), (3)) == (\"person is most value\"));\n    assert(candidate((\"If you told me about this ok\"), (4)) == (\"If you me about ok\"));\n    assert(candidate((\"Forces of darkeness is come into the play\"), (4)) == (\"Forces of darkeness is the\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_772_remove_length","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to remove all the words with k length in the given string.\nstd::string remove_length(std::string test_str, long K) {\n    std::istringstream stream(test_str);\n    std::string word;\n    std::string result;\n    while (stream >> word) {\n        if (word.length() != K) {\n            if (!result.empty()) {\n                result += \" \";\n            }\n            result += word;\n        }\n    }\n    return result;\n}\n```"}
{"name":"mbpp_773_occurance_substring","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the occurrence and position of the substrings within a string. Return None if there is no match.\nstd::optional<std::tuple<std::string, long, long>> occurance_substring(std::string text, std::string pattern) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_773_occurance_substring.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = occurance_substring;\n    assert(candidate((\"python programming, python language\"), (\"python\")) == std::make_tuple(\"python\", 0, 6));\n    assert(candidate((\"python programming,programming language\"), (\"programming\")) == std::make_tuple(\"programming\", 7, 18));\n    assert(candidate((\"python programming,programming language\"), (\"language\")) == std::make_tuple(\"language\", 31, 39));\n    assert(candidate((\"c++ programming, c++ language\"), (\"python\")) == std::nullopt);\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_773_occurance_substring","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n#include<optional>\n\n\/\/ Write a function to find the occurrence and position of the substrings within a string. Return None if there is no match.\nstd::optional<std::tuple<std::string, long, long>> occurance_substring(std::string text, std::string pattern) {\n    \/\/ Find the first occurrence of pattern in text\n    size_t pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        \/\/ If pattern not found, return None\n        return std::nullopt;\n    } else {\n        long count = 0;\n        \/\/ Loop to count occurrences of pattern\n        for (size_t start_pos = pos; start_pos != std::string::npos; start_pos = text.find(pattern, start_pos + pattern.length())) {\n            ++count;\n        }\n        \/\/ Return the pattern, occurrence count, and first position\n        return std::make_tuple(pattern, count, pos);\n    }\n}\n```"}
{"name":"mbpp_775_odd_position","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to check whether every odd index contains odd numbers of a given vector.\nbool odd_position(std::vector<long> nums) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_775_odd_position.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = odd_position;\n    assert(candidate((std::vector<long>({(long)2, (long)1, (long)4, (long)3, (long)6, (long)7, (long)6, (long)3}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_775_odd_position","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cpp function to check whether every odd index contains odd numbers of a given vector.\nbool odd_position(std::vector<long> nums) {\n    for (size_t i = 1; i < nums.size(); i += 2) {\n        if (nums[i] % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid test() {\n    assert(odd_position({1, 3, 5, 7, 9, 11}) == true);\n    assert(odd_position({1, 2, 3, 4, 5, 6}) == false);\n    assert(odd_position({2, 3, 4, 5}) == true);\n    assert(odd_position({2, 4, 6, 8}) == false);\n    assert(odd_position({}) == true);\n    assert(odd_position({1}) == true);\n    assert(odd_position({1, 3}) == true);\n    assert(odd_position({1, 2}) == false);\n}\n\ntest();\n```"}
{"name":"mbpp_776_count_vowels","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to count those characters which have vowels as their neighbors in the given string.\nlong count_vowels(std::string test_str) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_776_count_vowels.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = count_vowels;\n    assert(candidate((\"bestinstareels\")) == (7));\n    assert(candidate((\"partofthejourneyistheend\")) == (12));\n    assert(candidate((\"amazonprime\")) == (5));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_776_count_vowels","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\nusing namespace std;\n\nbool is_vowel(char ch) {\n    ch = tolower(ch);\n    return (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u');\n}\n\n\/\/ Write a function to count those characters which have vowels as their neighbors in the given string.\nlong count_vowels(string test_str) {\n    long count = 0;\n    int n = test_str.length();\n    \n    for(int i = 1; i < n - 1; ++i) {\n        if (is_vowel(test_str[i - 1]) && is_vowel(test_str[i + 1])) {\n            ++count;\n        }\n    }\n    \n    return count;\n}\n```\n\nHere, the `is_vowel` function is used to check if a character is a vowel. The `count_vowels` function then iterates through the string and checks each character that is between two vowels. If both neighbors of a character are vowels, it increments the count."}
{"name":"mbpp_777_find_sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the sum of non-repeated elements in a given vector.\nlong find_sum(std::vector<long> arr) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_777_find_sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_sum;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)1, (long)1, (long)4, (long)5, (long)6}))) == (21));\n    assert(candidate((std::vector<long>({(long)1, (long)10, (long)9, (long)4, (long)2, (long)10, (long)10, (long)45, (long)4}))) == (71));\n    assert(candidate((std::vector<long>({(long)12, (long)10, (long)9, (long)45, (long)2, (long)10, (long)10, (long)45, (long)10}))) == (78));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_777_find_sum","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n\n\/\/ Write a C++ function to find the sum of non-repeated elements in a given vector.\nlong find_sum(std::vector<long> arr) {\n    std::unordered_map<long, int> elementCount;\n    for (const auto& num : arr) {\n        elementCount[num]++;\n    }\n\n    long sum = 0;\n    for (const auto& pair : elementCount) {\n        if (pair.second == 1) {\n            sum += pair.first;\n        }\n    }\n\n    return sum;\n}\n```"}
{"name":"mbpp_778_pack_consecutive_duplicates","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to pack consecutive duplicates of a given vector elements into subvectors.\nstd::vector<std::vector<std::any>> pack_consecutive_duplicates(std::vector<std::any> list1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_778_pack_consecutive_duplicates.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = pack_consecutive_duplicates;\n    assert(candidate((std::vector<std::any>({(long)0, (long)0, (long)1, (long)2, (long)3, (long)4, (long)4, (long)5, (long)6, (long)6, (long)6, (long)7, (long)8, (long)9, (long)4, (long)4}))) == (std::vector<std::vector<std::any>>({(std::vector<long>)std::vector<long>({(long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)2}), (std::vector<long>)std::vector<long>({(long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)4}), (std::vector<long>)std::vector<long>({(long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)6, (long)6}), (std::vector<long>)std::vector<long>({(long)7}), (std::vector<long>)std::vector<long>({(long)8}), (std::vector<long>)std::vector<long>({(long)9}), (std::vector<long>)std::vector<long>({(long)4, (long)4})})));\n    assert(candidate((std::vector<std::any>({(long)10, (long)10, (long)15, (long)19, (long)18, (long)18, (long)17, (long)26, (long)26, (long)17, (long)18, (long)10}))) == (std::vector<std::vector<std::any>>({(std::vector<long>)std::vector<long>({(long)10, (long)10}), (std::vector<long>)std::vector<long>({(long)15}), (std::vector<long>)std::vector<long>({(long)19}), (std::vector<long>)std::vector<long>({(long)18, (long)18}), (std::vector<long>)std::vector<long>({(long)17}), (std::vector<long>)std::vector<long>({(long)26, (long)26}), (std::vector<long>)std::vector<long>({(long)17}), (std::vector<long>)std::vector<long>({(long)18}), (std::vector<long>)std::vector<long>({(long)10})})));\n    assert(candidate((std::vector<std::any>({(std::string)\"a\", (std::string)\"a\", (std::string)\"b\", (std::string)\"c\", (std::string)\"d\", (std::string)\"d\"}))) == (std::vector<std::vector<std::any>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"a\", (std::string)\"a\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"b\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"c\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"d\", (std::string)\"d\"})})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_778_pack_consecutive_duplicates","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to pack consecutive duplicates of a given vector elements into subvectors.\nstd::vector<std::vector<std::any>> pack_consecutive_duplicates(std::vector<std::any> list1) {\n    std::vector<std::vector<std::any>> result;\n    \n    if (list1.empty()) return result;\n    \n    std::vector<std::any> currentSubvector;\n    std::any previousElement = list1[0];\n    \n    for (const auto& element : list1) {\n        if (element == previousElement) {\n            currentSubvector.push_back(element);\n        } else {\n            result.push_back(currentSubvector);\n            currentSubvector.clear();\n            currentSubvector.push_back(element);\n        }\n        previousElement = element;\n    }\n    \n    result.push_back(currentSubvector);\n    \n    return result;\n}\n```"}
{"name":"mbpp_780_find_combinations","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the combinations of sums with tuples in the given tuple vector. https:\/\/www.geeksforgeeks.org\/cppthon-combinations-of-sum-with-tuples-in-tuple-vector\/\nstd::vector<std::tuple<long, long>> find_combinations(std::vector<std::tuple<long, long>> test_list) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_780_find_combinations.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = find_combinations;\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 4), (std::tuple<long, long>)std::make_tuple(6, 7), (std::tuple<long, long>)std::make_tuple(5, 1), (std::tuple<long, long>)std::make_tuple(6, 10)}))) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(8, 11), (std::tuple<long, long>)std::make_tuple(7, 5), (std::tuple<long, long>)std::make_tuple(8, 14), (std::tuple<long, long>)std::make_tuple(11, 8), (std::tuple<long, long>)std::make_tuple(12, 17), (std::tuple<long, long>)std::make_tuple(11, 11)})));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(3, 5), (std::tuple<long, long>)std::make_tuple(7, 8), (std::tuple<long, long>)std::make_tuple(6, 2), (std::tuple<long, long>)std::make_tuple(7, 11)}))) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(10, 13), (std::tuple<long, long>)std::make_tuple(9, 7), (std::tuple<long, long>)std::make_tuple(10, 16), (std::tuple<long, long>)std::make_tuple(13, 10), (std::tuple<long, long>)std::make_tuple(14, 19), (std::tuple<long, long>)std::make_tuple(13, 13)})));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(4, 6), (std::tuple<long, long>)std::make_tuple(8, 9), (std::tuple<long, long>)std::make_tuple(7, 3), (std::tuple<long, long>)std::make_tuple(8, 12)}))) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(12, 15), (std::tuple<long, long>)std::make_tuple(11, 9), (std::tuple<long, long>)std::make_tuple(12, 18), (std::tuple<long, long>)std::make_tuple(15, 12), (std::tuple<long, long>)std::make_tuple(16, 21), (std::tuple<long, long>)std::make_tuple(15, 15)})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_780_find_combinations","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Function to find the combinations of sums with tuples in the given tuple vector\nstd::vector<std::tuple<long, long>> find_combinations(std::vector<std::tuple<long, long>> test_list) {\n    \/\/ Create a result vector to store the combined sums\n    std::vector<std::tuple<long, long>> result;\n\n    \/\/ Iterate through all possible pairs in test_list\n    for(size_t i = 0; i < test_list.size(); ++i) {\n        for(size_t j = i + 1; j < test_list.size(); ++j) {\n            \/\/ Get the elements of the ith tuple\n            long first1 = std::get<0>(test_list[i]);\n            long second1 = std::get<1>(test_list[i]);\n\n            \/\/ Get the elements of the jth tuple\n            long first2 = std::get<0>(test_list[j]);\n            long second2 = std::get<1>(test_list[j]);\n\n            \/\/ Calculate the sums\n            long sum1 = first1 + first2;\n            long sum2 = second1 + second2;\n\n            \/\/ Add the result as a tuple to the result vector\n            result.push_back(std::make_tuple(sum1, sum2));\n        }\n    }\n\n    \/\/ Return the result vector\n    return result;\n}\n```\n\nIn this code:\n- The function `find_combinations` takes a vector of tuples as input and returns a vector of tuples containing the combined sums.\n- Nested loops are used to iterate through all possible pairs of tuples in the input vector.\n- For each pair of tuples, their respective elements are added to form new sums.\n- These summed values are added as a tuple to the resulting vector, which is then returned."}
{"name":"mbpp_781_count_divisors","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to check whether the count of divisors is even. https:\/\/www.w3resource.com\/cppthon-exercises\/basic\/cppthon-basic-1-exercise-24.php\nbool count_divisors(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_781_count_divisors.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = count_divisors;\n    assert(candidate((10)) == (true));\n    assert(candidate((100)) == (false));\n    assert(candidate((125)) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_781_count_divisors","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to check whether the count of divisors is even\nbool count_divisors(long n) {\n    int count = 0;\n\n    \/\/ Loop over all possible divisors\n    for (long i = 1; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            \/\/ If i is a divisor, then n \/ i is also a divisor\n            if (i == n \/ i) {\n                count += 1; \/\/ Perfect square\n            } else {\n                count += 2; \/\/ Count both divisors\n            }\n        }\n    }\n\n    \/\/ Check if the count of divisors is even\n    return (count % 2 == 0);\n}\n```"}
{"name":"mbpp_782_odd_length_sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the sum of all odd length subvectors. https:\/\/www.geeksforgeeks.org\/sum-of-all-odd-length-subvectors\/\nlong odd_length_sum(std::vector<long> arr) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_782_odd_length_sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = odd_length_sum;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4}))) == (14));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)1, (long)2}))) == (15));\n    assert(candidate((std::vector<long>({(long)1, (long)7}))) == (8));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_782_odd_length_sum","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n#include <assert.h>\n\n\/\/ Function to find sum of all odd length subvectors.\nlong odd_length_sum(std::vector<long> arr) {\n    long totalSum = 0;\n    int n = arr.size();\n\n    \/\/ Iterate over all possible starting points of subarrays\n    for (int i = 0; i < n; ++i) {\n        long sum = 0;\n\n        \/\/ Iterate over all possible odd lengths\n        for (int j = i; j < n; ++j) {\n            sum += arr[j];\n            if ((j - i + 1) % 2 == 1) {\n                totalSum += sum;\n            }\n        }\n    }\n\n    return totalSum;\n}\n```"}
{"name":"mbpp_783_rgb_to_hsv","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to convert rgb color to hsv color. https:\/\/www.geeksforgeeks.org\/program-change-rgb-color-model-hsv-color-model\/\nstd::vector<float> rgb_to_hsv(long r, long g, long b) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_783_rgb_to_hsv.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = rgb_to_hsv;\n    assert(candidate((255), (255), (255)) == (std::vector<float>({(float)0.0f, (float)0.0f, (float)100.0f})));\n    assert(candidate((0), (215), (0)) == (std::vector<float>({(float)120.0f, (float)100.0f, (float)84.31372549019608f})));\n    assert(candidate((10), (215), (110)) == (std::vector<float>({(float)149.26829268292684f, (float)95.34883720930233f, (float)84.31372549019608f})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_783_rgb_to_hsv","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Write a function to convert rgb color to hsv color. \n\/\/ https:\/\/www.geeksforgeeks.org\/program-change-rgb-color-model-hsv-color-model\/\nstd::vector<float> rgb_to_hsv(long r, long g, long b) {\n    \/\/ Normalize red, green and blue values\n    float red = r \/ 255.0;\n    float green = g \/ 255.0;\n    float blue = b \/ 255.0;\n\n    \/\/ Placeholder for HSV values\n    float h, s, v;\n\n    \/\/ Compute the maximum and minimum of r, g, and b\n    float cmax = max(red, max(green, blue));\n    float cmin = min(red, min(green, blue));\n    float diff = cmax - cmin;\n\n    \/\/ Compute Hue\n    if (cmax == cmin) {\n        h = 0;\n    } else if (cmax == red) {\n        h = fmod((60 * ((green - blue) \/ diff) + 360), 360.0);\n    } else if (cmax == green) {\n        h = fmod((60 * ((blue - red) \/ diff) + 120), 360.0);\n    } else if (cmax == blue) {\n        h = fmod((60 * ((red - green) \/ diff) + 240), 360.0);\n    }\n\n    \/\/ Compute Saturation\n    if (cmax == 0) {\n        s = 0;\n    } else {\n        s = (diff \/ cmax) * 100;\n    }\n\n    \/\/ Compute Value\n    v = cmax * 100;\n\n    return {h, s, v};\n}\n```"}
{"name":"mbpp_784_mul_even_odd","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find the product of first even and odd number of a given vector.\nlong mul_even_odd(std::vector<long> list1) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_784_mul_even_odd.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = mul_even_odd;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)7, (long)4, (long)1, (long)6, (long)8}))) == (4));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)5, (long)7, (long)9, (long)10}))) == (10));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_784_mul_even_odd","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to find the product of first even and odd number of a given vector.\nlong mul_even_odd(std::vector<long> list1) {\n    long first_even = -1;\n    long first_odd = -1;\n\n    for (long num : list1) {\n        if (first_even == -1 && num % 2 == 0) {\n            first_even = num;\n        }\n        if (first_odd == -1 && num % 2 != 0) {\n            first_odd = num;\n        }\n        if (first_even != -1 && first_odd != -1) {\n            break;\n        }\n    }\n\n    \/\/ If either even or odd number is not found, assert will trigger\n    assert(first_even != -1 && first_odd != -1);\n\n    return first_even * first_odd;\n}\n```"}
{"name":"mbpp_785_tuple_str_int","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to convert tuple string to integer tuple.\nstd::tuple<long, long, long> tuple_str_int(std::string test_str) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_785_tuple_str_int.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = tuple_str_int;\n    assert(candidate((\"(7, 8, 9)\")) == (std::make_tuple(7, 8, 9)));\n    assert(candidate((\"(1, 2, 3)\")) == (std::make_tuple(1, 2, 3)));\n    assert(candidate((\"(4, 5, 6)\")) == (std::make_tuple(4, 5, 6)));\n    assert(candidate((\"(7, 81, 19)\")) == (std::make_tuple(7, 81, 19)));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_785_tuple_str_int","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n#include <tuple>\n\n\/\/ Write a function to convert tuple string to integer tuple.\nstd::tuple<long, long, long> tuple_str_int(std::string test_str) {\n    \/\/ Remove any surrounding parentheses\n    test_str.erase(remove(test_str.begin(), test_str.end(), '('), test_str.end());\n    test_str.erase(remove(test_str.begin(), test_str.end(), ')'), test_str.end());\n\n    \/\/ Initialize variables to store each component of the tuple\n    long first, second, third;\n\n    \/\/ Use a stringstream to parse the comma-separated string\n    std::stringstream ss(test_str);\n    std::string item;\n    \n    \/\/ Read values from the stream\n    getline(ss, item, ',');\n    first = std::stol(item);\n    getline(ss, item, ',');\n    second = std::stol(item);\n    getline(ss, item, ',');\n    third = std::stol(item);\n\n    \/\/ Return as a tuple\n    return std::make_tuple(first, second, third);\n}\n```\n\nThis code defines a function `tuple_str_int` that takes a string representing a tuple (e.g., \"(123,456,789)\"), removes the parentheses, and converts the string components to integers, returning them as a tuple of type `std::tuple<long, long, long>`."}
{"name":"mbpp_786_right_insertion","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to locate the right insertion point for a specified value in sorted order.\nlong right_insertion(std::vector<long> a, long x) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_786_right_insertion.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = right_insertion;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5})), (6)) == (4));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5})), (3)) == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5})), (7)) == (4));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_786_right_insertion","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to locate the right insertion point for a specified value in sorted order.\nlong right_insertion(std::vector<long> a, long x) {\n    \/\/ Using lower_bound to find the insertion point of x\n    auto it = std::upper_bound(a.begin(), a.end(), x);\n    \/\/ Return the index as long\n    return it - a.begin();\n}\n```"}
{"name":"mbpp_787_text_match_three","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that matches a string that has an a followed by three 'b'.\nbool text_match_three(std::string text) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_787_text_match_three.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = text_match_three;\n    assert(candidate((\"ac\")) == (false));\n    assert(candidate((\"dc\")) == (false));\n    assert(candidate((\"abbbba\")) == (true));\n    assert(candidate((\"caacabbbba\")) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_787_text_match_three","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n#include<regex>\n\nbool text_match_three(std::string text) {\n    std::regex pattern(\"ab{3}\");\n    return std::regex_search(text, pattern);\n}\n\n\/\/ Test cases\nvoid test() {\n    assert(text_match_three(\"abbb\") == true);\n    assert(text_match_three(\"a\") == false);\n    assert(text_match_three(\"ab\") == false);\n    assert(text_match_three(\"abb\") == false);\n    assert(text_match_three(\"abbbb\") == true);\n    assert(text_match_three(\"aabbb\") == true);\n    assert(text_match_three(\"bbbabbb\") == true);\n    assert(text_match_three(\"bbaaaaabbb\") == true);\n    assert(text_match_three(\"\") == false);\n    \n    std::cout << \"All test cases passed!\" << std::endl;\n}\n\n\/\/ Ensure to test\ntest();\n```\n\nThis code completes the function `text_match_three` which uses a regex pattern to check if the string contains an 'a' followed by exactly three 'b's. The test cases help ensure the function works as expected."}
{"name":"mbpp_788_new_tuple","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to create a new tuple from the given string and vector.\nstd::tuple<std::string, std::string, std::string> new_tuple(std::vector<std::string> test_list, std::string test_str) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_788_new_tuple.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = new_tuple;\n    assert(candidate((std::vector<std::string>({(std::string)\"WEB\", (std::string)\"is\"})), (\"best\")) == (std::make_tuple(\"WEB\", \"is\", \"best\")));\n    assert(candidate((std::vector<std::string>({(std::string)\"We\", (std::string)\"are\"})), (\"Developers\")) == (std::make_tuple(\"We\", \"are\", \"Developers\")));\n    assert(candidate((std::vector<std::string>({(std::string)\"Part\", (std::string)\"is\"})), (\"Wrong\")) == (std::make_tuple(\"Part\", \"is\", \"Wrong\")));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_788_new_tuple","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function to create a new tuple from the given string and vector.\nstd::tuple<std::string, std::string, std::string> new_tuple(std::vector<std::string> test_list, std::string test_str) {\n    \/\/ Check if test_list has at least 2 elements\n    assert(test_list.size() >= 2);\n\n    \/\/ Create the new tuple using the first element of the vector, the input string, and the last element of the vector\n    std::tuple<std::string, std::string, std::string> result(test_list[0], test_str, test_list[test_list.size() - 1]);\n\n    \/\/ Return the created tuple\n    return result;\n}\n```"}
{"name":"mbpp_790_even_position","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to check whether every even index contains even numbers of a given vector.\nbool even_position(std::vector<long> nums) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_790_even_position.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = even_position;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (false));\n    assert(candidate((std::vector<long>({(long)2, (long)1, (long)4}))) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_790_even_position","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n\n\/\/ Write a cpp function to check whether every even index contains even numbers of a given vector.\nbool even_position(std::vector<long> nums) {\n    for (size_t i = 0; i < nums.size(); i += 2) {\n        if (nums[i] % 2 != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\nThis code defines the function `even_position` which takes a vector of `long`s as its parameter and checks if every number at an even index in the vector is an even number. If all the numbers at even indices are even, it returns `true`, otherwise it returns `false`."}
{"name":"mbpp_791_remove_nested","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to remove tuples from the given tuple.\nstd::tuple<long, long, long, long> remove_nested(std::any test_tup) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_791_remove_nested.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = remove_nested;\n    assert(candidate(std::make_tuple(1, 5, 7, std::make_tuple(4, 6), 10)) == (std::make_tuple(1, 5, 7, 10)));\n    assert(candidate(std::make_tuple(2, 6, 8, std::make_tuple(5, 7), 11)) == (std::make_tuple(2, 6, 8, 11)));\n    assert(candidate(std::make_tuple(3, 7, 9, std::make_tuple(6, 8), 12)) == (std::make_tuple(3, 7, 9, 12)));\n    assert(candidate(std::make_tuple(3, 7, 9, std::make_tuple(6, 8), std::make_tuple(5, 12), 12)) == (std::make_tuple(3, 7, 9, 12)));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_791_remove_nested","gpt_solution":"```cpp\n#include<tuple>\n#include<any>\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Helper function to flatten the nested tuples\ntemplate<size_t index, typename... Types>\nstruct TupleFlattener {\n    using Type = decltype(std::tuple_cat(\n        std::declval<typename TupleFlattener<index-1, Types...>::Type>(),\n        std::declval<std::tuple<std::tuple_element_t<index, std::tuple<Types...>>>>()));\n    \n    static Type flatten(const std::tuple<Types...>& tup) {\n        return std::tuple_cat(\n            TupleFlattener<index-1, Types...>::flatten(tup),\n            std::make_tuple(std::get<index>(tup))\n        );\n    }\n};\n\ntemplate<typename... Types>\nstruct TupleFlattener<0, Types...> {\n    using Type = std::tuple<std::tuple_element_t<0, std::tuple<Types...>>>;\n\n    static Type flatten(const std::tuple<Types...>& tup) {\n        return std::make_tuple(std::get<0>(tup));\n    }\n};\n\n\/\/ Function to flatten nested tuples\ntemplate<typename T>\nauto flatten_tuple(const T& tup) {\n    return TupleFlattener<std::tuple_size<T>::value - 1, typename std::tuple_element<0, T>::type>::flatten(tup);\n}\n\n\/\/ Helper function to convert std::any to specific type and flatten if it's a tuple\ntemplate<typename T>\nauto convert_any_to_flat_tuple(const std::any& any_value) {\n    try {\n        const auto& tuple_value = std::any_cast<T>(any_value);\n        return flatten_tuple(tuple_value);\n    } catch (const std::bad_any_cast&) {\n        throw std::runtime_error(\"Invalid tuple type\");\n    }\n}\n\n\/\/ Write a function to remove nested tuples from the given tuple.\nstd::tuple<long, long, long, long> remove_nested(std::any test_tup) {\n    return convert_any_to_flat_tuple<std::tuple<std::tuple<long, long>, std::tuple<long, long>>>(test_tup);\n}\n```"}
{"name":"mbpp_792_count_list","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to count the number of vectors in a given number of vectors.\nlong count_list(std::vector<std::vector<long>> input_list) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_792_count_list.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = count_list;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)5, (long)7}), (std::vector<long>)std::vector<long>({(long)9, (long)11}), (std::vector<long>)std::vector<long>({(long)13, (long)15, (long)17})}))) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5})}))) == (3));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)2, (long)0})}))) == (2));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_792_count_list","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to count the number of vectors in a given number of vectors.\nlong count_list(std::vector<std::vector<long>> input_list) {\n    return input_list.size();\n}\n```"}
{"name":"mbpp_793_last","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the last position of an element in a sorted vector.\nlong last(std::vector<long> arr, long x) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_793_last.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = last;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (1)) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)3, (long)4})), (1)) == (2));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)2, (long)3, (long)6, (long)8, (long)9})), (3)) == (3));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_793_last","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Function to find the last position of an element in a sorted vector.\nlong last(std::vector<long> arr, long x) {\n    int low = 0;\n    int high = arr.size() - 1;\n    int result = -1;\n    \n    while(low <= high) {\n        int mid = low + (high - low)\/2;\n        if(arr[mid] == x) {\n            result = mid;\n            low = mid + 1; \/\/ Move to the right part to find the last occurrence\n        } else if(arr[mid] > x) {\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return result;\n}\n```"}
{"name":"mbpp_794_text_starta_endb","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that matches a string that has an 'a' followed by anything, ending in 'b'.\nbool text_starta_endb(std::string text) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_794_text_starta_endb.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = text_starta_endb;\n    assert(candidate((\"aabbbb\")) == (true));\n    assert(candidate((\"aabAbbbc\")) == (false));\n    assert(candidate((\"accddbbjjj\")) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_794_text_starta_endb","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function that matches a string that has an 'a' followed by anything, ending in 'b'.\nbool text_starta_endb(std::string text) {\n    if (text.size() < 2) {\n        return false;\n    }\n    if (text.front() == 'a' && text.back() == 'b') {\n        return true;\n    }\n    return false;\n}\n```"}
{"name":"mbpp_796_return_sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write function to find the sum of all items in the given map.\nlong return_sum(std::map<std::string,long> dict) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_796_return_sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = return_sum;\n    assert(candidate((std::map<std::string,long>({{\"a\", 100}, {\"b\", 200}, {\"c\", 300}}))) == (600));\n    assert(candidate((std::map<std::string,long>({{\"a\", 25}, {\"b\", 18}, {\"c\", 45}}))) == (88));\n    assert(candidate((std::map<std::string,long>({{\"a\", 36}, {\"b\", 39}, {\"c\", 49}}))) == (124));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_796_return_sum","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write function to find the sum of all items in the given map.\nlong return_sum(std::map<std::string,long> dict) {\n    long sum = 0;\n    for (const auto& pair : dict) {\n        sum += pair.second;\n    }\n    return sum;\n}\n```"}
{"name":"mbpp_797_sum_in_range","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the sum of all odd natural numbers within the range l and r.\nlong sum_in_range(long l, long r) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_797_sum_in_range.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = sum_in_range;\n    assert(candidate((2), (5)) == (8));\n    assert(candidate((5), (7)) == (12));\n    assert(candidate((7), (13)) == (40));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_797_sum_in_range","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a cpp function to find the sum of all odd natural numbers within the range l and r.\nlong sum_in_range(long l, long r) {\n    long sum = 0;\n    for (long i = l; i <= r; ++i) {\n        if (i % 2 != 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}\n```\n\nThis code defines the `sum_in_range` function which takes two long integers, `l` and `r`, and returns the sum of all odd natural numbers within the range `[l, r]`."}
{"name":"mbpp_798__sum","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the sum of a vector.\nlong _sum(std::vector<long> arr) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_798__sum.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = _sum;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (6));\n    assert(candidate((std::vector<long>({(long)15, (long)12, (long)13, (long)10}))) == (50));\n    assert(candidate((std::vector<long>({(long)0, (long)1, (long)2}))) == (3));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_798__sum","gpt_solution":"```cpp\n#include <assert.h>\n#include <vector>\n\n\/\/ Function to find the sum of a vector\nlong _sum(std::vector<long> arr) {\n    long total = 0;\n    for(long num : arr) {\n        total += num;\n    }\n    return total;\n}\n```"}
{"name":"mbpp_799_left_rotate","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to that rotate left bits by d bits a given number. We assume that the number is 32 bit.\nlong left_rotate(long n, long d) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_799_left_rotate.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = left_rotate;\n    assert(candidate((16), (2)) == (64));\n    assert(candidate((10), (2)) == (40));\n    assert(candidate((99), (3)) == (792));\n    assert(candidate((99), (3)) == (792));\n    assert(candidate((1), (3)) == (8));\n    assert(candidate((5), (3)) == (40));\n    assert(candidate((29), (3)) == (232));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_799_left_rotate","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function that rotates left bits by d bits a given number. We assume that the number is 32 bit.\nlong left_rotate(long n, long d) {\n    const int num_bits = 32; \/\/ Number of bits in a 32-bit integer\n\n    \/\/ Normalize the number of bits to rotate\n    d = d % num_bits;\n\n    \/\/ Perform the left bit rotation\n    return (n << d) | (n >> (num_bits - d));\n}\n```\n\nIn this function, we first define the number of bits in a 32-bit integer (`num_bits`). We then normalize the number of bits to rotate (`d`) to be within the range of valid bit positions. The left rotation is performed by shifting the number `n` to the left by `d` bits and then shifting `n` to the right by `(num_bits - d)` bits to account for the bits that overflow from the left. The results of these two shifts are combined using the bitwise OR operator."}
{"name":"mbpp_800_remove_all_spaces","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to remove all whitespaces from a string.\nstd::string remove_all_spaces(std::string text) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_800_remove_all_spaces.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = remove_all_spaces;\n    assert(candidate((\"python  program\")) == (\"pythonprogram\"));\n    assert(candidate((\"python   programming    language\")) == (\"pythonprogramminglanguage\"));\n    assert(candidate((\"python                     program\")) == (\"pythonprogram\"));\n    assert(candidate((\"   python                     program\")) == (\"pythonprogram\"));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_800_remove_all_spaces","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to remove all whitespaces from a string.\nstd::string remove_all_spaces(std::string text) {\n    text.erase(remove(text.begin(), text.end(), ' '), text.end());\n    return text;\n}\n\n\/\/ Test cases\nvoid test() {\n    assert(remove_all_spaces(\"Hello World\") == \"HelloWorld\");\n    assert(remove_all_spaces(\"   Leading and trailing spaces   \") == \"Leadingandtrailingspaces\");\n    assert(remove_all_spaces(\"NoSpaces\") == \"NoSpaces\");\n    assert(remove_all_spaces(\"    \") == \"\");\n    assert(remove_all_spaces(\"No spaces in between\") == \"Nospacesinbetween\");\n    assert(remove_all_spaces(\"Text with multiple spaces between words\") == \"Textwithmultiplespacesbetweenwords\");\n}\n\n\/\/ Running the test cases\ntest();\n```"}
{"name":"mbpp_801_test_three_equal","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to count the number of equal numbers from three given integers.\nlong test_three_equal(long x, long y, long z) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_801_test_three_equal.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = test_three_equal;\n    assert(candidate((1), (1), (1)) == (3));\n    assert(candidate((-1), (-2), (-3)) == (0));\n    assert(candidate((1), (2), (2)) == (2));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_801_test_three_equal","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to count the number of equal numbers from three given integers.\nlong test_three_equal(long x, long y, long z) {\n    if (x == y && y == z) {\n        return 3; \/\/ All three numbers are equal\n    }\n    else if (x == y || y == z || x == z) {\n        return 2; \/\/ Two of the numbers are equal\n    }\n    return 1; \/\/ No numbers are equal\n}\n\nint main() {\n    \/\/ Test cases\n    assert(test_three_equal(1, 2, 3) == 1);\n    assert(test_three_equal(2, 2, 3) == 2);\n    assert(test_three_equal(2, 2, 2) == 3);\n    assert(test_three_equal(3, 3, 4) == 2);\n    assert(test_three_equal(5, 5, 5) == 3);\n    assert(test_three_equal(6, 7, 8) == 1);\n\n    cout << \"All test cases passed!\" << endl;\n    return 0;\n}\n```"}
{"name":"mbpp_802_count_rotation","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to count the number of rotations required to generate a sorted vector. https:\/\/www.geeksforgeeks.org\/count-of-rotations-required-to-generate-a-sorted-vector\/\nlong count_rotation(std::vector<long> arr) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_802_count_rotation.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = count_rotation;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)1, (long)2, (long)3}))) == (2));\n    assert(candidate((std::vector<long>({(long)7, (long)8, (long)9, (long)1, (long)2, (long)3}))) == (3));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2}))) == (2));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_802_count_rotation","gpt_solution":"```cpp\n#include <bits\/stdc++.h>\n\n\/\/ Write a cpp function to count the number of rotations required to generate a sorted vector. \n\/\/ https:\/\/www.geeksforgeeks.org\/count-of-rotations-required-to-generate-a-sorted-vector\/\nlong count_rotation(std::vector<long> arr) {\n    long n = arr.size();\n\n    \/\/ Initialize start and end indices\n    long start = 0;\n    long end = n - 1;\n\n    \/\/ Iterate till start index is less than or equal to end index\n    while (start <= end) {\n        \/\/ If the array is already sorted, then number of rotations is zero\n        if (arr[start] <= arr[end]) {\n            return start;\n        }\n\n        long mid = start + (end - start) \/ 2;\n        \n        \/\/ Find the next and previous elements of the mid element considering circular rotation\n        long next = (mid + 1) % n;\n        long prev = (mid - 1 + n) % n;\n\n        \/\/ Check if mid element is the minimum element\n        if (arr[mid] <= arr[next] && arr[mid] <= arr[prev]) {\n            return mid;\n        }\n        \/\/ If array is not sorted from mid to end, the minimum element is to the left of mid index\n        else if (arr[mid] <= arr[end]) {\n            end = mid - 1;\n        }\n        \/\/ If array is not sorted from start to mid, the minimum element is to the right of mid index\n        else if (arr[mid] >= arr[start]) {\n            start = mid + 1;\n        }\n    }\n\n    \/\/ If no rotation was needed or the array was empty\n    return 0;\n}\n```"}
{"name":"mbpp_803_is_perfect_square","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check whether the given number is a perfect square or not. https:\/\/www.geeksforgeeks.org\/check-if-given-number-is-perfect-square-in-cpp\/\nbool is_perfect_square(long n) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_803_is_perfect_square.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = is_perfect_square;\n    assert(candidate((10)) == (false));\n    assert(candidate((36)) == (true));\n    assert(candidate((14)) == (false));\n    assert(candidate((196)) == (true));\n    assert(candidate((125)) == (false));\n    assert(candidate((15625)) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_803_is_perfect_square","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Write a function to check whether the given number is a perfect square or not. https:\/\/www.geeksforgeeks.org\/check-if-given-number-is-perfect-square-in-cpp\/\nbool is_perfect_square(long n) {\n    if (n < 0) return false; \/\/ Negative numbers are not perfect squares\n    long sqrt_n = static_cast<long>(sqrt(n));\n    return (sqrt_n * sqrt_n == n);\n}\n```\n\nThis function checks if a given number is a perfect square or not. If `n` is negative, it immediately returns `false` since negative numbers cannot be perfect squares. It then calculates the integer part of the square root of `n` and checks if squaring that integer results in `n`. If it does, then `n` is a perfect square; otherwise, it is not."}
{"name":"mbpp_804_is_product_even","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check whether the product of numbers in a vector is even or not.\nbool is_product_even(std::vector<long> arr) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_804_is_product_even.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = is_product_even;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)1, (long)4}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)1}))) == (false));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_804_is_product_even","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to check whether the product of numbers in a vector is even or not.\nbool is_product_even(std::vector<long> arr) {\n    for (long num : arr) {\n        if (num % 2 == 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\nExplanation:\n- The function `is_product_even` takes a vector of long integers as an argument.\n- It iterates through each element in the vector.\n- If any number in the vector is even (i.e., divisible by 2 with no remainder), the function returns `true` because the product of the numbers in the vector will be even.\n- If no number in the vector is even, the function returns `false`, indicating that the product of the numbers is not even."}
{"name":"mbpp_805_max_sum_list","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function that returns the vector in a vector of vectors whose sum of elements is the highest.\nstd::vector<long> max_sum_list(std::vector<std::vector<long>> lists) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_805_max_sum_list.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = max_sum_list;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)10, (long)11, (long)12}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})}))) == (std::vector<long>({(long)10, (long)11, (long)12})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)3, (long)2, (long)1}), (std::vector<long>)std::vector<long>({(long)6, (long)5, (long)4}), (std::vector<long>)std::vector<long>({(long)12, (long)11, (long)10})}))) == (std::vector<long>({(long)12, (long)11, (long)10})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)3, (long)1})}))) == (std::vector<long>({(long)2, (long)3, (long)1})));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_805_max_sum_list","gpt_solution":"```cpp\n#include <assert.h>\n#include <bits\/stdc++.h>\n\n\/\/ Write a function that returns the vector in a vector of vectors whose sum of elements is the highest.\nstd::vector<long> max_sum_list(std::vector<std::vector<long>> lists) {\n    std::vector<long> max_list;\n    long max_sum = std::numeric_limits<long>::min();\n\n    for (const auto &list : lists) {\n        long current_sum = std::accumulate(list.begin(), list.end(), 0L);\n        if (current_sum > max_sum) {\n            max_sum = current_sum;\n            max_list = list;\n        }\n    }\n\n    return max_list;\n}\n```\n\nThis code defines the function `max_sum_list` which takes a vector of vectors of long integers. It iterates through each vector, calculates the sum of its elements, and keeps track of the vector with the highest sum encountered so far. Finally, it returns the vector with the highest sum."}
{"name":"mbpp_806_max_run_uppercase","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to find maximum run of uppercase characters in the given string.\nlong max_run_uppercase(std::string test_str) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_806_max_run_uppercase.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = max_run_uppercase;\n    assert(candidate((\"GeMKSForGERksISBESt\")) == (5));\n    assert(candidate((\"PrECIOusMOVemENTSYT\")) == (6));\n    assert(candidate((\"GooGLEFluTTER\")) == (4));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_806_max_run_uppercase","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find maximum run of uppercase characters in the given string.\nlong max_run_uppercase(const std::string& test_str) {\n    long max_run = 0;\n    long current_run = 0;\n    \n    for(char c : test_str) {\n        if(isupper(c)) {\n            current_run++;\n            max_run = std::max(max_run, current_run);\n        } else {\n            current_run = 0;\n        }\n    }\n    \n    return max_run;\n}\n```"}
{"name":"mbpp_807_first_odd","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a cppthon function to find the first odd number in a given vector of numbers.\nlong first_odd(std::vector<long> nums) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_807_first_odd.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = first_odd;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5}))) == (1));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)9, (long)1}))) == (9));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_807_first_odd","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to find the first odd number in a given vector of numbers.\nlong first_odd(std::vector<long> nums) {\n    for (long num : nums) {\n        if (num % 2 != 0) {\n            return num;\n        }\n    }\n    \/\/ If no odd number is found, return an indication, such as -1\n    return -1;\n}\n```"}
{"name":"mbpp_808_check_K","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check if the given tuples contain the k or not.\nbool check_K(std::vector<long> test_tup, long K) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_808_check_K.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = check_K;\n    assert(candidate((std::vector<long>({(long)10, (long)4, (long)5, (long)6, (long)8})), (6)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (7)) == (false));\n    assert(candidate((std::vector<long>({(long)7, (long)8, (long)9, (long)44, (long)11, (long)12})), (11)) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_808_check_K","gpt_solution":"```cpp\n#include <vector>\n\n\/\/ Function to check if the given vector contains the value K or not.\nbool check_K(std::vector<long> test_tup, long K) {\n    \/\/ Check each element in the vector\n    for (long elem : test_tup) {\n        \/\/ If any element is equal to K, return true\n        if (elem == K) {\n            return true;\n        }\n    }\n    \/\/ If no element is equal to K, return false\n    return false;\n}\n```"}
{"name":"mbpp_809_check_smaller","language":"cpp","prompt":"#include<assert.h>\n#include<bits\/stdc++.h>\n\/\/ Write a function to check if each element of second tuple is smaller than its corresponding element in the first tuple.\nbool check_smaller(std::tuple<long, long, long> test_tup1, std::tuple<long, long, long> test_tup2) {\n","doctests":"transform","original":"\/Users\/arjun\/repos\/nuprl\/MultiPL-E\/datasets\/..\/datasets\/mbpp-typed\/mbpp_809_check_smaller.py","prompt_terminology":"reworded","tests":"}\nint main() {\n    auto candidate = check_smaller;\n    assert(candidate((std::make_tuple(1, 2, 3)), (std::make_tuple(2, 3, 4))) == (false));\n    assert(candidate((std::make_tuple(4, 5, 6)), (std::make_tuple(3, 4, 5))) == (true));\n    assert(candidate((std::make_tuple(11, 12, 13)), (std::make_tuple(10, 11, 12))) == (true));\n}\n","stop_tokens":["\n}"],"task_id":"mbpp_809_check_smaller","gpt_solution":"```cpp\n#include<assert.h>\n#include<bits\/stdc++.h>\n\n\/\/ Write a function to check if each element of second tuple is smaller than its corresponding element in the first tuple.\nbool check_smaller(std::tuple<long, long, long> test_tup1, std::tuple<long, long, long> test_tup2) {\n    return std::get<0>(test_tup2) < std::get<0>(test_tup1) &&\n           std::get<1>(test_tup2) < std::get<1>(test_tup1) &&\n           std::get<2>(test_tup2) < std::get<2>(test_tup1);\n}\n```"}

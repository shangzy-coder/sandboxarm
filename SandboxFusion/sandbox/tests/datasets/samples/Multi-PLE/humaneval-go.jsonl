{"name": "HumanEval_0_has_close_elements", "language": "go_test.go", "prompt": "package has_close_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Check if in given list of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements([]float64{1.0, 2.0, 3.0}, 0.5)\n// false\n// >>> has_close_elements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\n// true\nfunc has_close_elements(numbers []float64, threshold float64) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_0_has_close_elements.py", "prompt_terminology": "reworded", "tests": "func TestHas_Close_Elements(t *testing.T) {\n  candidate := has_close_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3), expected: true },\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05), expected: false },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.95), expected: true },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.8), expected: false },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, 0.1), expected: true },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 1.0), expected: true },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 0.5), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage has_close_elements_test\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\t\"fmt\"\n)\n\n// Check if in given list of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements([]float64{1.0, 2.0, 3.0}, 0.5)\n// false\n// >>> has_close_elements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\n// true\nfunc has_close_elements(numbers []float64, threshold float64) bool {\n\tsort.Float64s(numbers)\n\tfor i := 0; i < len(numbers)-1; i++ {\n\t\tif numbers[i+1]-numbers[i] < threshold {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc TestHasCloseElements(t *testing.T) {\n\ttests := []struct {\n\t\tnumbers   []float64\n\t\tthreshold float64\n\t\texpected  bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, false},\n\t\t{[]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3, true},\n\t\t{[]float64{1.0, 1.4, 1.8, 2.2, 2.6, 3.0}, 0.5, false},\n\t\t{[]float64{1.0, 1.4, 1.8, 1.1, 2.6, 3.0}, 0.3, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"numbers=%v,threshold=%v\", test.numbers, test.threshold), func(t *testing.T) {\n\t\t\tresult := has_close_elements(test.numbers, test.threshold)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"Expected %v but got %v\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n```", "task_id": "HumanEval_0_has_close_elements"}
{"name": "HumanEval_1_separate_paren_groups", "language": "go_test.go", "prompt": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_1_separate_paren_groups.py", "prompt_terminology": "reworded", "tests": "func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"strings\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    clean_string := strings.ReplaceAll(paren_string, \" \", \"\")\n    groups := []string{}\n    balance := 0\n    start := 0\n\n    for i, ch := range clean_string {\n        if ch == '(' {\n            if balance == 0 {\n                start = i\n            }\n            balance++\n        } else if ch == ')' {\n            balance--\n            if balance == 0 {\n                groups = append(groups, clean_string[start:i+1])\n            }\n        }\n    }\n\n    return groups\n}\n\nfunc TestSeparateParenGroups(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected []string\n    }{\n        {\"( ) (( )) (( )( ))\", []string{\"()\", \"(())\", \"(()())\"}},\n        {\"((())) ()\", []string{\"((()))\", \"()\"}},\n        {\"() (()) ((()))\", []string{\"()\", \"(())\", \"((()))\"}},\n        {\"()()() ((()))\", []string{\"()\", \"()\", \"()\", \"((()))\"}},\n        {\"(((())))\", []string{\"(((())))\"}},\n        {\"\", []string{}},\n    }\n\n    for _, test := range tests {\n        result := separate_paren_groups(test.input)\n        if !equalSlices(result, test.expected) {\n            t.Errorf(\"separate_paren_groups(%q) = %v; want %v\", test.input, result, test.expected)\n        }\n    }\n}\n\nfunc equalSlices(a, b []string) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n```", "task_id": "HumanEval_1_separate_paren_groups"}
{"name": "HumanEval_2_truncate_number", "language": "go_test.go", "prompt": "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64 {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_2_truncate_number.py", "prompt_terminology": "reworded", "tests": "func TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage truncate_number_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n\t\"math\"\n)\n\n// Given a positive floating point number, it can be decomposed into\n// an integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64 {\n\tintegerPart := math.Floor(number)\n\treturn number - integerPart\n}\n\nfunc TestTruncateNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput float64\n\t\texpected float64\n\t}{\n\t\t{3.5, 0.5},\n\t\t{4.75, 0.75},\n\t\t{6.12345, 0.12345},\n\t\t{10.0, 0.0},\n\t\t{0.999, 0.999},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := truncate_number(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For input %.5f, expected %.5f but got %.5f\", test.input, test.expected, result)\n\t\t}\n\t}\n}\n\nfunc main() {\n\t// run the test\n\tfmt.Println(\"Running tests\")\n\tTestTruncateNumber(&testing.T{})\n}\n```", "task_id": "HumanEval_2_truncate_number"}
{"name": "HumanEval_3_below_zero", "language": "go_test.go", "prompt": "package below_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're given a list of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero([]int{1, 2, 3})\n// false\n// >>> below_zero([]int{1, 2, -4, 5})\n// true\nfunc below_zero(operations []int) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_3_below_zero.py", "prompt_terminology": "reworded", "tests": "func TestBelow_Zero(t *testing.T) {\n  candidate := below_zero\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: false },\n     { actual: candidate([]int{1, 2, -3, 1, 2, -3}), expected: false },\n     { actual: candidate([]int{1, 2, -4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, -1, 2, -2, 5, -5, 4, -4}), expected: false },\n     { actual: candidate([]int{1, -1, 2, -2, 5, -5, 4, -5}), expected: true },\n     { actual: candidate([]int{1, -2, 2, -2, 5, -5, 4, -4}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage below_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc below_zero(operations []int) bool {\n    balance := 0\n    for _, op := range operations {\n        balance += op\n        if balance < 0 {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestBelowZero(t *testing.T) {\n    tests := []struct {\n        operations []int\n        expected   bool\n    }{\n        {[]int{1, 2, 3}, false},\n        {[]int{1, 2, -4, 5}, true},\n        {[]int{-1, 2, -1, -3}, true},\n        {[]int{5, -1, -2, -3}, false},\n        {[]int{}, false},\n    }\n\n    for _, test := range tests {\n        result := below_zero(test.operations)\n        if result != test.expected {\n            t.Errorf(\"For operations %v, expected %v,  but got %v\", test.operations, test.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(below_zero([]int{1, 2, 3}))       // false\n    fmt.Println(below_zero([]int{1, 2, -4, 5}))   // true\n    fmt.Println(below_zero([]int{-1, 2, -1, -3})) // true\n    fmt.Println(below_zero([]int{5, -1, -2, -3})) // false\n    fmt.Println(below_zero([]int{}))              // false\n}\n```\n\nThis code implements the function `below_zero` that iterates over a list of operations (deposits and withdrawals) and tracks the balance. If the balance ever falls below zero, it returns `true`; otherwise, it returns `false`. The `TestBelowZero` function is used for unit testing to ensure the implementation works correctly, and the `main` function demonstrates some examples.", "task_id": "HumanEval_3_below_zero"}
{"name": "HumanEval_4_mean_absolute_deviation", "language": "go_test.go", "prompt": "package mean_absolute_deviation_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// For a given list of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation([]float64{1.0, 2.0, 3.0, 4.0})\n// 1.0\nfunc mean_absolute_deviation(numbers []float64) float64 {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_4_mean_absolute_deviation.py", "prompt_terminology": "reworded", "tests": "func TestMean_Absolute_Deviation(t *testing.T) {\n  candidate := mean_absolute_deviation\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0}), expected: 0.5 },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0}), expected: 1.0 },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0}), expected: 1.2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage mean_absolute_deviation_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\n// For a given list of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation([]float64{1.0, 2.0, 3.0, 4.0})\n// 1.0\nfunc mean_absolute_deviation(numbers []float64) float64 {\n    // Calculate the mean of the numbers\n    var sum float64\n    for _, num := range numbers {\n        sum += num\n    }\n    mean := sum / float64(len(numbers))\n\n    // Calculate the sum of absolute differences from the mean\n    var absDiffSum float64\n    for _, num := range numbers {\n        absDiffSum += math.Abs(num - mean)\n    }\n\n    // Calculate and return the mean absolute deviation\n    mad := absDiffSum / float64(len(numbers))\n    return mad\n}\n\nfunc TestMeanAbsoluteDeviation(t *testing.T) {\n    testCases := []struct {\n        numbers []float64\n        expected float64\n    }{\n        {[]float64{1.0, 2.0, 3.0, 4.0}, 1.0},\n        {[]float64{1.0, 1.0, 1.0, 1.0}, 0.0},\n        {[]float64{10.0, 20.0, 30.0, 40.0}, 10.0},\n        {[]float64{1.0, 10.0, 100.0, 1000.0}, 324.25},\n    }\n\n    for _, tc := range testCases {\n        result := mean_absolute_deviation(tc.numbers)\n        if result != tc.expected {\n            t.Errorf(\"mean_absolute_deviation(%v) = %v; expected %v\", tc.numbers, result, tc.expected)\n        }\n    }\n}\n\nfunc main() {\n    // Running a simple example\n    numbers := []float64{1.0, 2.0, 3.0, 4.0}\n    fmt.Printf(\"Mean Absolute Deviation of %v is %v\\n\", numbers, mean_absolute_deviation(numbers))\n}\n```", "task_id": "HumanEval_4_mean_absolute_deviation"}
{"name": "HumanEval_5_intersperse", "language": "go_test.go", "prompt": "package intersperse_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n// >>> intersperse([]int{}, 4)\n// []int{}\n// >>> intersperse([]int{1, 2, 3}, 4)\n// []int{1, 4, 2, 4, 3}\nfunc intersperse(numbers []int, delimeter int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_5_intersperse.py", "prompt_terminology": "reworded", "tests": "func TestIntersperse(t *testing.T) {\n  candidate := intersperse\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}, 7), expected: []int{} },\n     { actual: candidate([]int{5, 6, 3, 2}, 8), expected: []int{5, 8, 6, 8, 3, 8, 2} },\n     { actual: candidate([]int{2, 2, 2}, 2), expected: []int{2, 2, 2, 2, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage intersperse_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n// >>> intersperse([]int{}, 4)\n// []int{}\n// >>> intersperse([]int{1, 2, 3}, 4)\n// []int{1, 4, 2, 4, 3}\nfunc intersperse(numbers []int, delimeter int) []int {\n    if len(numbers) == 0 {\n        return numbers\n    }\n    \n    result := []int{}\n    for i, num := range numbers {\n        if i > 0 {\n            result = append(result, delimeter)\n        }\n        result = append(result, num)\n    }\n    return result\n}\n\nfunc TestIntersperse(t *testing.T) {\n    tests := []struct {\n        input       []int\n        delimeter   int\n        expected    []int\n    }{\n        {[]int{}, 4, []int{}},\n        {[]int{1, 2, 3}, 4, []int{1, 4, 2, 4, 3}},\n        {[]int{1}, 4, []int{1}},\n        {[]int{1, 2, 3, 4}, 0, []int{1, 0, 2, 0, 3, 0, 4}},\n    }\n\n    for _, test := range tests {\n        result := intersperse(test.input, test.delimeter)\n        if !equal(result, test.expected) {\n            t.Errorf(\"intersperse(%v, %v) = %v; want %v\", test.input, test.delimeter, result, test.expected)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    fmt.Println(intersperse([]int{}, 4)) // Output: []\n    fmt.Println(intersperse([]int{1, 2, 3}, 4)) // Output: [1, 4, 2, 4, 3]\n}\n```\n\nThis complete code includes the `intersperse` function implementation as described, along with some test cases to ensure the function works correctly. The `TestIntersperse` function uses the `testing` package to check various input scenarios, and the `equal` function is used to compare slices. The `main` function is included to demonstrate the intended output.\n", "task_id": "HumanEval_5_intersperse"}
{"name": "HumanEval_6_parse_nested_parens", "language": "go_test.go", "prompt": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_6_parse_nested_parens.py", "prompt_terminology": "reworded", "tests": "func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage parse_nested_parens_test\n\nimport (\n    \"strings\"\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    groups := strings.Split(paren_string, \" \")\n    var result []int\n\n    for _, group := range groups {\n        maxDepth := 0\n        currentDepth := 0\n        \n        for _, char := range group {\n            if char == '(' {\n                currentDepth++\n                if currentDepth > maxDepth {\n                    maxDepth = currentDepth\n                }\n            } else if char == ')' {\n                currentDepth--\n            }\n        }\n\n        result = append(result, maxDepth)\n    }\n\n    return result\n}\n\nfunc TestParseNestedParens(t *testing.T) {\n    tests := []struct {\n        input string\n        expected []int\n    }{\n        {\"(()()) ((())) () ((())()())\", []int{2, 3, 1, 3}},\n        {\"() (()) ((())) (((())))\", []int{1, 2, 3, 4}},\n        {\"() () ()\", []int{1, 1, 1}},\n        {\"((()))\", []int{3}},\n        {\"\", []int{0}},\n    }\n\n    for _, test := range tests {\n        result := parse_nested_parens(test.input)\n        if !equal(result, test.expected) {\n            t.Errorf(\"For input '%s', expected %v but got %v\", test.input, test.expected, result)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    // Running the tests\n    result := testing.RunTests(func(pat, str string) (bool, error) {\n        return true, nil\n    }, []testing.InternalTest{\n        {\"TestParseNestedParens\", TestParseNestedParens},\n    })\n\n    fmt.Println(result)\n}\n```", "task_id": "HumanEval_6_parse_nested_parens"}
{"name": "HumanEval_7_filter_by_substring", "language": "go_test.go", "prompt": "package filter_by_substring_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([]string{}, \"a\")\n// []string{}\n// >>> filter_by_substring([]string{\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\")\n// []string{\"abc\", \"bacd\", \"array\"}\nfunc filter_by_substring(strings []string, substring string) []string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_7_filter_by_substring.py", "prompt_terminology": "reworded", "tests": "func TestFilter_By_Substring(t *testing.T) {\n  candidate := filter_by_substring\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}, \"john\"), expected: []string{} },\n     { actual: candidate([]string{\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"), expected: []string{\"xxx\", \"xxxAAA\", \"xxx\"} },\n     { actual: candidate([]string{\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xx\"), expected: []string{\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"} },\n     { actual: candidate([]string{\"grunt\", \"trumpet\", \"prune\", \"gruesome\"}, \"run\"), expected: []string{\"grunt\", \"prune\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage filter_by_substring_test\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"fmt\"\n)\n\n// Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([]string{}, \"a\")\n// []string{}\n// >>> filter_by_substring([]string{\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\")\n// []string{\"abc\", \"bacd\", \"array\"}\nfunc filter_by_substring(strs []string, substring string) []string {\n\tvar result []string\n\tfor _, str := range strs {\n\t\tif strings.Contains(str, substring) {\n\t\t\tresult = append(result, str)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc TestFilterBySubstring(t *testing.T) {\n    cases := []struct{\n        input []string\n        substring string\n        expected []string\n    }{\n        {[]string{}, \"a\", []string{}},\n        {[]string{\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\", []string{\"abc\", \"bacd\", \"array\"}},\n        {[]string{\"hello\", \"world\", \"golang\", \"test\"}, \"o\", []string{\"hello\", \"world\", \"golang\"}},\n        {[]string{\"apple\", \"banana\", \"cherry\", \"date\"}, \"e\", []string{\"apple\", \"cherry\", \"date\"}},\n    }\n\n    for _, c := range cases {\n        actual := filter_by_substring(c.input, c.substring)\n        if !testEq(actual, c.expected) {\n            t.Errorf(\"filter_by_substring() == %v, expected %v\", actual, c.expected)\n        }\n    }\n}\n\nfunc testEq(a, b []string) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc ExampleFilterBySubstring() {\n    fmt.Println(filter_by_substring([]string{}, \"a\"))\n    fmt.Println(filter_by_substring([]string{\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\"))\n    fmt.Println(filter_by_substring([]string{\"hello\", \"world\", \"golang\", \"test\"}, \"o\"))\n    fmt.Println(filter_by_substring([]string{\"apple\", \"banana\", \"cherry\", \"date\"}, \"e\"))\n    // Output:\n    // []\n    // [abc bacd array]\n    // [hello world golang]\n    // [apple cherry date]\n}\n```", "task_id": "HumanEval_7_filter_by_substring"}
{"name": "HumanEval_8_sum_product", "language": "go_test.go", "prompt": "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// For a given list of integers, return a list consisting of a sum and a product of all the integers in a list.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product([]int{})\n// []interface{}{0, 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers []int) []interface{} {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_8_sum_product.py", "prompt_terminology": "reworded", "tests": "func TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// For a given list of integers, return a list consisting of a sum and a product of all the integers in a list.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product([]int{})\n// []interface{}{0, 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers []int) []interface{} {\n    sum := 0\n    product := 1\n\n    if len(numbers) == 0 {\n        return []interface{}{sum, product}\n    }\n\n    for _, num := range numbers {\n        sum += num\n        product *= num\n    }\n\n    return []interface{}{sum, product}\n}\n\nfunc TestSumProduct(t *testing.T) {\n    cases := []struct{\n        input    []int\n        expected []interface{}\n    }{\n        {[]int{}, []interface{}{0, 1}},\n        {[]int{1, 2, 3, 4}, []interface{}{10, 24}},\n        {[]int{5, 10, 15}, []interface{}{30, 750}},\n        {[]int{-1, -2, -3}, []interface{}{-6, -6}},\n        {[]int{0, 1, 2, 3}, []interface{}{6, 0}},\n    }\n\n    for _, c := range cases {\n        result := sum_product(c.input)\n        if fmt.Sprintf(\"%v\", result) != fmt.Sprintf(\"%v\", c.expected) {\n            t.Errorf(\"Expected %v for input %v, but got %v\", c.expected, c.input, result)\n        }\n    }\n}\n```", "task_id": "HumanEval_8_sum_product"}
{"name": "HumanEval_9_rolling_max", "language": "go_test.go", "prompt": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_9_rolling_max.py", "prompt_terminology": "reworded", "tests": "func TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    result := make([]int, len(numbers))\n    max_so_far := numbers[0]\n\n    for i, num := range numbers {\n        if num > max_so_far {\n            max_so_far = num\n        }\n        result[i] = max_so_far\n    }\n\n    return result\n}\n\nfunc TestRollingMax(t *testing.T) {\n    input := []int{1, 2, 3, 2, 3, 4, 2}\n    expectedOutput := []int{1, 2, 3, 3, 3, 4, 4}\n\n    result := rolling_max(input)\n\n    if !slicesEqual(result, expectedOutput) {\n        t.Errorf(\"Expected %v, but got %v\", expectedOutput, result)\n    }\n}\n\nfunc slicesEqual(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    input := []int{1, 2, 3, 2, 3, 4, 2}\n    fmt.Println(rolling_max(input))\n}\n```", "task_id": "HumanEval_9_rolling_max"}
{"name": "HumanEval_10_make_palindrome", "language": "go_test.go", "prompt": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_10_make_palindrome.py", "prompt_terminology": "reworded", "tests": "func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    longestPalindromicSuffix := func(s string) string {\n        for length := len(s); length > 0; length-- {\n            if isPalindrome(s[len(s)-length:]) {\n                return s[len(s)-length:]\n            }\n        }\n        return \"\"\n    }\n\n    isPalindrome := func(s string) bool {\n        for i := 0; i < len(s)/2; i++ {\n            if s[i] != s[len(s)-i-1] {\n                return false\n            }\n        }\n        return true\n    }\n\n    lps := longestPalindromicSuffix(myString)\n    prefix := myString[:len(myString)-len(lps)]\n    reversedPrefix := reverseString(prefix)\n\n    return myString + reversedPrefix\n}\n\n// Helper function for reversing a string.\nfunc reverseString(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}\n\n// Helper function for testing the make_palindrome function.\nfunc TestMakePalindrome(t *testing.T) {\n    testCases := []struct {\n        input    string\n        expected string\n    }{\n        {\"\", \"\"},\n        {\"cat\", \"catac\"},\n        {\"cata\", \"catac\"},\n        {\"race\", \"racecar\"},\n        {\"ab\", \"aba\"},\n        {\"aa\", \"aa\"},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"make_palindrome(%q)\", tc.input), func(t *testing.T) {\n            got := make_palindrome(tc.input)\n            if got != tc.expected {\n                t.Errorf(\"make_palindrome(%q) = %q; want %q\", tc.input, got, tc.expected)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_10_make_palindrome"}
{"name": "HumanEval_11_string_xor", "language": "go_test.go", "prompt": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_11_string_xor.py", "prompt_terminology": "reworded", "tests": "func TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    if len(a) != len(b) {\n        return \"\"\n    }\n    \n    result := make([]byte, len(a))\n    \n    for i := 0; i < len(a); i++ {\n        if a[i] == b[i] {\n            result[i] = '0'\n        } else {\n            result[i] = '1'\n        }\n    }\n    \n    return string(result)\n}\n\nfunc TestStringXor(t *testing.T) {\n    tests := []struct {\n        a    string\n        b    string\n        want string\n    }{\n        {\"010\", \"110\", \"100\"},\n        {\"111\", \"000\", \"111\"},\n        {\"1010\", \"0101\", \"1111\"},\n        {\"0000\", \"0000\", \"0000\"},\n        {\"101010\", \"010101\", \"111111\"},\n    }\n    \n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"%s XOR %s\", tt.a, tt.b), func(t *testing.T) {\n            if got := string_xor(tt.a, tt.b); got != tt.want {\n                t.Errorf(\"string_xor(%q, %q) = %v; want %v\", tt.a, tt.b, got, tt.want)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_11_string_xor"}
{"name": "HumanEval_13_greatest_common_divisor", "language": "go_test.go", "prompt": "package greatest_common_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor(3, 5)\n// 1\n// >>> greatest_common_divisor(25, 15)\n// 5\nfunc greatest_common_divisor(a int, b int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_13_greatest_common_divisor.py", "prompt_terminology": "reworded", "tests": "func TestGreatest_Common_Divisor(t *testing.T) {\n  candidate := greatest_common_divisor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 7), expected: 1 },\n     { actual: candidate(10, 15), expected: 5 },\n     { actual: candidate(49, 14), expected: 7 },\n     { actual: candidate(144, 60), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage greatest_common_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor(3, 5)\n// 1\n// >>> greatest_common_divisor(25, 15)\n// 5\nfunc greatest_common_divisor(a int, b int) int {\n    if b == 0 {\n        return a\n    }\n    return greatest_common_divisor(b, a % b)\n}\n\nfunc TestGreatestCommonDivisor(t *testing.T) {\n    testCases := []struct {\n        a, b, expected int\n    }{\n        {3, 5, 1},\n        {25, 15, 5},\n        {100, 25, 25},\n        {18, 12, 6},\n        {81, 57, 3},\n    }\n\n    for _, tc := range testCases {\n        result := greatest_common_divisor(tc.a, tc.b)\n        if result != tc.expected {\n            t.Errorf(\"greatest_common_divisor(%d, %d) = %d; expected %d\", tc.a, tc.b, result, tc.expected)\n        }\n    }\n}\n\nfunc main() {\n    // Output testing cases\n    fmt.Println(greatest_common_divisor(3, 5))   // 1\n    fmt.Println(greatest_common_divisor(25, 15)) // 5\n}\n```", "task_id": "HumanEval_13_greatest_common_divisor"}
{"name": "HumanEval_14_all_prefixes", "language": "go_test.go", "prompt": "package all_prefixes_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes(\"abc\")\n// []string{\"a\", \"ab\", \"abc\"}\nfunc all_prefixes(myString string) []string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_14_all_prefixes.py", "prompt_terminology": "reworded", "tests": "func TestAll_Prefixes(t *testing.T) {\n  candidate := all_prefixes\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []string{} },\n     { actual: candidate(\"asdfgh\"), expected: []string{\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"} },\n     { actual: candidate(\"WWW\"), expected: []string{\"W\", \"WW\", \"WWW\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage all_prefixes_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes(\"abc\")\n// []string{\"a\", \"ab\", \"abc\"}\nfunc all_prefixes(myString string) []string {\n    prefixes := []string{}\n    for i := 1; i <= len(myString); i++ {\n        prefixes = append(prefixes, myString[:i])\n    }\n    return prefixes\n}\n\nfunc TestAllPrefixes(t *testing.T) {\n    result := all_prefixes(\"abc\")\n    expected := []string{\"a\", \"ab\", \"abc\"}\n    \n    if len(result) != len(expected) {\n        t.Errorf(\"Expected length %d, but got %d\", len(expected), len(result))\n    }\n    \n    for i := range result {\n        if result[i] != expected[i] {\n            t.Errorf(\"Expected %s, but got %s\", expected[i], result[i])\n        }\n    }\n}\n\nfunc ExampleAllPrefixes() {\n    fmt.Println(all_prefixes(\"abc\"))\n    // Output: [a ab abc]\n}\n```", "task_id": "HumanEval_14_all_prefixes"}
{"name": "HumanEval_15_string_sequence", "language": "go_test.go", "prompt": "package string_sequence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence(0)\n// \"0\"\n// >>> string_sequence(5)\n// \"0 1 2 3 4 5\"\nfunc string_sequence(n int) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_15_string_sequence.py", "prompt_terminology": "reworded", "tests": "func TestString_Sequence(t *testing.T) {\n  candidate := string_sequence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"0\" },\n     { actual: candidate(3), expected: \"0 1 2 3\" },\n     { actual: candidate(10), expected: \"0 1 2 3 4 5 6 7 8 9 10\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage string_sequence_test\n\nimport (\n    \"strings\"\n    \"testing\"\n    \"fmt\"\n)\n\n// Return a string containing space-delimited numbers starting from 0 up to n inclusive.\n// >>> string_sequence(0)\n// \"0\"\n// >>> string_sequence(5)\n// \"0 1 2 3 4 5\"\nfunc string_sequence(n int) string {\n    var sb strings.Builder\n    for i := 0; i <= n; i++ {\n        sb.WriteString(fmt.Sprintf(\"%d\", i))\n        if i != n {\n            sb.WriteString(\" \")\n        }\n    }\n    return sb.String()\n}\n\nfunc TestStringSequence(t *testing.T) {\n    tests := []struct {\n        input int\n        want  string\n    }{\n        {0, \"0\"},\n        {1, \"0 1\"},\n        {5, \"0 1 2 3 4 5\"},\n        {10, \"0 1 2 3 4 5 6 7 8 9 10\"},\n    }\n\n    for _, test := range tests {\n        got := string_sequence(test.input)\n        if got != test.want {\n            t.Errorf(\"string_sequence(%d) = %q, want %q\", test.input, got, test.want)\n        }\n    }\n}\n```", "task_id": "HumanEval_15_string_sequence"}
{"name": "HumanEval_16_count_distinct_characters", "language": "go_test.go", "prompt": "package count_distinct_characters_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters(\"xyzXYZ\")\n// 3\n// >>> count_distinct_characters(\"Jerry\")\n// 4\nfunc count_distinct_characters(myString string) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_16_count_distinct_characters.py", "prompt_terminology": "reworded", "tests": "func TestCount_Distinct_Characters(t *testing.T) {\n  candidate := count_distinct_characters\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"abcde\"), expected: 5 },\n     { actual: candidate(\"abcdecadeCADE\"), expected: 5 },\n     { actual: candidate(\"aaaaAAAAaaaa\"), expected: 1 },\n     { actual: candidate(\"Jerry jERRY JeRRRY\"), expected: 5 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage count_distinct_characters_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc count_distinct_characters(myString string) int {\n    characterSet := make(map[rune]bool)\n    for _, char := range strings.ToLower(myString) {\n        characterSet[char] = true\n    }\n    return len(characterSet)\n}\n\nfunc TestCountDistinctCharacters(t *testing.T) {\n    testCases := []struct{\n        input string\n        expected int\n    }{\n        {\"xyzXYZ\", 3},\n        {\"Jerry\", 4},\n        {\"hello\", 4},\n        {\"\", 0},\n        {\"AaBbCc\", 3},\n    }\n\n    for _, testCase := range testCases {\n        result := count_distinct_characters(testCase.input)\n        if result != testCase.expected {\n            t.Errorf(\"For input %q, expected %d but got %d\", testCase.input, testCase.expected, result)\n        }\n    }\n}\n\nfunc ExampleCountDistinctCharacters() {\n    fmt.Println(count_distinct_characters(\"xyzXYZ\")) // Output: 3\n    fmt.Println(count_distinct_characters(\"Jerry\")) // Output: 4\n    // Output:\n    // 3\n    // 4\n}\n```\n\nThis Go code includes the `count_distinct_characters` function, a test function `TestCountDistinctCharacters`, and an example function `ExampleCountDistinctCharacters`. The function counts distinct characters in a case-insensitive manner using a map to track seen characters. The test and example functions demonstrate the function's correctness.", "task_id": "HumanEval_16_count_distinct_characters"}
{"name": "HumanEval_17_parse_music", "language": "go_test.go", "prompt": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_17_parse_music.py", "prompt_terminology": "reworded", "tests": "func TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage parse_music_test\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quarter note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n\tvar result []int\n\tnotes := strings.Split(music_string, \" \")\n\n\tfor _, note := range notes {\n\t\tswitch note {\n\t\tcase \"o\":\n\t\t\tresult = append(result, 4)\n\t\tcase \"o|\":\n\t\t\tresult = append(result, 2)\n\t\tcase \".|\":\n\t\t\tresult = append(result, 1)\n\t\tdefault:\n\t\t\t// Handle any unexpected input\n\t\t\tresult = append(result, 0)\n\t\t}\n\t}\n\n\treturn result\n}\n\n// Unit tests for parse_music function\nfunc TestParseMusic(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []int\n\t}{\n\t\t{\"o o| .| o| o| .| .| .| .| o o\", []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}},\n\t\t{\"o\", []int{4}},\n\t\t{\"o| .|\", []int{2, 1}},\n\t\t{\"o o o o\", []int{4, 4, 4, 4}},\n\t\t{\"\", []int{}},\n\t\t{\".| .| .| .|\", []int{1, 1, 1, 1}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := parse_music(test.input)\n\t\tif !equal(result, test.expected) {\n\t\t\tt.Errorf(\"For input '%s', expected %v but got %v\", test.input, test.expected, result)\n\t\t}\n\t}\n}\n\n// Helper function to check equality of two slices\nfunc equal(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n```", "task_id": "HumanEval_17_parse_music"}
{"name": "HumanEval_18_how_many_times", "language": "go_test.go", "prompt": "package how_many_times_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times(\"\", \"a\")\n// 0\n// >>> how_many_times(\"aaa\", \"a\")\n// 3\n// >>> how_many_times(\"aaaa\", \"aa\")\n// 3\nfunc how_many_times(myString string, substring string) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_18_how_many_times.py", "prompt_terminology": "reworded", "tests": "func TestHow_Many_Times(t *testing.T) {\n  candidate := how_many_times\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\", \"x\"), expected: 0 },\n     { actual: candidate(\"xyxyxyx\", \"x\"), expected: 4 },\n     { actual: candidate(\"cacacacac\", \"cac\"), expected: 4 },\n     { actual: candidate(\"john doe\", \"john\"), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage how_many_times_test\n\nimport (\n    \"strings\"\n    \"testing\"\n    \"fmt\"\n)\n\n// Find how many times a given substring can be found in the original string. Count overlapping cases.\n// >>> how_many_times(\"\", \"a\")\n// 0\n// >>> how_many_times(\"aaa\", \"a\")\n// 3\n// >>> how_many_times(\"aaaa\", \"aa\")\n// 3\nfunc how_many_times(myString string, substring string) int {\n    if len(substring) == 0 {\n        return 0\n    }\n\n    count := 0\n    index := 0\n\n    for {\n        index = strings.Index(myString, substring)\n        if index == -1 {\n            break\n        }\n        count++\n        myString = myString[index+1:]\n    }\n\n    return count\n}\n\nfunc TestHowManyTimes(t *testing.T) {\n    testCases := []struct {\n        myString  string\n        substring string\n        expected  int\n    }{\n        {\"\", \"a\", 0},\n        {\"aaa\", \"a\", 3},\n        {\"aaaa\", \"aa\", 3},\n        {\"abcabcabc\", \"abc\", 3},\n        {\"abababa\", \"aba\", 3},\n        {\"abababa\", \"ab\", 3},\n        {\"a\", \"ab\", 0},\n    }\n\n    for _, tc := range testCases {\n        result := how_many_times(tc.myString, tc.substring)\n        if result != tc.expected {\n            t.Errorf(\"how_many_times(%q, %q) = %d; expected %d\", tc.myString, tc.substring, result, tc.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(how_many_times(\"\", \"a\"))       // Output: 0\n    fmt.Println(how_many_times(\"aaa\", \"a\"))    // Output: 3\n    fmt.Println(how_many_times(\"aaaa\", \"aa\"))  // Output: 3\n}\n```\n\nIn this code, we first define the `how_many_times` function which calculates the number of times a given `substring` appears in `myString`, including overlapping occurrences. Then we define a test function `TestHowManyTimes` using the `testing` package to verify different test cases. Finally, `main` function provides sample usages of the `how_many_times` function. Note that for running Go tests, you typically use the `go test` command, and the `main` function is not required for that.", "task_id": "HumanEval_18_how_many_times"}
{"name": "HumanEval_19_sort_numbers", "language": "go_test.go", "prompt": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_19_sort_numbers.py", "prompt_terminology": "reworded", "tests": "func TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage sort_numbers_test\n\nimport (\n    \"strings\"\n    \"sort\"\n    \"testing\"\n    \"fmt\"\n)\n\nvar numberMap = map[string]int{\n    \"zero\" : 0,\n    \"one\" : 1,\n    \"two\" : 2,\n    \"three\" : 3,\n    \"four\" : 4,\n    \"five\" : 5,\n    \"six\" : 6,\n    \"seven\" : 7,\n    \"eight\" : 8,\n    \"nine\" : 9,\n}\n\nvar reverseMap = map[int]string {\n    0: \"zero\",\n    1: \"one\",\n    2: \"two\",\n    3: \"three\",\n    4: \"four\",\n    5: \"five\",\n    6: \"six\",\n    7: \"seven\",\n    8: \"eight\",\n    9: \"nine\",\n}\n\nfunc sort_numbers(numbers string) string {\n    if numbers == \"\" {\n        return \"\"\n    }\n\n    numberList := strings.Split(numbers, \" \")\n    numberValues := make([]int, len(numberList))\n\n    for i, num := range numberList {\n        numberValues[i] = numberMap[num]\n    }\n\n    sort.Ints(numberValues)\n\n    sortedNumbers := make([]string, len(numberValues))\n    for i, val := range numberValues {\n        sortedNumbers[i] = reverseMap[val]\n    }\n\n    return strings.Join(sortedNumbers, \" \")\n}\n\nfunc TestSortNumbers(t *testing.T) {\n    cases := []struct {\n        input string\n        expected string\n    }{\n        {\"three one five\", \"one three five\"},\n        {\"nine eight seven six\", \"six seven eight nine\"},\n        {\"zero four five two\", \"zero two four five\"},\n        {\"four five six six\", \"four five six six\"},\n        {\"\", \"\"},\n    }\n\n    for _, tc := range cases {\n        result := sort_numbers(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"For input '%s' expected '%s' but got '%s'\", tc.input, tc.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(sort_numbers(\"three one five\")) // Output: one three five\n    fmt.Println(sort_numbers(\"nine eight seven six\")) // Output: six seven eight nine\n}\n```", "task_id": "HumanEval_19_sort_numbers"}
{"name": "HumanEval_20_find_closest_elements", "language": "go_test.go", "prompt": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_20_find_closest_elements.py", "prompt_terminology": "reworded", "tests": "func TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage find_closest_elements_test\n\nimport (\n    \"math\"\n    \"sort\"\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n    // Sort the slice to make finding closest elements easier\n    sort.Float64s(numbers)\n\n    minDiff := math.MaxFloat64 // Initialize with maximum possible difference\n    var result []interface{}\n\n    // Iterate through sorted numbers to find the pair with the smallest difference\n    for i := 1; i < len(numbers); i++ {\n        // Calculate the difference between the current and previous element\n        diff := numbers[i] - numbers[i-1]\n        if diff < minDiff {\n            minDiff = diff\n            result = []interface{}{numbers[i-1], numbers[i]}\n        }\n    }\n\n    return result\n}\n\n// Test cases\nfunc TestFindClosestElements(t *testing.T) {\n    tests := []struct {\n        input  []float64\n        output []interface{}\n    }{\n        {[]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}, []interface{}{2.0, 2.2}},\n        {[]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, []interface{}{2.0, 2.0}},\n        {[]float64{10.5, 8.1, 6.8, 9.5, 5.2, 7.3}, []interface{}{8.1, 9.5}},\n        {[]float64{0.1, 0.1}, []interface{}{0.1, 0.1}},\n    }\n\n    for _, test := range tests {\n        result := find_closest_elements(test.input)\n        for i, v := range result {\n            if v != test.output[i] {\n                t.Errorf(\"For input %v, expected %v, but got %v\", test.input, test.output, result)\n                break\n            }\n        }\n    }\n}\n```\n\nThis code defines the `find_closest_elements` function and a corresponding test function `TestFindClosestElements`. The `find_closest_elements` function sorts the input numbers and finds the two closest elements. The test function verifies the correctness of the implementation using a series of test cases.", "task_id": "HumanEval_20_find_closest_elements"}
{"name": "HumanEval_21_rescale_to_unit", "language": "go_test.go", "prompt": "package rescale_to_unit_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([]float64{1.0, 2.0, 3.0, 4.0, 5.0})\n// []float64{0.0, 0.25, 0.5, 0.75, 1.0}\nfunc rescale_to_unit(numbers []float64) []float64 {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_21_rescale_to_unit.py", "prompt_terminology": "reworded", "tests": "func TestRescale_To_Unit(t *testing.T) {\n  candidate := rescale_to_unit\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{2.0, 49.9}), expected: []float64{0.0, 1.0} },\n     { actual: candidate([]float64{100.0, 49.9}), expected: []float64{1.0, 0.0} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0}), expected: []float64{0.0, 0.25, 0.5, 0.75, 1.0} },\n     { actual: candidate([]float64{2.0, 1.0, 5.0, 3.0, 4.0}), expected: []float64{0.25, 0.0, 1.0, 0.5, 0.75} },\n     { actual: candidate([]float64{12.0, 11.0, 15.0, 13.0, 14.0}), expected: []float64{0.25, 0.0, 1.0, 0.5, 0.75} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage rescale_to_unit_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([]float64{1.0, 2.0, 3.0, 4.0, 5.0})\n// []float64{0.0, 0.25, 0.5, 0.75, 1.0}\nfunc rescale_to_unit(numbers []float64) []float64 {\n    min, max := numbers[0], numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n\n    scale := max - min\n    rescaled := make([]float64, len(numbers))\n    for i, number := range numbers {\n        rescaled[i] = (number - min) / scale\n    }\n    return rescaled\n}\n\nfunc TestRescaleToUnit(t *testing.T) {\n    input := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n    expected := []float64{0.0, 0.25, 0.5, 0.75, 1.0}\n    result := rescale_to_unit(input)\n\n    if len(result) != len(expected) {\n        t.Fatalf(\"Expected length %d but got %d\", len(expected), len(result))\n    }\n\n    for i := range result {\n        if result[i] != expected[i] {\n            t.Errorf(\"At index %d, expected %f but got %f\", i, expected[i], result[i])\n        }\n    }\n}\n\nfunc main() {\n    test := testing.T{}\n    TestRescaleToUnit(&test)\n    fmt.Println(\"All tests passed.\")\n}\n```", "task_id": "HumanEval_21_rescale_to_unit"}
{"name": "HumanEval_22_filter_integers", "language": "go_test.go", "prompt": "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc filter_integers(values []interface{}) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_22_filter_integers.py", "prompt_terminology": "reworded", "tests": "func TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Filter given list of any Go values only for integers\n// >>> filter_integers([]interface{}{\"a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc filter_integers(values []interface{}) []int {\n    var result []int\n    for _, v := range values {\n        if intValue, ok := v.(int); ok {\n            result = append(result, intValue)\n        }\n    }\n    return result\n}\n\nfunc TestFilterIntegers(t *testing.T) {\n    tests := []struct {\n        input  []interface{}\n        output []int\n    }{\n        {[]interface{}{\"a\", 3.14, 5}, []int{5}},\n        {[]interface{}{1, 2, 3, \"abc\", map[interface{}]interface{}{}, []interface{}{}}, []int{1, 2, 3}},\n        {[]interface{}{float64(3.14), int64(4), 5, \"test\", true, nil, 7}, []int{5, 7}},\n        {[]interface{}{}, []int{}},\n    }\n\n    for _, test := range tests {\n        result := filter_integers(test.input)\n        if !equals(result, test.output) {\n            t.Errorf(\"filter_integers(%v) = %v; want %v\", test.input, result, test.output)\n        }\n    }\n}\n\nfunc equals(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i, v := range a {\n        if v != b[i] {\n            return false\n        }\n    }\n    return true\n}\n```", "task_id": "HumanEval_22_filter_integers"}
{"name": "HumanEval_23_strlen", "language": "go_test.go", "prompt": "package strlen_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return length of given string\n// >>> strlen(\"\")\n// 0\n// >>> strlen(\"abc\")\n// 3\nfunc strlen(myString string) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_23_strlen.py", "prompt_terminology": "reworded", "tests": "func TestStrlen(t *testing.T) {\n  candidate := strlen\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"x\"), expected: 1 },\n     { actual: candidate(\"asdasnakj\"), expected: 9 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage strlen_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return length of given string\n// >>> strlen(\"\")\n// 0\n// >>> strlen(\"abc\")\n// 3\nfunc strlen(myString string) int {\n    return len(myString)\n}\n\nfunc TestStrlen(t *testing.T) {\n    tests := []struct {\n        input string\n        want  int\n    }{\n        {\"\", 0},\n        {\"abc\", 3},\n        {\"hello\", 5},\n        {\"GoLang\", 6},\n    }\n\n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"strlen(%q)\", tt.input), func(t *testing.T) {\n            got := strlen(tt.input)\n            if got != tt.want {\n                t.Errorf(\"strlen(%q) = %d; want %d\", tt.input, got, tt.want)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_23_strlen"}
{"name": "HumanEval_24_largest_divisor", "language": "go_test.go", "prompt": "package largest_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor(15)\n// 5\nfunc largest_divisor(n int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_24_largest_divisor.py", "prompt_terminology": "reworded", "tests": "func TestLargest_Divisor(t *testing.T) {\n  candidate := largest_divisor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3), expected: 1 },\n     { actual: candidate(7), expected: 1 },\n     { actual: candidate(10), expected: 5 },\n     { actual: candidate(100), expected: 50 },\n     { actual: candidate(49), expected: 7 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage largest_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor(15)\n// 5\nfunc largest_divisor(n int) int {\n    if n <= 1 {\n        return 0 // For n <= 1, there are no divisors smaller than n\n    }\n    for i := n / 2; i >= 1; i-- {\n        if n%i == 0 {\n            return i\n        }\n    }\n    return 1 // This line should never be reached for n > 1\n}\n\nfunc TestLargestDivisor(t *testing.T) {\n    tests := []struct {\n        input    int\n        expected int\n    }{\n        {15, 5},\n        {12, 6},\n        {100, 50},\n        {97, 1},  // 97 is a prime number\n        {1, 0},   // No divisor smaller than 1\n        {0, 0},   // n <= 1 should return 0\n    }\n\n    for _, test := range tests {\n        if output := largest_divisor(test.input); output != test.expected {\n            t.Errorf(\"For input %d, expected %d, but got %d\", test.input, test.expected, output)\n        } else {\n            fmt.Printf(\"For input %d, got the expected result %d\\n\", test.input, output)\n        }\n    }\n}\n```", "task_id": "HumanEval_24_largest_divisor"}
{"name": "HumanEval_25_factorize", "language": "go_test.go", "prompt": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_25_factorize.py", "prompt_terminology": "reworded", "tests": "func TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    if n <= 1 {\n        return []int{}\n    }\n    factors := []int{}\n    for i := 2; i*i <= n; i++ {\n        for n%i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    if n > 1 {\n        factors = append(factors, n)\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n    testCases := []struct {\n        input  int\n        expect []int\n    }{\n        {8, []int{2, 2, 2}},\n        {25, []int{5, 5}},\n        {70, []int{2, 5, 7}},\n        {1, []int{}},\n        {2, []int{2}},\n        {3, []int{3}},\n        {4, []int{2, 2}},\n        {100, []int{2, 2, 5, 5}},\n    }\n\n    for _, tc := range testCases {\n        result := factorize(tc.input)\n        if !equal(result, tc.expect) {\n            t.Errorf(\"for input %d expected %v but got %v\", tc.input, tc.expect, result)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    fmt.Println(factorize(8))   // Output: [2 2 2]\n    fmt.Println(factorize(25))  // Output: [5 5]\n    fmt.Println(factorize(70))  // Output: [2 5 7]\n    fmt.Println(factorize(100)) // Output: [2 2 5 5]\n}\n```", "task_id": "HumanEval_25_factorize"}
{"name": "HumanEval_26_remove_duplicates", "language": "go_test.go", "prompt": "package remove_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a list of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates([]int{1, 2, 3, 2, 4})\n// []int{1, 3, 4}\nfunc remove_duplicates(numbers []int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_26_remove_duplicates.py", "prompt_terminology": "reworded", "tests": "func TestRemove_Duplicates(t *testing.T) {\n  candidate := remove_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{1, 2, 3, 2, 4, 3, 5}), expected: []int{1, 4, 5} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage remove_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a list of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates([]int{1, 2, 3, 2, 4})\n// []int{1, 3, 4}\nfunc remove_duplicates(numbers []int) []int {\n    countMap := make(map[int]int)\n    result := []int{}\n\n    // Count occurrences of each number\n    for _, num := range numbers {\n        countMap[num]++\n    }\n\n    // Collect numbers that occur only once\n    for _, num := range numbers {\n        if countMap[num] == 1 {\n            result = append(result, num)\n        }\n    }\n\n    return result\n}\n\nfunc TestRemoveDuplicates(t *testing.T) {\n    testCases := []struct {\n        input    []int\n        expected []int\n    }{\n        {[]int{1, 2, 3, 2, 4}, []int{1, 3, 4}},\n        {[]int{1, 1, 1, 1, 1}, []int{}},\n        {[]int{1, 2, 3, 4, 5}, []int{1, 2, 3, 4, 5}},\n        {[]int{1, 2, 3, 3, 2, 4}, []int{1, 4}},\n        {[]int{5, 5, 5, 5, 5, 5}, []int{}},\n        {[]int{}, []int{}},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"%v\", tc.input), func(t *testing.T) {\n            result := remove_duplicates(tc.input)\n            if !equal(result, tc.expected) {\n                t.Fatalf(\"expected: %v, got: %v\", tc.expected, result)\n            }\n        })\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n```", "task_id": "HumanEval_26_remove_duplicates"}
{"name": "HumanEval_27_flip_case", "language": "go_test.go", "prompt": "package flip_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case(\"Hello\")\n// \"hELLO\"\nfunc flip_case(myString string) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_27_flip_case.py", "prompt_terminology": "reworded", "tests": "func TestFlip_Case(t *testing.T) {\n  candidate := flip_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"Hello!\"), expected: \"hELLO!\" },\n     { actual: candidate(\"These violent delights have violent ends\"), expected: \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage flip_case_test\n\nimport (\n    \"testing\"\n    \"unicode\"\n    \"fmt\"\n)\n\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case(\"Hello\")\n// \"hELLO\"\nfunc flip_case(myString string) string {\n    var result []rune\n    for _, r := range myString {\n        if unicode.IsLower(r) {\n            result = append(result, unicode.ToUpper(r))\n        } else if unicode.IsUpper(r) {\n            result = append(result, unicode.ToLower(r))\n        } else {\n            result = append(result, r)\n        }\n    }\n    return string(result)\n}\n\nfunc TestFlipCase(t *testing.T) {\n    testCases := []struct {\n        input    string\n        expected string\n    }{\n        {\"Hello\", \"hELLO\"},\n        {\"WORLD\", \"world\"},\n        {\"GoLang123\", \"gOlANG123\"},\n        {\"1234\", \"1234\"},\n        {\"Test_CASE\", \"tEST_case\"},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"flip_case(%s)\", tc.input), func(t *testing.T) {\n            result := flip_case(tc.input)\n            if result != tc.expected {\n                t.Errorf(\"expected %s, got %s\", tc.expected, result)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_27_flip_case"}
{"name": "HumanEval_28_concatenate", "language": "go_test.go", "prompt": "package concatenate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Concatenate list of strings into a single string\n// >>> concatenate([]string{})\n// \"\"\n// >>> concatenate([]string{\"a\", \"b\", \"c\"})\n// \"abc\"\nfunc concatenate(strings []string) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_28_concatenate.py", "prompt_terminology": "reworded", "tests": "func TestConcatenate(t *testing.T) {\n  candidate := concatenate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}), expected: \"\" },\n     { actual: candidate([]string{\"x\", \"y\", \"z\"}), expected: \"xyz\" },\n     { actual: candidate([]string{\"x\", \"y\", \"z\", \"w\", \"k\"}), expected: \"xyzwk\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage concatenate_test\n\nimport (\n    \"strings\"\n    \"testing\"\n    \"fmt\"\n)\n\n// Concatenate list of strings into a single string\n// >>> concatenate([]string{})\n// \"\"\n// >>> concatenate([]string{\"a\", \"b\", \"c\"})\n// \"abc\"\nfunc concatenate(strs []string) string {\n    return strings.Join(strs, \"\")\n}\n\nfunc TestConcatenate(t *testing.T) {\n    tests := []struct {\n        input    []string\n        expected string\n    }{\n        {[]string{}, \"\"},\n        {[]string{\"a\", \"b\", \"c\"}, \"abc\"},\n        {[]string{\"hello\", \" \", \"world\"}, \"hello world\"},\n        {[]string{\"golang\", \"is\", \"awesome\"}, \"golangisawesome\"},\n    }\n\n    for _, test := range tests {\n        result := concatenate(test.input)\n        if result != test.expected {\n            t.Errorf(\"concatenate(%v) = %v; expected %v\", test.input, result, test.expected)\n        }\n    }\n}\n\nfunc ExampleConcatenate() {\n    fmt.Println(concatenate([]string{}))\n    fmt.Println(concatenate([]string{\"a\", \"b\", \"c\"}))\n    // Output:\n    // \n    // abc\n}\n```", "task_id": "HumanEval_28_concatenate"}
{"name": "HumanEval_29_filter_by_prefix", "language": "go_test.go", "prompt": "package filter_by_prefix_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Filter an input list of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([]string{}, \"a\")\n// []string{}\n// >>> filter_by_prefix([]string{\"abc\", \"bcd\", \"cde\", \"array\"}, \"a\")\n// []string{\"abc\", \"array\"}\nfunc filter_by_prefix(strings []string, prefix string) []string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_29_filter_by_prefix.py", "prompt_terminology": "reworded", "tests": "func TestFilter_By_Prefix(t *testing.T) {\n  candidate := filter_by_prefix\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}, \"john\"), expected: []string{} },\n     { actual: candidate([]string{\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"), expected: []string{\"xxx\", \"xxxAAA\", \"xxx\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage filter_by_prefix_test\n\nimport (\n    \"strings\"\n    \"testing\"\n    \"fmt\"\n)\n\n// Filter an input list of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([]string{}, \"a\")\n// []string{}\n// >>> filter_by_prefix([]string{\"abc\", \"bcd\", \"cde\", \"array\"}, \"a\")\n// []string{\"abc\", \"array\"}\nfunc filter_by_prefix(strings []string, prefix string) []string {\n    var result []string\n    for _, str := range strings {\n        if strings.HasPrefix(str, prefix) {\n            result = append(result, str)\n        }\n    }\n    return result\n}\n\nfunc TestFilterByPrefix(t *testing.T) {\n    // Test case 1: Empty input list\n    input := []string{}\n    prefix := \"a\"\n    expected := []string{}\n    result := filter_by_prefix(input, prefix)\n    if !equal(result, expected) {\n        t.Errorf(\"Expected %v, but got %v\", expected, result)\n    }\n\n    // Test case 2: List with matching prefixes\n    input = []string{\"abc\", \"bcd\", \"cde\", \"array\"}\n    prefix = \"a\"\n    expected = []string{\"abc\", \"array\"}\n    result = filter_by_prefix(input, prefix)\n    if !equal(result, expected) {\n        t.Errorf(\"Expected %v, but got %v\", expected, result)\n    }\n\n    // Test case 3: List with no matching prefix\n    input = []string{\"bcd\", \"cde\", \"def\"}\n    prefix = \"a\"\n    expected = []string{}\n    result = filter_by_prefix(input, prefix)\n    if !equal(result, expected) {\n        t.Errorf(\"Expected %v, but got %v\", expected, result)\n    }\n\n    // Test case 4: List with all elements having same prefix\n    input = []string{\"apple\", \"ape\", \"apricot\"}\n    prefix = \"ap\"\n    expected = []string{\"apple\", \"ape\", \"apricot\"}\n    result = filter_by_prefix(input, prefix)\n    if !equal(result, expected) {\n        t.Errorf(\"Expected %v, but got %v\", expected, result)\n    }\n}\n\n// Helper function to check equality of two string slices\nfunc equal(a, b []string) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n\n// Example usage\nfunc ExampleFilterByPrefix() {\n    fmt.Println(filter_by_prefix([]string{\"abc\", \"bcd\", \"cde\", \"array\"}, \"a\"))\n    // Output: [abc array]\n}\n```", "task_id": "HumanEval_29_filter_by_prefix"}
{"name": "HumanEval_30_get_positive", "language": "go_test.go", "prompt": "package get_positive_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return only positive numbers in the list.\n// >>> get_positive([]int{-1, 2, -4, 5, 6})\n// []int{2, 5, 6}\n// >>> get_positive([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n// []int{5, 3, 2, 3, 9, 123, 1}\nfunc get_positive(l []int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_30_get_positive.py", "prompt_terminology": "reworded", "tests": "func TestGet_Positive(t *testing.T) {\n  candidate := get_positive\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{-1, -2, 4, 5, 6}), expected: []int{4, 5, 6} },\n     { actual: candidate([]int{5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}), expected: []int{5, 3, 2, 3, 3, 9, 123, 1} },\n     { actual: candidate([]int{-1, -2}), expected: []int{} },\n     { actual: candidate([]int{}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage get_positive_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return only positive numbers in the list.\n// >>> get_positive([]int{-1, 2, -4, 5, 6})\n// []int{2, 5, 6}\n// >>> get_positive([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n// []int{5, 3, 2, 3, 9, 123, 1}\nfunc get_positive(l []int) []int {\n    var positive []int\n    for _, num := range l {\n        if num > 0 {\n            positive = append(positive, num)\n        }\n    }\n    return positive\n}\n\nfunc TestGetPositive(t *testing.T) {\n    tests := []struct {\n        input    []int\n        expected []int\n    }{\n        {[]int{-1, 2, -4, 5, 6}, []int{2, 5, 6}},\n        {[]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}, []int{5, 3, 2, 3, 9, 123, 1}},\n        {[]int{}, []int{}},\n        {[]int{-1, -2, -3}, []int{}},\n        {[]int{1, 2, 3, 4}, []int{1, 2, 3, 4}},\n    }\n\n    for _, test := range tests {\n        got := get_positive(test.input)\n        if !equal(got, test.expected) {\n            t.Errorf(\"get_positive(%v) = %v; expected %v\", test.input, got, test.expected)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i, v := range a {\n        if v != b[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    fmt.Println(get_positive([]int{-1, 2, -4, 5, 6}))\n    fmt.Println(get_positive([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}))\n}\n```", "task_id": "HumanEval_30_get_positive"}
{"name": "HumanEval_31_is_prime", "language": "go_test.go", "prompt": "package is_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime(6)\n// false\n// >>> is_prime(101)\n// true\n// >>> is_prime(11)\n// true\n// >>> is_prime(13441)\n// true\n// >>> is_prime(61)\n// true\n// >>> is_prime(4)\n// false\n// >>> is_prime(1)\n// false\nfunc is_prime(n int) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_31_is_prime.py", "prompt_terminology": "reworded", "tests": "func TestIs_Prime(t *testing.T) {\n  candidate := is_prime\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(6), expected: false },\n     { actual: candidate(101), expected: true },\n     { actual: candidate(11), expected: true },\n     { actual: candidate(13441), expected: true },\n     { actual: candidate(61), expected: true },\n     { actual: candidate(4), expected: false },\n     { actual: candidate(1), expected: false },\n     { actual: candidate(5), expected: true },\n     { actual: candidate(11), expected: true },\n     { actual: candidate(17), expected: true },\n     { actual: candidate(85), expected: false },\n     { actual: candidate(77), expected: false },\n     { actual: candidate(255379), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage is_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime(6)\n// false\n// >>> is_prime(101)\n// true\n// >>> is_prime(11)\n// true\n// >>> is_prime(13441)\n// true\n// >>> is_prime(61)\n// true\n// >>> is_prime(4)\n// false\n// >>> is_prime(1)\n// false\nfunc is_prime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n%2 == 0 {\n        return false\n    }\n    sqrtN := int(math.Sqrt(float64(n)))\n    for i := 3; i <= sqrtN; i += 2 {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIsPrime(t *testing.T) {\n    tests := []struct {\n        input    int\n        expected bool\n    }{\n        {6, false},\n        {101, true},\n        {11, true},\n        {13441, true},\n        {61, true},\n        {4, false},\n        {1, false},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"is_prime(%d)\", test.input), func(t *testing.T) {\n            result := is_prime(test.input)\n            if result != test.expected {\n                t.Errorf(\"Expected is_prime(%d) to be %v, got %v\", test.input, test.expected, result)\n            }\n        })\n    }\n}\n```\n\nThis `go` code implements the function `is_prime` to check if a number is prime, and a test function `TestIsPrime` to verify the correctness of the `is_prime` function against multiple test cases specified in the requirements.", "task_id": "HumanEval_31_is_prime"}
{"name": "HumanEval_33_sort_third", "language": "go_test.go", "prompt": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_33_sort_third.py", "prompt_terminology": "reworded", "tests": "func TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"sort\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n// to the values of the corresponding indices of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Collect values from indices divisible by 3\n    var divisibleByThree []int\n    for i := range l {\n        if i % 3 == 0 {\n            divisibleByThree = append(divisibleByThree, l[i])\n        }\n    }\n\n    // Sort the collected values\n    sort.Ints(divisibleByThree)\n\n    // Create a new list with sorted values at indices divisible by 3\n    var idx int\n    for i := range l {\n        if i % 3 == 0 {\n            l[i] = divisibleByThree[idx]\n            idx++\n        }\n    }\n\n    return l\n}\n\nfunc TestSortThird(t *testing.T) {\n    cases := []struct {\n        input []int\n        want  []int\n    }{\n        {[]int{1, 2, 3}, []int{1, 2, 3}},\n        {[]int{5, 6, 3, 4, 8, 9, 2}, []int{2, 6, 3, 4, 8, 9, 5}},\n        {[]int{3, 2, 1, 6, 5, 4, 9, 8, 7}, []int{1, 2, 3, 6, 5, 4, 7, 8, 9}},\n    }\n\n    for _, c := range cases {\n        got := sort_third(c.input)\n        for i := range got {\n            if got[i] != c.want[i] {\n                t.Errorf(\"sort_third(%v) == %v, want %v\", c.input, got, c.want)\n                break\n            }\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(sort_third([]int{1, 2, 3})) // [1 2 3]\n    fmt.Println(sort_third([]int{5, 6, 3, 4, 8, 9, 2})) // [2 6 3 4 8 9 5]\n}\n```", "task_id": "HumanEval_33_sort_third"}
{"name": "HumanEval_34_unique", "language": "go_test.go", "prompt": "package unique_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return sorted unique elements in a list\n// >>> unique([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n// []int{0, 2, 3, 5, 9, 123}\nfunc unique(l []int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_34_unique.py", "prompt_terminology": "reworded", "tests": "func TestUnique(t *testing.T) {\n  candidate := unique\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 3, 5, 2, 3, 3, 9, 0, 123}), expected: []int{0, 2, 3, 5, 9, 123} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage unique_test\n\nimport (\n    \"sort\"\n    \"testing\"\n    \"fmt\"\n)\n\n// Return sorted unique elements in a list\n// >>> unique([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n// []int{0, 2, 3, 5, 9, 123}\nfunc unique(l []int) []int {\n    uniqueMap := make(map[int]bool)\n    uniqueList := []int{}\n\n    // Insert elements into map to filter out duplicates\n    for _, v := range l {\n        if !uniqueMap[v] {\n            uniqueMap[v] = true\n            uniqueList = append(uniqueList, v)\n        }\n    }\n\n    // Sort the resulting list of unique numbers\n    sort.Ints(uniqueList)\n\n    return uniqueList\n}\n\nfunc TestUnique(t *testing.T) {\n    input := []int{5, 3, 5, 2, 3, 3, 9, 0, 123}\n    expected := []int{0, 2, 3, 5, 9, 123}\n    \n    result := unique(input)\n\n    if !equal(result, expected) {\n        t.Errorf(\"Expected %v but got %v\", expected, result)\n    } else {\n        fmt.Printf(\"Passed: %v\\n\", result)\n    }\n}\n\n// Helper function to compare equality of two slices\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    // Manually run test\n    TestUnique(nil)\n}\n```", "task_id": "HumanEval_34_unique"}
{"name": "HumanEval_35_max_element", "language": "go_test.go", "prompt": "package max_element_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return maximum element in the list.\n// >>> max_element([]int{1, 2, 3})\n// 3\n// >>> max_element([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n// 123\nfunc max_element(l []int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_35_max_element.py", "prompt_terminology": "reworded", "tests": "func TestMax_Element(t *testing.T) {\n  candidate := max_element\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3}), expected: 3 },\n     { actual: candidate([]int{5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10}), expected: 124 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage max_element_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return maximum element in the list.\n// >>> max_element([]int{1, 2, 3})\n// 3\n// >>> max_element([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n// 123\nfunc max_element(l []int) int {\n    if len(l) == 0 {\n        panic(\"list must not be empty\")\n    }\n\n    max := l[0]\n    for _, v := range l {\n        if v > max {\n            max = v\n        }\n    }\n    return max\n}\n\nfunc TestMaxElement(t *testing.T) {\n    var tests = []struct {\n        input []int\n        expected int\n    }{\n        {[]int{1, 2, 3}, 3},\n        {[]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}, 123},\n        {[]int{-1, -2, -3, -4}, -1},\n        {[]int{0, 0, 0, 0}, 0},\n    }\n\n    for _, test := range tests {\n        if got := max_element(test.input); got != test.expected {\n            t.Errorf(\"max_element(%v) = %v; want %v\", test.input, got, test.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(max_element([]int{1, 2, 3}) == 3)\n    fmt.Println(max_element([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}) == 123)\n}\n```", "task_id": "HumanEval_35_max_element"}
{"name": "HumanEval_36_fizz_buzz", "language": "go_test.go", "prompt": "package fizz_buzz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz(50)\n// 0\n// >>> fizz_buzz(78)\n// 2\n// >>> fizz_buzz(79)\n// 3\nfunc fizz_buzz(n int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_36_fizz_buzz.py", "prompt_terminology": "reworded", "tests": "func TestFizz_Buzz(t *testing.T) {\n  candidate := fizz_buzz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(50), expected: 0 },\n     { actual: candidate(78), expected: 2 },\n     { actual: candidate(79), expected: 3 },\n     { actual: candidate(100), expected: 3 },\n     { actual: candidate(200), expected: 6 },\n     { actual: candidate(4000), expected: 192 },\n     { actual: candidate(10000), expected: 639 },\n     { actual: candidate(100000), expected: 8026 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage fizz_buzz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strconv\"\n)\n\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz(50)\n// 0\n// >>> fizz_buzz(78)\n// 2\n// >>> fizz_buzz(79)\n// 3\nfunc fizz_buzz(n int) int {\n    count := 0\n    for i := 1; i < n; i++ {\n        if i % 11 == 0 || i % 13 == 0 {\n            count += countSevens(i)\n        }\n    }\n    return count\n}\n\nfunc countSevens(num int) int {\n    count := 0\n    strNum := strconv.Itoa(num)\n    for _, ch := range strNum {\n        if ch == '7' {\n            count++\n        }\n    }\n    return count\n}\n\n// Testing fizz_buzz function\nfunc TestFizzBuzz(t *testing.T) {\n    tests := []struct {\n        input    int\n        expected int\n    }{\n        {50, 0},\n        {78, 2},\n        {79, 3},\n        {100, 4}, // Additional case to validate the function\n    }\n\n    for _, test := range tests {\n        result := fizz_buzz(test.input)\n        if result != test.expected {\n            t.Errorf(\"fizz_buzz(%d) = %d; expected %d\", test.input, result, test.expected)\n        } else {\n            fmt.Printf(\"fizz_buzz(%d) = %d; expected %d\\n\", test.input, result, test.expected)\n        }\n    }\n}\n```", "task_id": "HumanEval_36_fizz_buzz"}
{"name": "HumanEval_37_sort_even", "language": "go_test.go", "prompt": "package sort_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_even([]int{5, 6, 3, 4})\n// []int{3, 6, 5, 4}\nfunc sort_even(l []int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_37_sort_even.py", "prompt_terminology": "reworded", "tests": "func TestSort_Even(t *testing.T) {\n  candidate := sort_even\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3}), expected: []int{1, 2, 3} },\n     { actual: candidate([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}), expected: []int{-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123} },\n     { actual: candidate([]int{5, 8, -12, 4, 23, 2, 3, 11, 12, -10}), expected: []int{-12, 8, 3, 4, 5, 2, 12, 11, 23, -10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage sort_even_test\n\nimport (\n\t\"testing\"\n\t\"sort\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_even([]int{5, 6, 3, 4})\n// []int{3, 6, 5, 4}\nfunc sort_even(l []int) []int {\n\t// Find all even indexed elements\n\tvar evens []int\n\tfor i := 0; i < len(l); i += 2 {\n\t\tevens = append(evens, l[i])\n\t}\n\n\t// Sort the even indexed elements\n\tsort.Ints(evens)\n\n\t// Populate the sorted even indexed elements back to result list\n\tresult := make([]int, len(l))\n\tcopy(result, l)\n\tfor i, j := 0, 0; i < len(result); i += 2 {\n\t\tresult[i] = evens[j]\n\t\tj++\n\t}\n\n\treturn result\n}\n\nfunc TestSortEven(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected []int\n\t}{\n\t\t{[]int{1, 2, 3}, []int{1, 2, 3}},\n\t\t{[]int{5, 6, 3, 4}, []int{3, 6, 5, 4}},\n\t\t{[]int{8, 7, 5, 6, 3, 9, 2}, []int{2, 7, 3, 6, 5, 9, 8}},\n\t\t{[]int{4, 5, 2, 3, 8, 9}, []int{2, 5, 4, 3, 8, 9}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := sort_even(test.input)\n\t\tif !equal(result, test.expected) {\n\t\t\tt.Errorf(\"sort_even(%v) = %v; want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\n// Helper function to check equality of two slices\nfunc equal(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n```", "task_id": "HumanEval_37_sort_even"}
{"name": "HumanEval_39_prime_fib", "language": "go_test.go", "prompt": "package prime_fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib(1)\n// 2\n// >>> prime_fib(2)\n// 3\n// >>> prime_fib(3)\n// 5\n// >>> prime_fib(4)\n// 13\n// >>> prime_fib(5)\n// 89\nfunc prime_fib(n int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_39_prime_fib.py", "prompt_terminology": "reworded", "tests": "func TestPrime_Fib(t *testing.T) {\n  candidate := prime_fib\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: 2 },\n     { actual: candidate(2), expected: 3 },\n     { actual: candidate(3), expected: 5 },\n     { actual: candidate(4), expected: 13 },\n     { actual: candidate(5), expected: 89 },\n     { actual: candidate(6), expected: 233 },\n     { actual: candidate(7), expected: 1597 },\n     { actual: candidate(8), expected: 28657 },\n     { actual: candidate(9), expected: 514229 },\n     { actual: candidate(10), expected: 433494437 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage prime_fib_test\n\nimport (\n\t\"testing\"\n\t\"math/big\"\n)\n\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib(1)\n// 2\n// >>> prime_fib(2)\n// 3\n// >>> prime_fib(3)\n// 5\n// >>> prime_fib(4)\n// 13\n// >>> prime_fib(5)\n// 89\nfunc prime_fib(n int) int {\n    count := 0\n    fibPrev, fibCurr := 0, 1\n    \n    for {\n        fibPrev, fibCurr = fibCurr, fibPrev + fibCurr\n        \n        if big.NewInt(int64(fibCurr)).ProbablyPrime(0) {\n            count++\n            if count == n {\n                return fibCurr\n            }\n        }\n    }\n}\n\nfunc TestPrimeFib(t *testing.T) {\n    tests := []struct {\n        input    int\n        expected int\n    }{\n        {1, 2},\n        {2, 3},\n        {3, 5},\n        {4, 13},\n        {5, 89},\n    }\n    \n    for _, test := range tests {\n        result := prime_fib(test.input)\n        if result != test.expected {\n            t.Errorf(\"Expected %d for input %d, but got %d\", test.expected, test.input, result)\n        }\n    }\n}\n\nfunc ExamplePrimeFib() {\n    fmt.Println(prime_fib(1)) // Output: 2\n    fmt.Println(prime_fib(2)) // Output: 3\n    fmt.Println(prime_fib(3)) // Output: 5\n    fmt.Println(prime_fib(4)) // Output: 13\n    fmt.Println(prime_fib(5)) // Output: 89\n}\n```", "task_id": "HumanEval_39_prime_fib"}
{"name": "HumanEval_40_triples_sum_to_zero", "language": "go_test.go", "prompt": "package triples_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// triples_sum_to_zero takes a list of integers as an input.\n// it returns true if there are three distinct elements in the list that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero([]int{1, 3, 5, 0})\n// false\n// >>> triples_sum_to_zero([]int{1, 3, -2, 1})\n// true\n// >>> triples_sum_to_zero([]int{1, 2, 3, 7})\n// false\n// >>> triples_sum_to_zero([]int{2, 4, -5, 3, 9, 7})\n// true\n// >>> triples_sum_to_zero([]int{1})\n// false\nfunc triples_sum_to_zero(l []int) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_40_triples_sum_to_zero.py", "prompt_terminology": "reworded", "tests": "func TestTriples_Sum_To_Zero(t *testing.T) {\n  candidate := triples_sum_to_zero\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 5, 0}), expected: false },\n     { actual: candidate([]int{1, 3, 5, -1}), expected: false },\n     { actual: candidate([]int{1, 3, -2, 1}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 7}), expected: false },\n     { actual: candidate([]int{1, 2, 5, 7}), expected: false },\n     { actual: candidate([]int{2, 4, -5, 3, 9, 7}), expected: true },\n     { actual: candidate([]int{1}), expected: false },\n     { actual: candidate([]int{1, 3, 5, -100}), expected: false },\n     { actual: candidate([]int{100, 3, 5, -100}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage triples_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"sort\"\n)\n\n// triples_sum_to_zero takes a list of integers as an input.\n// it returns true if there are three distinct elements in the list that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero([]int{1, 3, 5, 0})\n// false\n// >>> triples_sum_to_zero([]int{1, 3, -2, 1})\n// true\n// >>> triples_sum_to_zero([]int{1, 2, 3, 7})\n// false\n// >>> triples_sum_to_zero([]int{2, 4, -5, 3, 9, 7})\n// true\n// >>> triples_sum_to_zero([]int{1})\n// false\nfunc triples_sum_to_zero(l []int) bool {\n    n := len(l)\n    if n < 3 {\n        return false\n    }\n\n    sort.Ints(l)\n\n    for i := 0; i < n-2; i++ {\n        if i > 0 && l[i] == l[i-1] {\n            continue\n        }\n        left, right := i+1, n-1\n        for left < right {\n            sum := l[i] + l[left] + l[right]\n            if sum == 0 {\n                return true\n            } else if sum < 0 {\n                left++\n            } else {\n                right--\n            }\n        }\n    }\n    return false\n}\n\nfunc TestTriplesSumToZero(t *testing.T) {\n    cases := []struct {\n        input    []int\n        expected bool\n    }{\n        {[]int{1, 3, 5, 0}, false},\n        {[]int{1, 3, -2, 1}, true},\n        {[]int{1, 2, 3, 7}, false},\n        {[]int{2, 4, -5, 3, 9, 7}, true},\n        {[]int{1}, false},\n    }\n\n    for _, c := range cases {\n        result := triples_sum_to_zero(c.input)\n        if result != c.expected {\n            t.Errorf(\"triples_sum_to_zero(%v) == %v, expected %v\", c.input, result, c.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(triples_sum_to_zero([]int{1, 3, 5, 0}))\n    fmt.Println(triples_sum_to_zero([]int{1, 3, -2, 1}))\n    fmt.Println(triples_sum_to_zero([]int{1, 2, 3, 7}))\n    fmt.Println(triples_sum_to_zero([]int{2, 4, -5, 3, 9, 7}))\n    fmt.Println(triples_sum_to_zero([]int{1}))\n}\n```\nThe code implements the function `triples_sum_to_zero` that returns `true` if there are three distinct elements in the list that sum to zero, and `false` otherwise. Additionally, it contains a test function `TestTriplesSumToZero` to verify the correctness of the function using a set of test cases. The `main` function prints the results of some test cases to the console.", "task_id": "HumanEval_40_triples_sum_to_zero"}
{"name": "HumanEval_41_car_race_collision", "language": "go_test.go", "prompt": "package car_race_collision_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nfunc car_race_collision(n int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_41_car_race_collision.py", "prompt_terminology": "reworded", "tests": "func TestCar_Race_Collision(t *testing.T) {\n  candidate := car_race_collision\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: 4 },\n     { actual: candidate(3), expected: 9 },\n     { actual: candidate(4), expected: 16 },\n     { actual: candidate(8), expected: 64 },\n     { actual: candidate(10), expected: 100 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage car_race_collision_test\n\nimport (\n    \"fmt\"\n    \"testing\"\n)\n\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nfunc car_race_collision(n int) int {\n    return n\n}\n\nfunc TestCarRaceCollision(t *testing.T) {\n    tests := []struct {\n        n     int\n        want  int\n    }{\n        {1, 1},\n        {2, 2},\n        {3, 3},\n        {10, 10},\n        {100, 100},\n    }\n\n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"n=%d\", tt.n), func(t *testing.T) {\n            got := car_race_collision(tt.n)\n            if got != tt.want {\n                t.Errorf(\"got %d, want %d\", got, tt.want)\n            }\n        })\n    }\n}\n```\n\nExplanation:\n- The `car_race_collision` function assumes that each car traveling left to right will definitely collide with a car traveling right to left, hence the number of collisions is directly `n`.\n- The `TestCarRaceCollision` function tests various values of `n` to ensure that the `car_race_collision` function is working as expected.\n", "task_id": "HumanEval_41_car_race_collision"}
{"name": "HumanEval_42_incr_list", "language": "go_test.go", "prompt": "package incr_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list with elements incremented by 1.\n// >>> incr_list([]int{1, 2, 3})\n// []int{2, 3, 4}\n// >>> incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n// []int{6, 4, 6, 3, 4, 4, 10, 1, 124}\nfunc incr_list(l []int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_42_incr_list.py", "prompt_terminology": "reworded", "tests": "func TestIncr_List(t *testing.T) {\n  candidate := incr_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{3, 2, 1}), expected: []int{4, 3, 2} },\n     { actual: candidate([]int{5, 2, 5, 2, 3, 3, 9, 0, 123}), expected: []int{6, 3, 6, 3, 4, 4, 10, 1, 124} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage incr_list_test\n\nimport (\n    \"fmt\"\n    \"testing\"\n)\n\n// Return list with elements incremented by 1.\n// >>> incr_list([]int{1, 2, 3})\n// []int{2, 3, 4}\n// >>> incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n// []int{6, 4, 6, 3, 4, 4, 10, 1, 124}\nfunc incr_list(l []int) []int {\n    for i := range l {\n        l[i]++\n    }\n    return l\n}\n\nfunc TestIncrList(t *testing.T) {\n    tests := []struct {\n        input    []int\n        expected []int\n    }{\n        {[]int{1, 2, 3}, []int{2, 3, 4}},\n        {[]int{5, 3, 5, 2, 3, 3, 9, 0, 123}, []int{6, 4, 6, 3, 4, 4, 10, 1, 124}},\n    }\n\n    for _, test := range tests {\n        result := incr_list(test.input)\n        for i := range result {\n            if result[i] != test.expected[i] {\n                t.Errorf(\"For input %v, expected %v, but got %v\", test.input, test.expected, result)\n                break\n            }\n        }\n    }\n}\n\nfunc main() {\n    test := testing.T{}\n    TestIncrList(&test)\n    fmt.Println(\"All tests passed!\")\n}\n```\n\nThis code includes the `incr_list` function that increments each element in the list by one. It also includes a test function `TestIncrList` to validate the accuracy of the `incr_list` function against a set of test cases.", "task_id": "HumanEval_42_incr_list"}
{"name": "HumanEval_43_pairs_sum_to_zero", "language": "go_test.go", "prompt": "package pairs_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// pairs_sum_to_zero takes a list of integers as an input.\n// it returns true if there are two distinct elements in the list that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero([]int{1, 3, 5, 0})\n// false\n// >>> pairs_sum_to_zero([]int{1, 3, -2, 1})\n// false\n// >>> pairs_sum_to_zero([]int{1, 2, 3, 7})\n// false\n// >>> pairs_sum_to_zero([]int{2, 4, -5, 3, 5, 7})\n// true\n// >>> pairs_sum_to_zero([]int{1})\n// false\nfunc pairs_sum_to_zero(l []int) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_43_pairs_sum_to_zero.py", "prompt_terminology": "reworded", "tests": "func TestPairs_Sum_To_Zero(t *testing.T) {\n  candidate := pairs_sum_to_zero\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 5, 0}), expected: false },\n     { actual: candidate([]int{1, 3, -2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 7}), expected: false },\n     { actual: candidate([]int{2, 4, -5, 3, 5, 7}), expected: true },\n     { actual: candidate([]int{1}), expected: false },\n     { actual: candidate([]int{-3, 9, -1, 3, 2, 30}), expected: true },\n     { actual: candidate([]int{-3, 9, -1, 3, 2, 31}), expected: true },\n     { actual: candidate([]int{-3, 9, -1, 4, 2, 30}), expected: false },\n     { actual: candidate([]int{-3, 9, -1, 4, 2, 31}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage pairs_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// pairs_sum_to_zero takes a list of integers as an input.\n// it returns true if there are two distinct elements in the list that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero([]int{1, 3, 5, 0})\n// false\n// >>> pairs_sum_to_zero([]int{1, 3, -2, 1})\n// false\n// >>> pairs_sum_to_zero([]int{1, 2, 3, 7})\n// false\n// >>> pairs_sum_to_zero([]int{2, 4, -5, 3, 5, 7})\n// true\n// >>> pairs_sum_to_zero([]int{1})\n// false\nfunc pairs_sum_to_zero(l []int) bool {\n    seen := make(map[int]bool)\n    for _, num := range l {\n        if seen[-num] {\n            return true\n        }\n        seen[num] = true\n    }\n    return false\n}\n\n// Test function for the pairs_sum_to_zero implementation\nfunc TestPairsSumToZero(t *testing.T) {\n    testCases := []struct {\n        input    []int\n        expected bool\n    }{\n        {[]int{1, 3, 5, 0}, false},\n        {[]int{1, 3, -2, 1}, false},\n        {[]int{1, 2, 3, 7}, false},\n        {[]int{2, 4, -5, 3, 5, 7}, true},\n        {[]int{1}, false},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"input=%v\", tc.input), func(t *testing.T) {\n            actual := pairs_sum_to_zero(tc.input)\n            if actual != tc.expected {\n                t.Errorf(\"expected %v, but got %v\", tc.expected, actual)\n            }\n        })\n    }\n}\n```\n\nTo complete the `pairs_sum_to_zero` function, I used a map to keep track of the numbers we have seen so far. For each number in the input list, we check if its negation exists in the map (indicating a pair that sums to zero). If it does, return true. If not, add the current number to the map and proceed. Finally, if no pairs are found, return false.\n\nAdditionally, I included tests for various cases to ensure the function behaves as expected.", "task_id": "HumanEval_43_pairs_sum_to_zero"}
{"name": "HumanEval_44_change_base", "language": "go_test.go", "prompt": "package change_base_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base(8, 3)\n// \"22\"\n// >>> change_base(8, 2)\n// \"1000\"\n// >>> change_base(7, 2)\n// \"111\"\nfunc change_base(x int, base int) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_44_change_base.py", "prompt_terminology": "reworded", "tests": "func TestChange_Base(t *testing.T) {\n  candidate := change_base\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(8, 3), expected: \"22\" },\n     { actual: candidate(9, 3), expected: \"100\" },\n     { actual: candidate(234, 2), expected: \"11101010\" },\n     { actual: candidate(16, 2), expected: \"10000\" },\n     { actual: candidate(8, 2), expected: \"1000\" },\n     { actual: candidate(7, 2), expected: \"111\" },\n     { actual: candidate(2, 3), expected: \"2\" },\n     { actual: candidate(3, 4), expected: \"3\" },\n     { actual: candidate(4, 5), expected: \"4\" },\n     { actual: candidate(5, 6), expected: \"5\" },\n     { actual: candidate(6, 7), expected: \"6\" },\n     { actual: candidate(7, 8), expected: \"7\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage change_base_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strconv\"\n)\n\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base(8, 3)\n// \"22\"\n// >>> change_base(8, 2)\n// \"1000\"\n// >>> change_base(7, 2)\n// \"111\"\nfunc change_base(x int, base int) string {\n    if base < 2 || base > 9 {\n        return \"Unsupported base\"\n    }\n    \n    result := \"\"\n    for x > 0 {\n        remainder := x % base\n        result = strconv.Itoa(remainder) + result\n        x = x / base\n    }\n    \n    if result == \"\" {\n        return \"0\"\n    }\n    \n    return result\n}\n\nfunc TestChangeBase(t *testing.T) {\n    testCases := []struct {\n        x        int\n        base     int\n        expected string\n    }{\n        {8, 3, \"22\"},\n        {8, 2, \"1000\"},\n        {7, 2, \"111\"},\n        {0, 2, \"0\"},\n        {5, 5, \"10\"},\n        {10, 10, \"10\"},\n    }\n    \n    for _, tc := range testCases {\n        result := change_base(tc.x, tc.base)\n        if result != tc.expected {\n            t.Errorf(\"change_base(%d, %d) = %s; expected %s\", tc.x, tc.base, result, tc.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(change_base(8, 3))  // should print \"22\"\n    fmt.Println(change_base(8, 2))  // should print \"1000\"\n    fmt.Println(change_base(7, 2))  // should print \"111\"\n}\n```", "task_id": "HumanEval_44_change_base"}
{"name": "HumanEval_45_triangle_area", "language": "go_test.go", "prompt": "package triangle_area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area(5, 3)\n// 7.5\nfunc triangle_area(a int, h int) float64 {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_45_triangle_area.py", "prompt_terminology": "reworded", "tests": "func TestTriangle_Area(t *testing.T) {\n  candidate := triangle_area\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 3), expected: 7.5 },\n     { actual: candidate(2, 2), expected: 2.0 },\n     { actual: candidate(10, 8), expected: 40.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage triangle_area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given length of a side and height return area for a triangle.\n// >>> triangle_area(5, 3)\n// 7.5\nfunc triangle_area(a int, h int) float64 {\n    return 0.5 * float64(a) * float64(h)\n}\n\nfunc TestTriangleArea(t *testing.T) {\n    result := triangle_area(5, 3)\n    expected := 7.5\n    if result != expected {\n        t.Errorf(\"Expected %.1f, but got %.1f\", expected, result)\n    }\n}\n\nfunc ExampleTriangleArea() {\n    result := triangle_area(5, 3)\n    fmt.Println(result)\n    // Output: 7.5\n}\n```", "task_id": "HumanEval_45_triangle_area"}
{"name": "HumanEval_46_fib4", "language": "go_test.go", "prompt": "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n// >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_46_fib4.py", "prompt_terminology": "reworded", "tests": "func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence. Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n// >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n        return 2\n    } else if n == 3 {\n        return 0\n    }\n\n    a, b, c, d := 0, 0, 2, 0\n\n    for i := 4; i <= n; i++ {\n        next := a + b + c + d\n        a, b, c, d = b, c, d, next\n    }\n\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n    var tests = []struct {\n        input    int\n        expected int\n    }{\n        {0, 0},\n        {1, 0},\n        {2, 2},\n        {3, 0},\n        {4, 2},\n        {5, 4},\n        {6, 8},\n        {7, 14},\n        {8, 28},\n        {9, 54},\n        {10, 104},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"fib4(%d)\", test.input), func(t *testing.T) {\n            if got := fib4(test.input); got != test.expected {\n                t.Errorf(\"fib4(%d) = %d; want %d\", test.input, got, test.expected)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_46_fib4"}
{"name": "HumanEval_47_median", "language": "go_test.go", "prompt": "package median_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return median of elements in the list l.\n// >>> median([]int{3, 1, 2, 4, 5})\n// 3\n// >>> median([]int{-10, 4, 6, 1000, 10, 20})\n// 15.0\nfunc median(l []int) float64 {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_47_median.py", "prompt_terminology": "reworded", "tests": "func TestMedian(t *testing.T) {\n  candidate := median\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 1, 2, 4, 5}), expected: 3 },\n     { actual: candidate([]int{-10, 4, 6, 1000, 10, 20}), expected: 8.0 },\n     { actual: candidate([]int{5}), expected: 5 },\n     { actual: candidate([]int{6, 5}), expected: 5.5 },\n     { actual: candidate([]int{8, 1, 3, 9, 9, 2, 7}), expected: 7 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage median_test\n\nimport (\n    \"sort\"\n    \"testing\"\n    \"fmt\"\n)\n\n// Return median of elements in the list l.\n// >>> median([]int{3, 1, 2, 4, 5})\n// 3\n// >>> median([]int{-10, 4, 6, 1000, 10, 20})\n// 15.0\nfunc median(l []int) float64 {\n    sort.Ints(l)\n\n    n := len(l)\n    if n%2 == 1 {\n        return float64(l[n/2])\n    }\n    return float64(l[n/2-1]+l[n/2]) / 2.0\n}\n\nfunc TestMedian(t *testing.T) {\n    testCases := []struct {\n        input  []int\n        output float64\n    }{\n        {[]int{3, 1, 2, 4, 5}, 3},\n        {[]int{-10, 4, 6, 1000, 10, 20}, 15},\n        {[]int{7, 3, 5, 1}, 4},\n        {[]int{8, 3}, 5.5},\n        {[]int{42}, 42},\n    }\n\n    for _, tc := range testCases {\n        result := median(tc.input)\n        if result != tc.output {\n            t.Errorf(\"median(%v) = %v; expected %v\", tc.input, result, tc.output)\n        }\n    }\n}\n\nfunc main() {\n    // Running the tests\n    fmt.Println(\"Running tests:\")\n    TestMedian(nil)\n}\n```", "task_id": "HumanEval_47_median"}
{"name": "HumanEval_48_is_palindrome", "language": "go_test.go", "prompt": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\n// >>> is_palindrome(\"\")\n// true\n// >>> is_palindrome(\"aba\")\n// true\n// >>> is_palindrome(\"aaaaa\")\n// true\n// >>> is_palindrome(\"zbcd\")\n// false\nfunc is_palindrome(text string) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_48_is_palindrome.py", "prompt_terminology": "reworded", "tests": "func TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\n// >>> is_palindrome(\"\")\n// true\n// >>> is_palindrome(\"aba\")\n// true\n// >>> is_palindrome(\"aaaaa\")\n// true\n// >>> is_palindrome(\"zbcd\")\n// false\nfunc is_palindrome(text string) bool {\n    n := len(text)\n    for i := 0; i < n/2; i++ {\n        if text[i] != text[n-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIsPalindrome(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected bool\n    }{\n        {\"\", true},\n        {\"aba\", true},\n        {\"aaaaa\", true},\n        {\"zbcd\", false},\n        {\"a\", true},\n        {\"ab\", false},\n        {\"abcba\", true},\n        {\"abccba\", true},\n        {\"abcdefg\", false},\n    }\n\n    for _, test := range tests {\n        result := is_palindrome(test.input)\n        if result != test.expected {\n            t.Errorf(\"is_palindrome(%q) = %v; expected %v\", test.input, result, test.expected)\n        }\n    }\n}\n\nfunc main() {\n    result1 := is_palindrome(\"\")\n    fmt.Println(\"is_palindrome(\\\"\\\") =\", result1) // true\n\n    result2 := is_palindrome(\"aba\")\n    fmt.Println(\"is_palindrome(\\\"aba\\\") =\", result2) // true\n\n    result3 := is_palindrome(\"aaaaa\")\n    fmt.Println(\"is_palindrome(\\\"aaaaa\\\") =\", result3) // true\n\n    result4 := is_palindrome(\"zbcd\")\n    fmt.Println(\"is_palindrome(\\\"zbcd\\\") =\", result4) // false\n}\n```", "task_id": "HumanEval_48_is_palindrome"}
{"name": "HumanEval_49_modp", "language": "go_test.go", "prompt": "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n// 1\nfunc modp(n int, p int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_49_modp.py", "prompt_terminology": "reworded", "tests": "func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n// 1\nfunc modp(n int, p int) int {\n    if p == 1 {\n        return 0\n    }\n    res := 1\n    base := 2 % p\n    for n > 0 {\n        if n % 2 == 1 {\n            res = (res * base) % p\n        }\n        n = n / 2\n        base = (base * base) % p\n    }\n    return res\n}\n\nfunc TestModp(t *testing.T) {\n    testCases := []struct {\n        n        int\n        p        int\n        expected int\n    }{\n        {3, 5, 3},\n        {1101, 101, 2},\n        {0, 101, 1},\n        {3, 11, 8},\n        {100, 101, 1},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"modp(%d, %d)\", tc.n, tc.p), func(t *testing.T) {\n            result := modp(tc.n, tc.p)\n            if result != tc.expected {\n                t.Fatalf(\"expected %d, got %d\", tc.expected, result)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_49_modp"}
{"name": "HumanEval_51_remove_vowels", "language": "go_test.go", "prompt": "package remove_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels(\"\")\n// \"\"\n// >>> remove_vowels(\"abcdef\")\n// \"bcdf\"\n// >>> remove_vowels(\"aaaaa\")\n// \"\"\n// >>> remove_vowels(\"aaBAA\")\n// \"B\"\n// >>> remove_vowels(\"zbcd\")\n// \"zbcd\"\nfunc remove_vowels(text string) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_51_remove_vowels.py", "prompt_terminology": "reworded", "tests": "func TestRemove_Vowels(t *testing.T) {\n  candidate := remove_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"abcdef\\nghijklm\"), expected: \"bcdf\\nghjklm\" },\n     { actual: candidate(\"fedcba\"), expected: \"fdcb\" },\n     { actual: candidate(\"eeeee\"), expected: \"\" },\n     { actual: candidate(\"acBAA\"), expected: \"cB\" },\n     { actual: candidate(\"EcBOO\"), expected: \"cB\" },\n     { actual: candidate(\"ybcd\"), expected: \"ybcd\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage remove_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels(\"\")\n// \"\"\n// >>> remove_vowels(\"abcdef\")\n// \"bcdf\"\n// >>> remove_vowels(\"aaaaa\")\n// \"\"\n// >>> remove_vowels(\"aaBAA\")\n// \"B\"\n// >>> remove_vowels(\"zbcd\")\n// \"zbcd\"\nfunc remove_vowels(text string) string {\n    vowels := \"aeiouAEIOU\"\n    var result strings.Builder\n    for _, ch := range text {\n        if !strings.ContainsRune(vowels, ch) {\n            result.WriteRune(ch)\n        }\n    }\n    return result.String()\n}\n\nfunc TestRemoveVowels(t *testing.T) {\n    cases := []struct {\n        input, expected string\n    }{\n        {\"\", \"\"},\n        {\"abcdef\", \"bcdf\"},\n        {\"aaaaa\", \"\"},\n        {\"aaBAA\", \"B\"},\n        {\"zbcd\", \"zbcd\"},\n    }\n    \n    for _, c := range cases {\n        t.Run(fmt.Sprintf(\"remove_vowels(%q)\", c.input), func(t *testing.T) {\n            got := remove_vowels(c.input)\n            if got != c.expected {\n                t.Errorf(\"remove_vowels(%q) == %q; want %q\", c.input, got, c.expected)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_51_remove_vowels"}
{"name": "HumanEval_52_below_threshold", "language": "go_test.go", "prompt": "package below_threshold_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return true if all numbers in the list l are below threshold t.\n// >>> below_threshold([]int{1, 2, 4, 10}, 100)\n// true\n// >>> below_threshold([]int{1, 20, 4, 10}, 5)\n// false\nfunc below_threshold(l []int, t int) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_52_below_threshold.py", "prompt_terminology": "reworded", "tests": "func TestBelow_Threshold(t *testing.T) {\n  candidate := below_threshold\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}, 100), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}, 5), expected: false },\n     { actual: candidate([]int{1, 20, 4, 10}, 21), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}, 22), expected: true },\n     { actual: candidate([]int{1, 8, 4, 10}, 11), expected: true },\n     { actual: candidate([]int{1, 8, 4, 10}, 10), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage below_threshold_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return true if all numbers in the list l are below threshold t.\n// >>> below_threshold([]int{1, 2, 4, 10}, 100)\n// true\n// >>> below_threshold([]int{1, 20, 4, 10}, 5)\n// false\nfunc below_threshold(l []int, t int) bool {\n    for _, value := range l {\n        if value >= t {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestBelowThreshold(t *testing.T) {\n    cases := []struct {\n        input    []int\n        threshold int\n        expected bool\n    }{\n        {[]int{1, 2, 4, 10}, 100, true},\n        {[]int{1, 20, 4, 10}, 5, false},\n        {[]int{1, 2, 3, 4}, 5, true},\n        {[]int{5, 6, 7, 8}, 5, false},\n    }\n\n    for _, c := range cases {\n        result := below_threshold(c.input, c.threshold)\n        if result != c.expected {\n            t.Errorf(\"below_threshold(%v, %d) == %v, expected %v\", c.input, c.threshold, result, c.expected)\n        }\n    }\n}\n\nfunc main() {\n    testResults := testing.T{}\n    TestBelowThreshold(&testResults)\n    fmt.Println(\"All tests passed!\")\n}\n```", "task_id": "HumanEval_52_below_threshold"}
{"name": "HumanEval_53_add", "language": "go_test.go", "prompt": "package add_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Add two numbers x and y\n// >>> add(2, 3)\n// 5\n// >>> add(5, 7)\n// 12\nfunc add(x int, y int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_53_add.py", "prompt_terminology": "reworded", "tests": "func TestAdd(t *testing.T) {\n  candidate := add\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0, 1), expected: 1 },\n     { actual: candidate(1, 0), expected: 1 },\n     { actual: candidate(2, 3), expected: 5 },\n     { actual: candidate(5, 7), expected: 12 },\n     { actual: candidate(7, 5), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage add_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Add two numbers x and y\n// >>> add(2, 3)\n// 5\n// >>> add(5, 7)\n// 12\nfunc add(x int, y int) int {\n    return x + y\n}\n\nfunc TestAdd(t *testing.T) {\n    var tests = []struct {\n        x, y, expected int\n    }{\n        {2, 3, 5},\n        {5, 7, 12},\n    }\n\n    for _, tt := range tests {\n        testname := fmt.Sprintf(\"%d+%d\", tt.x, tt.y)\n        t.Run(testname, func(t *testing.T) {\n            ans := add(tt.x, tt.y)\n            if ans != tt.expected {\n                t.Errorf(\"got %d, want %d\", ans, tt.expected)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_53_add"}
{"name": "HumanEval_54_same_chars", "language": "go_test.go", "prompt": "package same_chars_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Check if two words have the same characters.\n// >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n// true\n// >>> same_chars(\"abcd\", \"dddddddabc\")\n// true\n// >>> same_chars(\"dddddddabc\", \"abcd\")\n// true\n// >>> same_chars(\"eabcd\", \"dddddddabc\")\n// false\n// >>> same_chars(\"abcd\", \"dddddddabce\")\n// false\n// >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n// false\nfunc same_chars(s0 string, s1 string) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_54_same_chars.py", "prompt_terminology": "reworded", "tests": "func TestSame_Chars(t *testing.T) {\n  candidate := same_chars\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"), expected: true },\n     { actual: candidate(\"abcd\", \"dddddddabc\"), expected: true },\n     { actual: candidate(\"dddddddabc\", \"abcd\"), expected: true },\n     { actual: candidate(\"eabcd\", \"dddddddabc\"), expected: false },\n     { actual: candidate(\"abcd\", \"dddddddabcf\"), expected: false },\n     { actual: candidate(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"), expected: false },\n     { actual: candidate(\"aabb\", \"aaccc\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage same_chars_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc same_chars(s0 string, s1 string) bool {\n\tcharCount := make(map[rune]int)\n\n\tfor _, char := range s0 {\n\t\tcharCount[char]++\n\t}\n\n\tfor _, char := range s1 {\n\t\tif charCount[char] > 0 {\n\t\t\tcharCount[char]--\n\t\t}\n\t}\n\n\tfor _, count := range charCount {\n\t\tif count > 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc TestSameChars(t *testing.T) {\n\ttests := []struct {\n\t\ts0, s1 string\n\t\twant   bool\n\t}{\n\t\t{\"eabcdzzzz\", \"dddzzzzzzzddeddabc\", true},\n\t\t{\"abcd\", \"dddddddabc\", true},\n\t\t{\"dddddddabc\", \"abcd\", true},\n\t\t{\"eabcd\", \"dddddddabc\", false},\n\t\t{\"abcd\", \"dddddddabce\", false},\n\t\t{\"eabcdzzzz\", \"dddzzzzzzzddddabc\", false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"%s_%s\", tt.s0, tt.s1), func(t *testing.T) {\n\t\t\tif got := same_chars(tt.s0, tt.s1); got != tt.want {\n\t\t\t\tt.Errorf(\"same_chars(%q, %q) = %v, want %v\", tt.s0, tt.s1, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n```", "task_id": "HumanEval_54_same_chars"}
{"name": "HumanEval_55_fib", "language": "go_test.go", "prompt": "package fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return n-th Fibonacci number.\n// >>> fib(10)\n// 55\n// >>> fib(1)\n// 1\n// >>> fib(8)\n// 21\nfunc fib(n int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_55_fib.py", "prompt_terminology": "reworded", "tests": "func TestFib(t *testing.T) {\n  candidate := fib\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10), expected: 55 },\n     { actual: candidate(1), expected: 1 },\n     { actual: candidate(8), expected: 21 },\n     { actual: candidate(11), expected: 89 },\n     { actual: candidate(12), expected: 144 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return n-th Fibonacci number.\n// >>> fib(10)\n// 55\n// >>> fib(1)\n// 1\n// >>> fib(8)\n// 21\nfunc fib(n int) int {\n    if n <= 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n\n    a, b := 0, 1\n    for i := 2; i <= n; i++ {\n        a, b = b, a+b\n    }\n    return b\n}\n\nfunc TestFib(t *testing.T) {\n    cases := []struct {\n        input int\n        want  int\n    }{\n        {10, 55},\n        {1, 1},\n        {8, 21},\n        {0, 0},\n        {5, 5},\n        {15, 610},\n    }\n\n    for _, c := range cases {\n        got := fib(c.input)\n        if got != c.want {\n            t.Errorf(\"fib(%d) == %d, want %d\", c.input, got, c.want)\n        }\n    }\n}\n\nfunc ExampleFib() {\n    fmt.Println(fib(10)) // Output: 55\n    fmt.Println(fib(1)) // Output: 1\n    fmt.Println(fib(8)) // Output: 21\n    // Output:\n    // 55\n    // 1\n    // 21\n}\n```", "task_id": "HumanEval_55_fib"}
{"name": "HumanEval_56_correct_bracketing", "language": "go_test.go", "prompt": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_56_correct_bracketing.py", "prompt_terminology": "reworded", "tests": "func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage correct_bracketing_test\n\nimport (\n\t\"testing\"\n\t\"strings\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n\tbalance := 0\n\tfor _, ch := range brackets {\n\t\tif ch == '<' {\n\t\t\tbalance++\n\t\t} else if ch == '>' {\n\t\t\tbalance--\n\t\t}\n\t\t// if balance is negative, there's a closing bracket without a matching opening bracket\n\t\tif balance < 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\t// return true if all opening brackets are matched\n\treturn balance == 0\n}\n\nfunc TestCorrectBracketing(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\"<\", false},\n\t\t{\"<>\", true},\n\t\t{\"<<><>>\", true},\n\t\t{\"><<>\", false},\n\t\t{\"\", true},      // all balanced brackets\n\t\t{\"<<<<>>>>\", true},\n\t\t{\"<<>>><<\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"correctBracketing(%v)\", test.input), func(t *testing.T) {\n\t\t\tresult := correct_bracketing(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkCorrectBracketing(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tcorrect_bracketing(\"<<><>>><<<><<>><<><>>\")\n\t}\n}\n```", "task_id": "HumanEval_56_correct_bracketing"}
{"name": "HumanEval_57_monotonic", "language": "go_test.go", "prompt": "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return true is list elements are monotonically increasing or decreasing.\n// >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4, 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l []int) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_57_monotonic.py", "prompt_terminology": "reworded", "tests": "func TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage monotonic_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\n// Return true if list elements are monotonically increasing or decreasing.\n// >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4, 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l []int) bool {\n\tif len(l) < 2 {\n\t\treturn true\n\t}\n\n\tincreasing := true\n\tdecreasing := true\n\n\tfor i := 1; i < len(l); i++ {\n\t\tif l[i] > l[i-1] {\n\t\t\tdecreasing = false\n\t\t}\n\t\tif l[i] < l[i-1] {\n\t\t\tincreasing = false\n\t\t}\n\t}\n\n\treturn increasing || decreasing\n}\n\nfunc TestMonotonic(t *testing.T) {\n\ttests := []struct {\n\t\tinput []int\n\t\twant  bool\n\t}{\n\t\t{[]int{1, 2, 4, 20}, true},\n\t\t{[]int{1, 20, 4, 10}, false},\n\t\t{[]int{4, 1, 0, -10}, true},\n\t\t{[]int{5, 5, 5, 5}, true},\n\t\t{[]int{1}, true},\n\t\t{[]int{2, 1}, true},\n\t\t{[]int{3, 4, 2}, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"monotonic(%v)\", test.input), func(t *testing.T) {\n\t\t\tgot := monotonic(test.input)\n\t\t\tif got != test.want {\n\t\t\t\tt.Errorf(\"monotonic(%v) = %v; want %v\", test.input, got, test.want)\n\t\t\t}\n\t\t})\n\t}\n}\n```\n\nThis code defines a function `monotonic` that checks whether a list of integers is monotonically increasing or decreasing, followed by a testing function `TestMonotonic` that uses the `testing` package to assert the correctness of the `monotonic` function using different test cases.", "task_id": "HumanEval_57_monotonic"}
{"name": "HumanEval_58_common", "language": "go_test.go", "prompt": "package common_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return sorted unique common elements for two lists.\n// >>> common([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121})\n// []int{1, 5, 653}\n// >>> common([]int{5, 3, 2, 8}, []int{3, 2})\n// []int{2, 3}\nfunc common(l1 []int, l2 []int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_58_common.py", "prompt_terminology": "reworded", "tests": "func TestCommon(t *testing.T) {\n  candidate := common\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121}), expected: []int{1, 5, 653} },\n     { actual: candidate([]int{5, 3, 2, 8}, []int{3, 2}), expected: []int{2, 3} },\n     { actual: candidate([]int{4, 3, 2, 8}, []int{3, 2, 4}), expected: []int{2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 8}, []int{}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage common_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"sort\"\n)\n\n// Return sorted unique common elements for two lists.\n// >>> common([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121})\n// []int{1, 5, 653}\n// >>> common([]int{5, 3, 2, 8}, []int{3, 2})\n// []int{2, 3}\nfunc common(l1 []int, l2 []int) []int {\n    // Use a map to track the elements in l1\n    elementMap := make(map[int]bool)\n    for _, elem := range l1 {\n        elementMap[elem] = true\n    }\n\n    // Use a set to track common elements\n    commonSet := make(map[int]bool)\n    for _, elem := range l2 {\n        if elementMap[elem] {\n            commonSet[elem] = true\n        }\n    }\n\n    // Convert the set to a slice\n    commonList := make([]int, 0, len(commonSet))\n    for elem := range commonSet {\n        commonList = append(commonList, elem)\n    }\n\n    // Sort the slice\n    sort.Ints(commonList)\n\n    return commonList\n}\n\nfunc TestCommon(t *testing.T) {\n    testCases := []struct {\n        l1       []int\n        l2       []int\n        expected []int\n    }{\n        {[]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121}, []int{1, 5, 653}},\n        {[]int{5, 3, 2, 8}, []int{3, 2}, []int{2, 3}},\n        {[]int{1, 2, 3}, []int{4, 5, 6}, []int{}},\n        {[]int{1, 1, 1}, []int{1, 1, 1}, []int{1}},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"common(%v, %v)\", tc.l1, tc.l2), func(t *testing.T) {\n            result := common(tc.l1, tc.l2)\n            if !equal(result, tc.expected) {\n                t.Errorf(\"expected %v; got %v\", tc.expected, result)\n            }\n        })\n    }\n}\n\n// Helper function to check equality of two slices\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n```\nThis code defines the `common` function to find the sorted unique common elements of two integer slices and includes test cases to validate its correctness.", "task_id": "HumanEval_58_common"}
{"name": "HumanEval_59_largest_prime_factor", "language": "go_test.go", "prompt": "package largest_prime_factor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n// 29\n// >>> largest_prime_factor(2048)\n// 2\nfunc largest_prime_factor(n int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_59_largest_prime_factor.py", "prompt_terminology": "reworded", "tests": "func TestLargest_Prime_Factor(t *testing.T) {\n  candidate := largest_prime_factor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(15), expected: 5 },\n     { actual: candidate(27), expected: 3 },\n     { actual: candidate(63), expected: 7 },\n     { actual: candidate(330), expected: 11 },\n     { actual: candidate(13195), expected: 29 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage largest_prime_factor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n// 29\n// >>> largest_prime_factor(2048)\n// 2\nfunc largest_prime_factor(n int) int {\n    largestFactor := 1\n    // Check divisibility by 2 first to handle even numbers\n    for n % 2 == 0 {\n        largestFactor = 2\n        n = n / 2\n    }\n\n    // Check for all odd factors\n    for i := 3; i*i <= n; i += 2 {\n        for n % i == 0 {\n            largestFactor = i\n            n = n / i\n        }\n    }\n\n    // If n is still greater than 2, then n itself is a prime factor\n    if n > 2 {\n        largestFactor = n\n    }\n\n    return largestFactor\n}\n\nfunc TestLargestPrimeFactor(t *testing.T) {\n    tests := []struct{\n        input int\n        expected int\n    }{\n        {13195, 29},\n        {2048, 2},\n        {49, 7},\n        {77, 11},\n    }\n\n    for _, test := range tests {\n        result := largest_prime_factor(test.input)\n        if result != test.expected {\n            t.Errorf(\"largest_prime_factor(%d) = %d; expected %d\", test.input, result, test.expected)\n        }\n    }\n}\n\n// Example usage and main function to run the tests\nfunc main() {\n    fmt.Println(\"Largest prime factor of 13195:\", largest_prime_factor(13195))\n    fmt.Println(\"Largest prime factor of 2048:\", largest_prime_factor(2048))\n}\n```\n\nThis code implements the `largest_prime_factor` function which calculates the largest prime factor of a given integer `n`. It also includes a set of tests to validate this function using the standard testing package in Go.", "task_id": "HumanEval_59_largest_prime_factor"}
{"name": "HumanEval_60_sum_to_n", "language": "go_test.go", "prompt": "package sum_to_n_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n(30)\n// 465\n// >>> sum_to_n(100)\n// 5050\n// >>> sum_to_n(5)\n// 15\n// >>> sum_to_n(10)\n// 55\n// >>> sum_to_n(1)\n// 1\nfunc sum_to_n(n int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_60_sum_to_n.py", "prompt_terminology": "reworded", "tests": "func TestSum_To_N(t *testing.T) {\n  candidate := sum_to_n\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: 1 },\n     { actual: candidate(6), expected: 21 },\n     { actual: candidate(11), expected: 66 },\n     { actual: candidate(30), expected: 465 },\n     { actual: candidate(100), expected: 5050 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage sum_to_n_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n(30)\n// 465\n// >>> sum_to_n(100)\n// 5050\n// >>> sum_to_n(5)\n// 15\n// >>> sum_to_n(10)\n// 55\n// >>> sum_to_n(1)\n// 1\nfunc sum_to_n(n int) int {\n\tsum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tsum += i\n\t}\n\treturn sum\n}\n\nfunc TestSumToN(t *testing.T) {\n    testCases := []struct {\n        input    int\n        expected int\n    }{\n        {30, 465},\n        {100, 5050},\n        {5, 15},\n        {10, 55},\n        {1, 1},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"sum_to_n(%d)\", tc.input), func(t *testing.T) {\n            result := sum_to_n(tc.input)\n            if result != tc.expected {\n                t.Errorf(\"Expected %d, got %d\", tc.expected, result)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_60_sum_to_n"}
{"name": "HumanEval_61_correct_bracketing", "language": "go_test.go", "prompt": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"(()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets string) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_61_correct_bracketing.py", "prompt_terminology": "reworded", "tests": "func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"(()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    balance := 0\n    for _, ch := range brackets {\n        if ch == '(' {\n            balance++\n        } else if ch == ')' {\n            balance--\n        }\n        if balance < 0 { // There are more closing brackets than opening ones\n            return false\n        }\n    }\n    return balance == 0 // There should be equal number of opening and closing brackets\n}\n\n// Test cases to verify the correct functionality of correct_bracketing function\nfunc TestCorrectBracketing(t *testing.T) {\n    testCases := []struct {\n        input    string\n        expected bool\n    }{\n        {\"(\", false},\n        {\"()\", true},\n        {\"(()())\", true},\n        {\")(()\", false},\n        {\"((()))\", true},\n        {\"())(\", false},\n        {\"\", true},\n    }\n\n    for _, testCase := range testCases {\n        result := correct_bracketing(testCase.input)\n        if result != testCase.expected {\n            t.Errorf(\"Expected correct_bracketing(%q) to be %v, but got %v\", testCase.input, testCase.expected, result)\n        } else {\n            fmt.Printf(\"correct_bracketing(%q) = %v\\n\", testCase.input, result)\n        }\n    }\n}\n```\n\nIn this code, the `correct_bracketing` function calculates the balance of the brackets by keeping track of the number of opening and closing brackets encountered. If the balance ever falls below zero, it means there are more closing brackets than opening brackets at that point, so it returns false. At the end, if the balance is zero, it means there are an equal number of opening and closing brackets, so it returns true. The test function `TestCorrectBracketing` validates the `correct_bracketing` function against multiple test cases.", "task_id": "HumanEval_61_correct_bracketing"}
{"name": "HumanEval_62_derivative", "language": "go_test.go", "prompt": "package derivative_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative([]int{3, 1, 2, 4, 5})\n// []int{1, 4, 12, 20}\n// >>> derivative([]int{1, 2, 3})\n// []int{2, 6}\nfunc derivative(xs []int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_62_derivative.py", "prompt_terminology": "reworded", "tests": "func TestDerivative(t *testing.T) {\n  candidate := derivative\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 1, 2, 4, 5}), expected: []int{1, 4, 12, 20} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 6} },\n     { actual: candidate([]int{3, 2, 1}), expected: []int{2, 2} },\n     { actual: candidate([]int{3, 2, 1, 0, 4}), expected: []int{2, 2, 0, 16} },\n     { actual: candidate([]int{1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage derivative_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative([]int{3, 1, 2, 4, 5})\n// []int{1, 4, 12, 20}\n// >>> derivative([]int{1, 2, 3})\n// []int{2, 6}\nfunc derivative(xs []int) []int {\n    n := len(xs)\n    if n == 0 {\n        return []int{}\n    }\n\n    deriv := make([]int, n-1)\n    for i := 1; i < n; i++ {\n        deriv[i-1] = xs[i] * i\n    }\n\n    return deriv\n}\n\nfunc TestDerivative(t *testing.T) {\n    cases := []struct {\n        input    []int\n        expected []int\n    }{\n        {[]int{3, 1, 2, 4, 5}, []int{1, 4, 12, 20}},\n        {[]int{1, 2, 3}, []int{2, 6}},\n        {[]int{5, 0, 3}, []int{0, 6}},\n        {[]int{0}, []int{}},\n    }\n\n    for _, c := range cases {\n        got := derivative(c.input)\n        if fmt.Sprintf(\"%v\", got) != fmt.Sprintf(\"%v\", c.expected) {\n            t.Errorf(\"derivative(%v) == %v, expected %v\", c.input, got, c.expected)\n        }\n    }\n}\n\nfunc main() {\n    TestDerivative(&testing.T{})\n}\n```", "task_id": "HumanEval_62_derivative"}
{"name": "HumanEval_63_fibfib", "language": "go_test.go", "prompt": "package fibfib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib(1)\n// 0\n// >>> fibfib(5)\n// 4\n// >>> fibfib(8)\n// 24\nfunc fibfib(n int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_63_fibfib.py", "prompt_terminology": "reworded", "tests": "func TestFibfib(t *testing.T) {\n  candidate := fibfib\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: 1 },\n     { actual: candidate(1), expected: 0 },\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 24 },\n     { actual: candidate(10), expected: 81 },\n     { actual: candidate(12), expected: 274 },\n     { actual: candidate(14), expected: 927 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage fibfib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc fibfib(n int) int {\n    if n < 0 {\n        return -1 // Return -1 for invalid input\n    }\n    \n    if n == 0 || n == 1 {\n        return 0\n    }\n    \n    if n == 2 {\n        return 1\n    }\n    \n    // Create an array to store the computed values\n    fibArr := make([]int, n+1)\n    fibArr[0], fibArr[1], fibArr[2] = 0, 0, 1\n\n    // Calculate fibfib values from 3 to n\n    for i := 3; i <= n; i++ {\n        fibArr[i] = fibArr[i-1] + fibArr[i-2] + fibArr[i-3]\n    }\n    \n    return fibArr[n]\n}\n\nfunc TestFibFib(t *testing.T) {\n    tests := []struct{\n        input int\n        expected int\n    }{\n        {0, 0},\n        {1, 0},\n        {2, 1},\n        {3, 1},\n        {4, 2},\n        {5, 4},\n        {6, 7},\n        {7, 13},\n        {8, 24},\n        {9, 44},\n    }\n\n    for _, test := range tests {\n        result := fibfib(test.input)\n        if result != test.expected {\n            t.Errorf(\"fibfib(%d) == %d, expected %d\", test.input, result, test.expected)\n        }\n    }\n\n    fmt.Println(\"All tests passed.\")\n}\n```", "task_id": "HumanEval_63_fibfib"}
{"name": "HumanEval_64_vowels_count", "language": "go_test.go", "prompt": "package vowels_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count(\"abcde\")\n// 2\n// >>> vowels_count(\"ACEDY\")\n// 3\nfunc vowels_count(s string) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_64_vowels_count.py", "prompt_terminology": "reworded", "tests": "func TestVowels_Count(t *testing.T) {\n  candidate := vowels_count\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"abcde\"), expected: 2 },\n     { actual: candidate(\"Alone\"), expected: 3 },\n     { actual: candidate(\"key\"), expected: 2 },\n     { actual: candidate(\"bye\"), expected: 1 },\n     { actual: candidate(\"keY\"), expected: 2 },\n     { actual: candidate(\"bYe\"), expected: 1 },\n     { actual: candidate(\"ACEDY\"), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage vowels_count_test\n\nimport (\n    \"strings\"\n    \"testing\"\n    \"fmt\"\n)\n\nfunc vowels_count(s string) int {\n    vowels := \"aeiouAEIOU\"\n    count := 0\n\n    for i, char := range s {\n        if strings.ContainsRune(vowels, char) {\n            count++\n        }\n        if (char == 'y' || char == 'Y') && i == len(s)-1 {\n            count++\n        }\n    }\n\n    return count\n}\n\nfunc TestVowelsCount(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected int\n    }{\n        {\"abcde\", 2},\n        {\"ACEDY\", 3},\n        {\"hello\", 2},\n        {\"sky\", 0},\n        {\"fuzzy\", 1},\n        {\"encyclopedia\", 6},\n    }\n\n    for _, test := range tests {\n        result := vowels_count(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input \\\"%s\\\", expected %d but got %d\", test.input, test.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(vowels_count(\"abcde\")) // 2\n    fmt.Println(vowels_count(\"ACEDY\")) // 3\n    fmt.Println(vowels_count(\"hello\")) // 2\n    fmt.Println(vowels_count(\"sky\"))   // 0\n    fmt.Println(vowels_count(\"fuzzy\")) // 1\n    fmt.Println(vowels_count(\"encyclopedia\")) // 6\n}\n```\n\nTo run the tests, use `go test` within your package directory, and observe the output for any failures or successes based on the predefined test cases. The `main` function demonstrates simple usage of the `vowels_count` function.", "task_id": "HumanEval_64_vowels_count"}
{"name": "HumanEval_65_circular_shift", "language": "go_test.go", "prompt": "package circular_shift_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift(12, 1)\n// \"21\"\n// >>> circular_shift(12, 2)\n// \"12\"\nfunc circular_shift(x int, shift int) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_65_circular_shift.py", "prompt_terminology": "reworded", "tests": "func TestCircular_Shift(t *testing.T) {\n  candidate := circular_shift\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(100, 2), expected: \"001\" },\n     { actual: candidate(12, 2), expected: \"12\" },\n     { actual: candidate(97, 8), expected: \"79\" },\n     { actual: candidate(12, 1), expected: \"21\" },\n     { actual: candidate(11, 101), expected: \"11\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage circular_shift_test\n\nimport (\n    \"strconv\"\n    \"testing\"\n    \"fmt\"\n)\n\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift(12, 1)\n// \"21\"\n// >>> circular_shift(12, 2)\n// \"12\"\nfunc circular_shift(x int, shift int) string {\n    // Convert integer to string for easy manipulation\n    s := strconv.Itoa(x)\n    length := len(s)\n\n    // If shift is greater than the number of digits, return the digits reversed\n    if shift >= length {\n        reversed := \"\"\n        for i := length - 1; i >= 0; i-- {\n            reversed += string(s[i])\n        }\n        return reversed\n    }\n\n    // Calculate actual shift needed since it might be larger than the length\n    shift = shift % length\n\n    // Perform the circular shift\n    shifted := s[length-shift:] + s[:length-shift]\n    return shifted\n}\n\nfunc TestCircularShift(t *testing.T) {\n    tests := []struct {\n        x     int\n        shift int\n        want  string\n    }{\n        {12, 1, \"21\"},\n        {12, 2, \"12\"},\n        {1234, 1, \"4123\"},\n        {1234, 3, \"2341\"},\n        {1234, 4, \"1234\"},\n        {1234, 5, \"4321\"},\n    }\n\n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"circular_shift(%d,%d)\", tt.x, tt.shift), func(t *testing.T) {\n            got := circular_shift(tt.x, tt.shift)\n            if got != tt.want {\n                t.Errorf(\"circular_shift(%d, %d) = %s; want %s\", tt.x, tt.shift, got, tt.want)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_65_circular_shift"}
{"name": "HumanEval_66_digitSum", "language": "go_test.go", "prompt": "package digitSum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum(\"\")\n// 0\n// >>> digitSum(\"abAB\")\n// 131\n// >>> digitSum(\"abcCd\")\n// 67\n// >>> digitSum(\"helloE\")\n// 69\n// >>> digitSum(\"woArBld\")\n// 131\n// >>> digitSum(\"aAaaaXa\")\n// 153\nfunc digitSum(s string) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_66_digitSum.py", "prompt_terminology": "reworded", "tests": "func TestDigitsum(t *testing.T) {\n  candidate := digitSum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"abAB\"), expected: 131 },\n     { actual: candidate(\"abcCd\"), expected: 67 },\n     { actual: candidate(\"helloE\"), expected: 69 },\n     { actual: candidate(\"woArBld\"), expected: 131 },\n     { actual: candidate(\"aAaaaXa\"), expected: 153 },\n     { actual: candidate(\" How are yOu?\"), expected: 151 },\n     { actual: candidate(\"You arE Very Smart\"), expected: 327 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage digitSum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"unicode\"\n)\n\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only\n// ASCII codes.\n// Examples:\n// >>> digitSum(\"\")\n// 0\n// >>> digitSum(\"abAB\")\n// 131\n// >>> digitSum(\"abcCd\")\n// 67\n// >>> digitSum(\"helloE\")\n// 69\n// >>> digitSum(\"woArBld\")\n// 131\n// >>> digitSum(\"aAaaaXa\")\n// 153\nfunc digitSum(s string) int {\n    sum := 0\n    for _, char := range s {\n        if unicode.IsUpper(char) {\n            sum += int(char)\n        }\n    }\n    return sum\n}\n\nfunc TestDigitSum(t *testing.T) {\n    tests := []struct {\n        input string\n        want  int\n    }{\n        {\"\", 0},\n        {\"abAB\", 131},\n        {\"abcCd\", 67},\n        {\"helloE\", 69},\n        {\"woArBld\", 131},\n        {\"aAaaaXa\", 153},\n    }\n\n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"digitSum(%q)\", tt.input), func(t *testing.T) {\n            got := digitSum(tt.input)\n            if got != tt.want {\n                t.Errorf(\"digitSum(%q) = %d; want %d\", tt.input, got, tt.want)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_66_digitSum"}
{"name": "HumanEval_67_fruit_distribution", "language": "go_test.go", "prompt": "package fruit_distribution_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution(\"5 apples and 6 oranges\", 19)\n// 8\n// >>> fruit_distribution(\"0 apples and 1 oranges\", 3)\n// 2\n// >>> fruit_distribution(\"2 apples and 3 oranges\", 100)\n// 95\n// >>> fruit_distribution(\"100 apples and 1 oranges\", 120)\n// 19\nfunc fruit_distribution(s string, n int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_67_fruit_distribution.py", "prompt_terminology": "reworded", "tests": "func TestFruit_Distribution(t *testing.T) {\n  candidate := fruit_distribution\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"5 apples and 6 oranges\", 19), expected: 8 },\n     { actual: candidate(\"5 apples and 6 oranges\", 21), expected: 10 },\n     { actual: candidate(\"0 apples and 1 oranges\", 3), expected: 2 },\n     { actual: candidate(\"1 apples and 0 oranges\", 3), expected: 2 },\n     { actual: candidate(\"2 apples and 3 oranges\", 100), expected: 95 },\n     { actual: candidate(\"2 apples and 3 oranges\", 5), expected: 0 },\n     { actual: candidate(\"1 apples and 100 oranges\", 120), expected: 19 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage fruit_distribution_test\n\nimport (\n    \"fmt\"\n    \"strconv\"\n    \"strings\"\n    \"testing\"\n)\n\nfunc fruit_distribution(s string, n int) int {\n    var apples, oranges int\n    fmt.Sscanf(s, \"%d apples and %d oranges\", &apples, &oranges)\n    return n - (apples + oranges)\n}\n\nfunc TestFruitDistribution(t *testing.T) {\n    testCases := []struct {\n        description string\n        s           string\n        n           int\n        expected    int\n    }{\n        {\"5 apples and 6 oranges, total 19\", \"5 apples and 6 oranges\", 19, 8},\n        {\"0 apples and 1 oranges, total 3\", \"0 apples and 1 oranges\", 3, 2},\n        {\"2 apples and 3 oranges, total 100\", \"2 apples and 3 oranges\", 100, 95},\n        {\"100 apples and 1 oranges, total 120\", \"100 apples and 1 oranges\", 120, 19},\n    }\n\n    for _, testCase := range testCases {\n        t.Run(testCase.description, func(t *testing.T) {\n            result := fruit_distribution(testCase.s, testCase.n)\n            if result != testCase.expected {\n                t.Errorf(\"got %d, expected %d\", result, testCase.expected)\n            }\n        })\n    }\n}\n```\n\nThis complete implementation includes the `fruit_distribution` function and a `TestFruitDistribution` function to test the implementation. The tests cover the given examples to ensure the function works as expected.", "task_id": "HumanEval_67_fruit_distribution"}
{"name": "HumanEval_68_pluck", "language": "go_test.go", "prompt": "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// \"Given a list representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a list, [ smalest_value, its index ],\n// If there are no even values or the given list is empty, return [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n// []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0, 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_68_pluck.py", "prompt_terminology": "reworded", "tests": "func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// \"Given a list representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a list, [ smallest_value, its index ],\n// If there are no even values or the given list is empty, return [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n// []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0, 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\nfunc pluck(arr []int) []int {\n    if len(arr) == 0 {\n        return []int{}\n    }\n\n    smallestEvenValue := -1\n    index := -1\n\n    for i, v := range arr {\n        if v%2 == 0 {\n            if smallestEvenValue == -1 || v < smallestEvenValue {\n                smallestEvenValue = v\n                index = i\n            }\n        }\n    }\n\n    if smallestEvenValue == -1 {\n        return []int{}\n    }\n    return []int{smallestEvenValue, index}\n}\n\nfunc TestPluck(t *testing.T) {\n    testCases := []struct {\n        input    []int\n        expected []int\n    }{\n        {[]int{4, 2, 3}, []int{2, 1}},\n        {[]int{1, 2, 3}, []int{2, 1}},\n        {[]int{}, []int{}},\n        {[]int{5, 0, 3, 0, 4, 2}, []int{0, 1}},\n        {[]int{1, 3, 5, 7}, []int{}},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"%v\", tc.input), func(t *testing.T) {\n            actual := pluck(tc.input)\n            if len(actual) != len(tc.expected) {\n                t.Errorf(\"expected %v, got %v\", tc.expected, actual)\n                return\n            }\n            for i := range actual {\n                if actual[i] != tc.expected[i] {\n                    t.Errorf(\"expected %v, got %v\", tc.expected, actual)\n                    break\n                }\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_68_pluck"}
{"name": "HumanEval_69_search", "language": "go_test.go", "prompt": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the list.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search([]int{4, 1, 2, 2, 3, 1})\n// 2\n// >>> search([]int{1, 2, 2, 3, 3, 3, 4, 4, 4})\n// 3\n// >>> search([]int{5, 5, 4, 4, 4})\n// -1\nfunc search(lst []int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_69_search.py", "prompt_terminology": "reworded", "tests": "func TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 5, 5, 5, 1}), expected: 1 },\n     { actual: candidate([]int{4, 1, 4, 1, 4, 4}), expected: 4 },\n     { actual: candidate([]int{3, 3}), expected: -1 },\n     { actual: candidate([]int{8, 8, 8, 8, 8, 8, 8, 8}), expected: 8 },\n     { actual: candidate([]int{2, 3, 3, 2, 2}), expected: 2 },\n     { actual: candidate([]int{2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}), expected: 1 },\n     { actual: candidate([]int{3, 2, 8, 2}), expected: 2 },\n     { actual: candidate([]int{6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}), expected: 1 },\n     { actual: candidate([]int{8, 8, 3, 6, 5, 6, 4}), expected: -1 },\n     { actual: candidate([]int{6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}), expected: 1 },\n     { actual: candidate([]int{1, 9, 10, 1, 3}), expected: 1 },\n     { actual: candidate([]int{6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}), expected: 5 },\n     { actual: candidate([]int{1}), expected: 1 },\n     { actual: candidate([]int{8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}), expected: 4 },\n     { actual: candidate([]int{2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}), expected: 2 },\n     { actual: candidate([]int{1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}), expected: 1 },\n     { actual: candidate([]int{9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}), expected: 4 },\n     { actual: candidate([]int{2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}), expected: 4 },\n     { actual: candidate([]int{9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}), expected: 2 },\n     { actual: candidate([]int{5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}), expected: -1 },\n     { actual: candidate([]int{10}), expected: -1 },\n     { actual: candidate([]int{9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}), expected: 2 },\n     { actual: candidate([]int{5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}), expected: 1 },\n     { actual: candidate([]int{7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}), expected: 1 },\n     { actual: candidate([]int{3, 10, 10, 9, 2}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage search_test\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc search(lst []int) int {\n\tfrequency := make(map[int]int)\n\n\t// Calculate the frequency of each element in the list\n\tfor _, num := range lst {\n\t\tfrequency[num]++\n\t}\n\n\tresult := -1\n\tfor num, count := range frequency {\n\t\tif count >= num && num > result {\n\t\t\tresult = num\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc TestSearch(t *testing.T) {\n\ttests := []struct {\n\t\tinput []int\n\t\twant  int\n\t}{\n\t\t{[]int{4, 1, 2, 2, 3, 1}, 2},\n\t\t{[]int{1, 2, 2, 3, 3, 3, 4, 4, 4}, 3},\n\t\t{[]int{5, 5, 4, 4, 4}, -1},\n\t\t{[]int{6, 6, 6, 5, 5, 5, 5}, 5},\n\t\t{[]int{3, 3, 3, 3}, 3},\n\t\t{[]int{8, 8, 7, 7, 7, 6, 6, 6}, 6},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprint(test.input), func(t *testing.T) {\n\t\t\tgot := search(test.input)\n\t\t\tif got != test.want {\n\t\t\t\tt.Errorf(\"search(%v) = %v; want %v\", test.input, got, test.want)\n\t\t\t}\n\t\t})\n\t}\n}\n```", "task_id": "HumanEval_69_search"}
{"name": "HumanEval_70_strange_sort_list", "language": "go_test.go", "prompt": "package strange_sort_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list([]int{1, 2, 3, 4})\n// []int{1, 4, 2, 3}\n// >>> strange_sort_list([]int{5, 5, 5, 5})\n// []int{5, 5, 5, 5}\n// >>> strange_sort_list([]int{})\n// []int{}\nfunc strange_sort_list(lst []int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_70_strange_sort_list.py", "prompt_terminology": "reworded", "tests": "func TestStrange_Sort_List(t *testing.T) {\n  candidate := strange_sort_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 4, 2, 3} },\n     { actual: candidate([]int{5, 6, 7, 8, 9}), expected: []int{5, 9, 6, 8, 7} },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: []int{1, 5, 2, 4, 3} },\n     { actual: candidate([]int{5, 6, 7, 8, 9, 1}), expected: []int{1, 9, 5, 8, 6, 7} },\n     { actual: candidate([]int{5, 5, 5, 5}), expected: []int{5, 5, 5, 5} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8}), expected: []int{1, 8, 2, 7, 3, 6, 4, 5} },\n     { actual: candidate([]int{0, 2, 2, 2, 5, 5, -5, -5}), expected: []int{-5, 5, -5, 5, 0, 2, 2, 2} },\n     { actual: candidate([]int{111111}), expected: []int{111111} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage strange_sort_list_test\n\nimport (\n    \"fmt\"\n    \"sort\"\n    \"testing\"\n)\n\n// Given list of integers, return list in strange order.\n// Strange sorting is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list([]int{1, 2, 3, 4})\n// []int{1, 4, 2, 3}\n// >>> strange_sort_list([]int{5, 5, 5, 5})\n// []int{5, 5, 5, 5}\n// >>> strange_sort_list([]int{})\n// []int{}\nfunc strange_sort_list(lst []int) []int {\n    if len(lst) == 0 {\n        return []int{}\n    }\n\n    sort.Ints(lst)\n    result := []int{}\n    i, j := 0, len(lst)-1\n\n    for i <= j {\n        if i == j {\n            result = append(result, lst[i])\n        } else {\n            result = append(result, lst[i], lst[j])\n        }\n        i++\n        j--\n    }\n\n    return result\n}\n\nfunc TestStrangeSortList(t *testing.T) {\n    cases := []struct {\n        input  []int\n        expect []int\n    }{\n        {[]int{1, 2, 3, 4}, []int{1, 4, 2, 3}},\n        {[]int{5, 5, 5, 5}, []int{5, 5, 5, 5}},\n        {[]int{}, []int{}},\n    }\n\n    for _, c := range cases {\n        got := strange_sort_list(c.input)\n        if !equal(got, c.expect) {\n            t.Errorf(\"strange_sort_list(%v) == %v, want %v\", c.input, got, c.expect)\n        } else {\n            fmt.Printf(\"Test passed with input: %v, output: %v\\n\", c.input, got)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n```", "task_id": "HumanEval_70_strange_sort_list"}
{"name": "HumanEval_71_triangle_area", "language": "go_test.go", "prompt": "package triangle_area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area(3, 4, 5)\n// 6.0\n// >>> triangle_area(1, 2, 10)\n// -1\nfunc triangle_area(a int, b int, c int) float64 {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_71_triangle_area.py", "prompt_terminology": "reworded", "tests": "func TestTriangle_Area(t *testing.T) {\n  candidate := triangle_area\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 4, 5), expected: 6.0 },\n     { actual: candidate(1, 2, 10), expected: -1 },\n     { actual: candidate(4, 8, 5), expected: 8.18 },\n     { actual: candidate(2, 2, 2), expected: 1.73 },\n     { actual: candidate(1, 2, 3), expected: -1 },\n     { actual: candidate(10, 5, 7), expected: 16.25 },\n     { actual: candidate(2, 6, 3), expected: -1 },\n     { actual: candidate(1, 1, 1), expected: 0.43 },\n     { actual: candidate(2, 2, 10), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage triangle_area_test\n\nimport (\n    \"testing\"\n    \"math\"\n    \"fmt\"\n)\n\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area(3, 4, 5)\n// 6.0\n// >>> triangle_area(1, 2, 10)\n// -1\nfunc triangle_area(a int, b int, c int) float64 {\n    // Check for valid triangle using the triangle inequality theorem\n    if a+b <= c || a+c <= b || b+c <= a {\n        return -1\n    }\n\n    // Calculate the area using Heron's formula\n    s := float64((a + b + c)) / 2\n    area := math.Sqrt(s * (s - float64(a)) * (s - float64(b)) * (s - float64(c)))\n\n    // Round to 2 decimal places\n    area = math.Round(area*100) / 100\n    return area\n}\n\n// Unit tests\nfunc TestTriangleArea(t *testing.T) {\n    cases := []struct {\n        a, b, c int\n        expected float64\n    }{\n        {3, 4, 5, 6.00},\n        {1, 2, 10, -1},\n        {7, 10, 5, 16.25},\n        {6, 8, 10, 24.00},\n        {11, 12, 13, 61.48},\n    }\n\n    for _, c := range cases {\n        t.Run(fmt.Sprintf(\"%d,%d,%d\", c.a, c.b, c.c), func(t *testing.T) {\n            got := triangle_area(c.a, c.b, c.c)\n            if got != c.expected {\n                t.Fatalf(\"expected %f, but got %f\", c.expected, got)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_71_triangle_area"}
{"name": "HumanEval_72_will_it_fly", "language": "go_test.go", "prompt": "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n// false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n// # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w int) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_72_will_it_fly.py", "prompt_terminology": "reworded", "tests": "func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n// false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n// # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w int) bool {\n    // Check if the list q is a palindrome\n    n := len(q)\n    for i := 0; i < n/2; i++ {\n        if q[i] != q[n-i-1] {\n            return false\n        }\n    }\n\n    // Calculate the sum of the list elements\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n\n    // Check if the sum is less than or equal to the maximum weight\n    if sum <= w {\n        return true\n    }\n\n    return false\n}\n\n// Tests\nfunc TestWillItFly(t *testing.T) {\n    cases := []struct{\n        q []int\n        w int\n        expected bool\n    }{\n        {[]int{1, 2}, 5, false},\n        {[]int{3, 2, 3}, 1, false},\n        {[]int{3, 2, 3}, 9, true},\n        {[]int{3}, 5, true},\n    }\n\n    for _, c := range cases {\n        result := will_it_fly(c.q, c.w)\n        if result != c.expected {\n            t.Errorf(\"will_it_fly(%v, %d) == %t, expected %t\", c.q, c.w, result, c.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(will_it_fly([]int{1, 2}, 5))  // false\n    fmt.Println(will_it_fly([]int{3, 2, 3}, 1))  // false\n    fmt.Println(will_it_fly([]int{3, 2, 3}, 9))  // true\n    fmt.Println(will_it_fly([]int{3}, 5))  // true\n}\n```", "task_id": "HumanEval_72_will_it_fly"}
{"name": "HumanEval_73_smallest_change", "language": "go_test.go", "prompt": "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list arr of integers, find the minimum number of elements that\n// need to be changed to make the list palindromic. A palindromic list is a list that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change([]int{1, 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2, 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr []int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_73_smallest_change.py", "prompt_terminology": "reworded", "tests": "func TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc smallest_change(arr []int) int {\n    n := len(arr)\n    changes := 0\n\n    for i := 0; i < n/2; i++ {\n        if arr[i] != arr[n-i-1] {\n            changes++\n        }\n    }\n\n    return changes\n}\n\nfunc TestSmallestChange(t *testing.T) {\n    tests := []struct {\n        input []int\n        want  int\n    }{\n        {[]int{1, 2, 3, 5, 4, 7, 9, 6}, 4},\n        {[]int{1, 2, 3, 4, 3, 2, 2}, 1},\n        {[]int{1, 2, 3, 2, 1}, 0},\n        {[]int{1, 2, 2, 3, 1}, 1},\n        {[]int{1, 2, 3, 4, 5, 4, 3, 2, 1}, 0},\n        {[]int{1, 3, 1, 3, 1}, 1},\n    }\n\n    for _, tc := range tests {\n        t.Run(fmt.Sprintf(\"%v\", tc.input), func(t *testing.T) {\n            got := smallest_change(tc.input)\n            if got != tc.want {\n                t.Fatalf(\"expected %d, but got %d\", tc.want, got)\n            }\n        })\n    }\n}\n```\n\nThis code defines the function `smallest_change` which computes the minimum number of changes required to make a list palindromic. The function iterates through the list from both ends towards the center, counting the positions where elements differ. The `TestSmallestChange` function includes multiple test cases to check the correctness of `smallest_change`.", "task_id": "HumanEval_73_smallest_change"}
{"name": "HumanEval_74_total_match", "language": "go_test.go", "prompt": "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that accepts two lists of strings and returns the list that has \n// total number of chars in the all strings of the list less than the other list.\n// if the two lists have the same number of chars, return the first list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n// []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n// []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string, lst2 []string) []string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_74_total_match.py", "prompt_terminology": "reworded", "tests": "func TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage total_match_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\n// total_match function to compare lists of strings based on their total number of characters\nfunc total_match(lst1 []string, lst2 []string) []string {\n\tcountChars := func(lst []string) int {\n\t\ttotal := 0\n\t\tfor _, str := range lst {\n\t\t\ttotal += len(str)\n\t\t}\n\t\treturn total\n\t}\n\n\tcount1 := countChars(lst1)\n\tcount2 := countChars(lst2)\n\n\tif count1 <= count2 {\n\t\treturn lst1\n\t}\n\treturn lst2\n}\n\n// Test function for total_match\nfunc TestTotalMatch(t *testing.T) {\n\ttests := []struct {\n\t\tlst1     []string\n\t\tlst2     []string\n\t\texpected []string\n\t}{\n\t\t{[]string{}, []string{}, []string{}},\n\t\t{[]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}, []string{\"hI\", \"Hi\"}},\n\t\t{[]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}, []string{\"hi\", \"admin\"}},\n\t\t{[]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}, []string{\"hI\", \"hi\", \"hi\"}},\n\t\t{[]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}, []string{\"4\"}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := total_match(tt.lst1, tt.lst2)\n\t\tif len(result) != len(tt.expected) {\n\t\t\tt.Errorf(\"total_match(%v, %v) = %v; want %v\", tt.lst1, tt.lst2, result, tt.expected)\n\t\t}\n\t\tfor i := range result {\n\t\t\tif result[i] != tt.expected[i] {\n\t\t\t\tt.Errorf(\"total_match(%v, %v) = %v; want %v\", tt.lst1, tt.lst2, result, tt.expected)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc ExampleTotalMatch() {\n\tfmt.Println(total_match([]string{}, []string{}))\n\tfmt.Println(total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}))\n\tfmt.Println(total_match([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}))\n\tfmt.Println(total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}))\n\tfmt.Println(total_match([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}))\n\t// Output:\n\t// []\n\t// [hI Hi]\n\t// [hi admin]\n\t// [hI hi hi]\n\t// [4]\n}\n```", "task_id": "HumanEval_74_total_match"}
{"name": "HumanEval_75_is_multiply_prime", "language": "go_test.go", "prompt": "package is_multiply_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime(30)\n// true\n// 30 = 2 * 3 * 5\nfunc is_multiply_prime(a int) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_75_is_multiply_prime.py", "prompt_terminology": "reworded", "tests": "func TestIs_Multiply_Prime(t *testing.T) {\n  candidate := is_multiply_prime\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: false },\n     { actual: candidate(30), expected: true },\n     { actual: candidate(8), expected: true },\n     { actual: candidate(10), expected: false },\n     { actual: candidate(125), expected: true },\n     { actual: candidate(105), expected: true },\n     { actual: candidate(126), expected: false },\n     { actual: candidate(729), expected: false },\n     { actual: candidate(891), expected: false },\n     { actual: candidate(1001), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage is_multiply_prime_test\n\nimport (\n    \"testing\"\n    \"math\"\n)\n\n// Helper function to check if a number is prime\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\n// Helper function to get all prime numbers less than 100\nfunc getPrimes() []int {\n    primes := []int{}\n    for i := 2; i < 100; i++ {\n        if isPrime(i) {\n            primes = append(primes, i)\n        }\n    }\n    return primes\n}\n\n// Function to check if a number is the product of three primes\nfunc is_multiply_prime(a int) bool {\n    primes := getPrimes()\n    n := len(primes)\n    \n    for i := 0; i < n; i++ {\n        for j := i; j < n; j++ {\n            for k := j; k < n; k++ {\n                if primes[i] * primes[j] * primes[k] == a {\n                    return true\n                }\n            }\n        }\n    }\n    \n    return false\n}\n\n// Unit tests\nfunc TestIsMultiplyPrime(t *testing.T) {\n    tests := []struct{\n        input int\n        expected bool\n    }{\n        {30, true},\n        {70, false},\n        {2310, true}, // 2 * 3 * 5 * 7\n        {105, true},  // 3 * 5 * 7\n        {15, false},  // 3 * 5\n        {60, true},   // 2 * 3 * 5 (within limits)\n        {97, false},  // 97 is a prime but not a product of three primes\n    }\n    \n    for _, test := range tests {\n        result := is_multiply_prime(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input %d, expected %v, but got %v\", test.input, test.expected, result)\n        }\n    }\n}\n```", "task_id": "HumanEval_75_is_multiply_prime"}
{"name": "HumanEval_76_is_simple_power", "language": "go_test.go", "prompt": "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>> is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>> is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n// >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_76_is_simple_power.py", "prompt_terminology": "reworded", "tests": "func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>> is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>> is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n// >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return false\n    }\n    current := n\n    for current <= x {\n        if current == x {\n            return true\n        }\n        current *= n\n    }\n    return false\n}\n\nfunc TestIsSimplePower(t *testing.T) {\n    testCases := []struct {\n        x        int\n        n        int\n        expected bool\n    }{\n        {1, 4, true},\n        {2, 2, true},\n        {8, 2, true},\n        {3, 2, false},\n        {3, 1, false},\n        {5, 3, false},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"x: %d, n: %d\", tc.x, tc.n), func(t *testing.T) {\n            result := is_simple_power(tc.x, tc.n)\n            if result != tc.expected {\n                t.Errorf(\"expected %v, got %v\", tc.expected, result)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_76_is_simple_power"}
{"name": "HumanEval_77_iscube", "language": "go_test.go", "prompt": "package iscube_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube(1)\n// true\n// >>> iscube(2)\n// false\n// >>> iscube(-1)\n// true\n// >>> iscube(64)\n// true\n// >>> iscube(0)\n// true\n// >>> iscube(180)\n// false\nfunc iscube(a int) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_77_iscube.py", "prompt_terminology": "reworded", "tests": "func TestIscube(t *testing.T) {\n  candidate := iscube\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: true },\n     { actual: candidate(2), expected: false },\n     { actual: candidate(-1), expected: true },\n     { actual: candidate(64), expected: true },\n     { actual: candidate(180), expected: false },\n     { actual: candidate(1000), expected: true },\n     { actual: candidate(0), expected: true },\n     { actual: candidate(1729), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage iscube_test\n\nimport (\n    \"math\"\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes an integer a and returns true \n// if this integer is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube(1)\n// true\n// >>> iscube(2)\n// false\n// >>> iscube(-1)\n// true\n// >>> iscube(64)\n// true\n// >>> iscube(0)\n// true\n// >>> iscube(180)\n// false\nfunc iscube(a int) bool {\n    // Compute the cube root of the absolute value of a\n    cubeRoot := math.Cbrt(float64(a))\n    \n    // Round the result to the nearest integer\n    roundedCubeRoot := math.Round(cubeRoot)\n\n    // Cube the rounded value and compare with the original value\n    if int(math.Pow(roundedCubeRoot, 3)) == a {\n        return true\n    }\n    return false\n}\n\nfunc TestIsCube(t *testing.T) {\n    testCases := []struct {\n        input    int\n        expected bool\n    }{\n        {1, true},\n        {2, false},\n        {-1, true},\n        {64, true},\n        {0, true},\n        {180, false},\n    }\n\n    for _, tc := range testCases {\n        result := iscube(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"iscube(%d) = %v; expected %v\", tc.input, result, tc.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(iscube(1))   // true\n    fmt.Println(iscube(2))   // false\n    fmt.Println(iscube(-1))  // true\n    fmt.Println(iscube(64))  // true\n    fmt.Println(iscube(0))   // true\n    fmt.Println(iscube(180)) // false\n}\n```", "task_id": "HumanEval_77_iscube"}
{"name": "HumanEval_78_hex_key", "language": "go_test.go", "prompt": "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\")\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_78_hex_key.py", "prompt_terminology": "reworded", "tests": "func TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage hex_key_test\n\nimport (\n    \"testing\"\n)\n\n// List of hexadecimal digits that are prime numbers\nvar primeHexDigits = map[rune]bool{\n    '2': true,\n    '3': true,\n    '5': true,\n    '7': true,\n    'B': true,\n    'D': true,\n}\n\nfunc hex_key(num string) int {\n    count := 0\n    for _, ch := range num {\n        if primeHexDigits[ch] {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestHexKey(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected int\n    }{\n        {\"AB\", 1},\n        {\"1077E\", 2},\n        {\"ABED1A33\", 4},\n        {\"123456789ABCDEF0\", 6},\n        {\"2020\", 2},\n    }\n\n    for _, test := range tests {\n        t.Run(test.input, func(t *testing.T) {\n            result := hex_key(test.input)\n            if result != test.expected {\n                t.Errorf(\"hex_key(%s) = %d; want %d\", test.input, result, test.expected)\n            }\n        })\n    }\n}\n\nfunc main() {\n    fmt.Println(hex_key(\"AB\"))         // Output: 1\n    fmt.Println(hex_key(\"1077E\"))      // Output: 2\n    fmt.Println(hex_key(\"ABED1A33\"))   // Output: 4\n    fmt.Println(hex_key(\"123456789ABCDEF0\")) // Output: 6\n    fmt.Println(hex_key(\"2020\"))       // Output: 2\n}\n```\n\nThis code includes the `hex_key` function which counts the number of prime hexadecimal digits in a given string. The `TestHexKey` function includes some test cases for verification using the `testing` package. The `main` function demonstrates the function usage with the provided examples.", "task_id": "HumanEval_78_hex_key"}
{"name": "HumanEval_79_decimal_to_binary", "language": "go_test.go", "prompt": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_79_decimal_to_binary.py", "prompt_terminology": "reworded", "tests": "func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "Here is the completed Go code wrapped in markdown syntax:\n\n```go\npackage decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strconv\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    binary := strconv.FormatInt(int64(decimal), 2)\n    return fmt.Sprintf(\"db%sdb\", binary)\n}\n\nfunc TestDecimalToBinary(t *testing.T) {\n    tests := []struct{\n        input int\n        expected string\n    }{\n        {15, \"db1111db\"},\n        {32, \"db100000db\"},\n        {1, \"db1db\"},\n        {0, \"db0db\"},\n        {255, \"db11111111db\"},\n    }\n    \n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"decimal_to_binary(%d)\", test.input), func(t *testing.T) {\n            output := decimal_to_binary(test.input)\n            if output != test.expected {\n                t.Errorf(\"got %s, want %s\", output, test.expected)\n            }\n        })\n    }\n}\n```\n\nIn this code, the `decimal_to_binary` function converts a decimal number to its binary representation, wraps the binary string with \"db\" at both ends, and returns the result. The `TestDecimalToBinary` function includes several test cases to ensure the implementation is correct.", "task_id": "HumanEval_79_decimal_to_binary"}
{"name": "HumanEval_80_is_happy", "language": "go_test.go", "prompt": "package is_happy_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// Your task is to check if the string is hapgo or not.\n// A string is hapgo if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy(\"a\")\n// false\n// >>> is_happy(\"aa\")\n// false\n// >>> is_happy(\"abcd\")\n// true\n// >>> is_happy(\"aabb\")\n// false\n// >>> is_happy(\"adb\")\n// true\n// >>> is_happy(\"xyy\")\n// false\nfunc is_happy(s string) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_80_is_happy.py", "prompt_terminology": "reworded", "tests": "func TestIs_Happy(t *testing.T) {\n  candidate := is_happy\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"a\"), expected: false },\n     { actual: candidate(\"aa\"), expected: false },\n     { actual: candidate(\"abcd\"), expected: true },\n     { actual: candidate(\"aabb\"), expected: false },\n     { actual: candidate(\"adb\"), expected: true },\n     { actual: candidate(\"xyy\"), expected: false },\n     { actual: candidate(\"iopaxpoi\"), expected: true },\n     { actual: candidate(\"iopaxioi\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage is_happy_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_happy(s string) bool {\n    if len(s) < 3 {\n        return false\n    }\n\n    for i := 0; i <= len(s)-3; i++ {\n        if s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIsHappy(t *testing.T) {\n    var tests = []struct {\n        input string\n        expected bool\n    }{\n        {\"a\", false},\n        {\"aa\", false},\n        {\"abcd\", true},\n        {\"aabb\", false},\n        {\"adb\", true},\n        {\"xyy\", false},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"is_happy(%q)\", test.input), func(t *testing.T) {\n            if got := is_happy(test.input); got != test.expected {\n                t.Errorf(\"is_happy(%q) = %v; want %v\", test.input, got, test.expected)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_80_is_happy"}
{"name": "HumanEval_81_numerical_letter_grade", "language": "go_test.go", "prompt": "package numerical_letter_grade_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a list of GPAs for some students and you have to write \n// a function that can output a list of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation([]float64{4.0, 3, 1.7, 2, 3.5})\n// []string{\"A+\", \"B\", \"C-\", \"C\", \"A-\"}\nfunc numerical_letter_grade(grades []float64) []string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_81_numerical_letter_grade.py", "prompt_terminology": "reworded", "tests": "func TestNumerical_Letter_Grade(t *testing.T) {\n  candidate := numerical_letter_grade\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{4.0, 3, 1.7, 2, 3.5}), expected: []string{\"A+\", \"B\", \"C-\", \"C\", \"A-\"} },\n     { actual: candidate([]float64{1.2}), expected: []string{\"D+\"} },\n     { actual: candidate([]float64{0.5}), expected: []string{\"D-\"} },\n     { actual: candidate([]float64{0.0}), expected: []string{\"E\"} },\n     { actual: candidate([]float64{1.0, 0.3, 1.5, 2.8, 3.3}), expected: []string{\"D\", \"D-\", \"C-\", \"B\", \"B+\"} },\n     { actual: candidate([]float64{0.0, 0.7}), expected: []string{\"E\", \"D-\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage numerical_letter_grade_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc numerical_letter_grade(grades []float64) []string {\n    var letter_grades []string\n\n    for _, grade := range grades {\n        switch {\n        case grade == 4.0:\n            letter_grades = append(letter_grades, \"A+\")\n        case grade > 3.7:\n            letter_grades = append(letter_grades, \"A\")\n        case grade > 3.3:\n            letter_grades = append(letter_grades, \"A-\")\n        case grade > 3.0:\n            letter_grades = append(letter_grades, \"B+\")\n        case grade > 2.7:\n            letter_grades = append(letter_grades, \"B\")\n        case grade > 2.3:\n            letter_grades = append(letter_grades, \"B-\")\n        case grade > 2.0:\n            letter_grades = append(letter_grades, \"C+\")\n        case grade > 1.7:\n            letter_grades = append(letter_grades, \"C\")\n        case grade > 1.3:\n            letter_grades = append(letter_grades, \"C-\")\n        case grade > 1.0:\n            letter_grades = append(letter_grades, \"D+\")\n        case grade > 0.7:\n            letter_grades = append(letter_grades, \"D\")\n        case grade > 0.0:\n            letter_grades = append(letter_grades, \"D-\")\n        default:\n            letter_grades = append(letter_grades, \"E\")\n        }\n    }\n\n    return letter_grades\n}\n\nfunc TestNumericalLetterGrade(t *testing.T) {\n    grades := []float64{4.0, 3.0, 1.7, 2.0, 3.5}\n    expected := []string{\"A+\", \"B+\", \"C\", \"C+\", \"A-\"}\n    result := numerical_letter_grade(grades)\n\n    for i, v := range result {\n        if v != expected[i] {\n            t.Errorf(\"For grade %.1f, expected %s but got %s\", grades[i], expected[i], v)\n        }\n    }\n}\n\nfunc main() {\n    grades := []float64{4.0, 3.0, 1.7, 2.0, 3.5}\n    fmt.Println(numerical_letter_grade(grades))\n}\n```", "task_id": "HumanEval_81_numerical_letter_grade"}
{"name": "HumanEval_82_prime_length", "language": "go_test.go", "prompt": "package prime_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length(\"Hello\")\n// true\n// >>> prime_length(\"abcdcba\")\n// true\n// >>> prime_length(\"kittens\")\n// true\n// >>> prime_length(\"orange\")\n// false\nfunc prime_length(myString string) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_82_prime_length.py", "prompt_terminology": "reworded", "tests": "func TestPrime_Length(t *testing.T) {\n  candidate := prime_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hello\"), expected: true },\n     { actual: candidate(\"abcdcba\"), expected: true },\n     { actual: candidate(\"kittens\"), expected: true },\n     { actual: candidate(\"orange\"), expected: false },\n     { actual: candidate(\"wow\"), expected: true },\n     { actual: candidate(\"world\"), expected: true },\n     { actual: candidate(\"MadaM\"), expected: true },\n     { actual: candidate(\"Wow\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"HI\"), expected: true },\n     { actual: candidate(\"go\"), expected: true },\n     { actual: candidate(\"gogo\"), expected: false },\n     { actual: candidate(\"aaaaaaaaaaaaaaa\"), expected: false },\n     { actual: candidate(\"Madam\"), expected: true },\n     { actual: candidate(\"M\"), expected: false },\n     { actual: candidate(\"0\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage prime_length_test\n\nimport (\n    \"math\"\n    \"testing\"\n    \"fmt\"\n)\n\n// Function to check if a number is prime\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n%2 == 0 {\n        return false\n    }\n    for i := 3; i <= int(math.Sqrt(float64(n))); i += 2 {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\n// Function to check if the length of the string is prime\nfunc prime_length(myString string) bool {\n    length := len(myString)\n    return isPrime(length)\n}\n\n// Test cases\nfunc TestPrimeLength(t *testing.T) {\n    cases := []struct {\n        input    string\n        expected bool\n    }{\n        {\"Hello\", true},\n        {\"abcdcba\", true},\n        {\"kittens\", true},\n        {\"orange\", false},\n        {\"a\", false},\n        {\"ab\", true},\n        {\"abcdefghij\", false},\n        {\"abcdefghijk\", false},\n        {\"abcdefghijkl\", false},\n        {\"abcdefghijklm\", true},\n    }\n    \n    for _, c := range cases {\n        t.Run(fmt.Sprintf(\"prime_length(%q)\", c.input), func(t *testing.T) {\n            result := prime_length(c.input)\n            if result != c.expected {\n                t.Errorf(\"expected %v, got %v\", c.expected, result)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_82_prime_length"}
{"name": "HumanEval_83_starts_one_ends", "language": "go_test.go", "prompt": "package starts_one_ends_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nfunc starts_one_ends(n int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_83_starts_one_ends.py", "prompt_terminology": "reworded", "tests": "func TestStarts_One_Ends(t *testing.T) {\n  candidate := starts_one_ends\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: 1 },\n     { actual: candidate(2), expected: 18 },\n     { actual: candidate(3), expected: 180 },\n     { actual: candidate(4), expected: 1800 },\n     { actual: candidate(5), expected: 18000 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage starts_one_ends_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nfunc starts_one_ends(n int) int {\n    if n == 1 {\n        return 1\n    }\n\n    totalCount := int(math.Pow(10, float64(n-1)))\n    countStartWith1 := 1 * int(math.Pow(10, float64(n-1)))\n    countEndWith1 := 9 * int(math.Pow(10, float64(n-2)))\n\n    return countStartWith1 + countEndWith1\n}\n\nfunc TestStartsOneEnds(t *testing.T) {\n    if res := starts_one_ends(1); res != 1 {\n        t.Errorf(\"expected 1, got %v\", res)\n    }\n    if res := starts_one_ends(2); res != 18 {\n        t.Errorf(\"expected 18, got %v\", res)\n    }\n    if res := starts_one_ends(3); res != 180 {\n        t.Errorf(\"expected 180, got %v\", res)\n    }\n}\n\nfunc ExampleStartsOneEnds() {\n    fmt.Println(starts_one_ends(1)) // Output: 1\n    fmt.Println(starts_one_ends(2)) // Output: 18\n    fmt.Println(starts_one_ends(3)) // Output: 180\n    // Output:\n    // 1\n    // 18\n    // 180\n}\n```", "task_id": "HumanEval_83_starts_one_ends"}
{"name": "HumanEval_84_solve", "language": "go_test.go", "prompt": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve(1000)\n// \"1\"\n// >>> solve(150)\n// \"110\"\n// >>> solve(147)\n// \"1100\"\n// Variables:\n// @N integer\n// Constraints: 0 ≤ N ≤ 10000.\n// Output:\n// a string of binary number\nfunc solve(N int) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_84_solve.py", "prompt_terminology": "reworded", "tests": "func TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1000), expected: \"1\" },\n     { actual: candidate(150), expected: \"110\" },\n     { actual: candidate(147), expected: \"1100\" },\n     { actual: candidate(333), expected: \"1001\" },\n     { actual: candidate(963), expected: \"10010\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage solve_test\n\nimport (\n    \"strconv\"\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve(1000)\n// \"1\"\n// >>> solve(150)\n// \"110\"\n// >>> solve(147)\n// \"1100\"\n// Variables:\n// @N integer\n// Constraints: 0 ≤ N ≤ 10000.\n// Output:\n// a string of binary number\nfunc solve(N int) string {\n    sum := 0\n    for N > 0 {\n        sum += N % 10\n        N /= 10\n    }\n    return strconv.FormatInt(int64(sum), 2)\n}\n\nfunc TestSolve(t *testing.T) {\n    testCases := []struct {\n        input    int\n        expected string\n    }{\n        {1000, \"1\"},\n        {150, \"110\"},\n        {147, \"1100\"},\n        {0, \"0\"},\n        {9999, \"1001\"},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"%d\", tc.input), func(t *testing.T) {\n            result := solve(tc.input)\n            if result != tc.expected {\n                t.Errorf(\"expected %s but got %s\", tc.expected, result)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_84_solve"}
{"name": "HumanEval_85_add", "language": "go_test.go", "prompt": "package add_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a non-empty list of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add([]int{4, 2, 6, 7})\n// 2\nfunc add(lst []int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_85_add.py", "prompt_terminology": "reworded", "tests": "func TestAdd(t *testing.T) {\n  candidate := add\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 88}), expected: 88 },\n     { actual: candidate([]int{4, 5, 6, 7, 2, 122}), expected: 122 },\n     { actual: candidate([]int{4, 0, 6, 7}), expected: 0 },\n     { actual: candidate([]int{4, 4, 6, 8}), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage add_test\n\nimport (\n\t\"testing\"\n)\n\n// Given a non-empty list of integers lst, add the even elements that are at odd indices.\n// Examples:\n// >>> add([]int{4, 2, 6, 7})\n// 2\nfunc add(lst []int) int {\n    sum := 0\n    for i := 1; i < len(lst); i += 2 { // iterate over odd indices\n        if lst[i]%2 == 0 { // check if the element is even\n            sum += lst[i]\n        }\n    }\n    return sum\n}\n\nfunc TestAdd(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected int\n\t}{\n\t\t{[]int{4, 2, 6, 7}, 2},\n\t\t{[]int{1, 2, 3, 4, 5, 6}, 6},\n\t\t{[]int{2, 4, 1, 6, 3, 8}, 14},\n\t\t{[]int{8, 5, 6, 7, 4, 9}, 0}, // no even elements at odd indices\n\t}\n\n\tfor _, tt := range tests {\n\t\tif result := add(tt.input); result != tt.expected {\n\t\t\tt.Errorf(\"add(%v) = %v; want %v\", tt.input, result, tt.expected)\n\t\t}\n\t}\n}\n```", "task_id": "HumanEval_85_add"}
{"name": "HumanEval_86_anti_shuffle", "language": "go_test.go", "prompt": "package anti_shuffle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle(\"Hi\")\n// \"Hi\"\n// >>> anti_shuffle(\"hello\")\n// \"ehllo\"\n// >>> anti_shuffle(\"Hello World!!!\")\n// \"Hello !!!Wdlor\"\nfunc anti_shuffle(s string) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_86_anti_shuffle.py", "prompt_terminology": "reworded", "tests": "func TestAnti_Shuffle(t *testing.T) {\n  candidate := anti_shuffle\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hi\"), expected: \"Hi\" },\n     { actual: candidate(\"hello\"), expected: \"ehllo\" },\n     { actual: candidate(\"number\"), expected: \"bemnru\" },\n     { actual: candidate(\"abcd\"), expected: \"abcd\" },\n     { actual: candidate(\"Hello World!!!\"), expected: \"Hello !!!Wdlor\" },\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"Hi. My name is Mister Robot. How are you?\"), expected: \".Hi My aemn is Meirst .Rboot How aer ?ouy\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage anti_shuffle_test\n\nimport (\n    \"sort\"\n    \"strings\"\n    \"unicode\"\n)\n\n// anti_shuffle function reorders characters in each word of the input string.\nfunc anti_shuffle(s string) string {\n    result := []string{}\n    words := strings.FieldsFunc(s, unicode.IsSpace)\n    spaces := strings.FieldsFunc(s, func(r rune) bool { return !unicode.IsSpace(r) })\n    \n    w := 0\n    for i, r := range s {\n        if unicode.IsSpace(r) {\n            result = append(result, spaces[w])\n            w++\n        } else {\n            chars := []rune(words[w])\n            sort.Slice(chars, func(i, j int) bool {\n                return chars[i] < chars[j]\n            })\n            result = append(result, string(chars))\n            w++\n        }\n    }\n    \n    return strings.Join(result, \"\")\n}\n\nfunc TestAntiShuffle(t *testing.T) {\n    tests := []struct {\n        input, expected string\n    }{\n        {\"Hi\", \"Hi\"},\n        {\"hello\", \"ehllo\"},\n        {\"Hello World!!!\", \"Hello !!!Wdlor\"},\n        {\"Go is fun\", \"Go is fnu\"},\n    }\n\n    for _, test := range tests {\n        result := anti_shuffle(test.input)\n        if result != test.expected {\n            t.Errorf(\"expected %q, got %q\", test.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(anti_shuffle(\"Hi\"))               // \"Hi\"\n    fmt.Println(anti_shuffle(\"hello\"))            // \"ehllo\"\n    fmt.Println(anti_shuffle(\"Hello World!!!\"))   // \"Hello !!!Wdlor\"\n}\n\n```\n\nIn this code:\n- The `anti_shuffle` function processes each word in the string separately, sorts the characters within each word, and maintains the original spaces.\n- The `TestAntiShuffle` function is provided to test the `anti_shuffle` function with different test cases.\n- The `main` function includes examples to demonstrate how the `anti_shuffle` function works with different inputs.", "task_id": "HumanEval_86_anti_shuffle"}
{"name": "HumanEval_87_get_row", "language": "go_test.go", "prompt": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_87_get_row.py", "prompt_terminology": "reworded", "tests": "func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage get_row_test\n\nimport (\n\t\"testing\"\n\t\"sort\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n\tvar coordinates [][]interface{}\n\t\n\tfor i, row := range lst {\n\t\tfor j, val := range row {\n\t\t\tif val == x {\n\t\t\t\tcoordinates = append(coordinates, []interface{}{i, j})\n\t\t\t}\n\t\t}\n\t}\n\n\tsort.SliceStable(coordinates, func(i, j int) bool {\n\t\tif coordinates[i][0].(int) == coordinates[j][0].(int) {\n\t\t\treturn coordinates[i][1].(int) > coordinates[j][1].(int)\n\t\t}\n\t\treturn coordinates[i][0].(int) < coordinates[j][0].(int)\n\t})\n\n\treturn coordinates\n}\n\nfunc TestGetRow(t *testing.T) {\n\ttests := []struct {\n\t\tlst      [][]int\n\t\tx        int\n\t\texpected [][]interface{}\n\t}{\n\t\t{\n\t\t\tlst:      [][]int{{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}},\n\t\t\tx:        1,\n\t\t\texpected: [][]interface{}{{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}},\n\t\t},\n\t\t{\n\t\t\tlst:      [][]int{},\n\t\t\tx:        1,\n\t\t\texpected: [][]interface{}{},\n\t\t},\n\t\t{\n\t\t\tlst:      [][]int{{}, {1}, {1, 2, 3}},\n\t\t\tx:        3,\n\t\t\texpected: [][]interface{}{{2, 2}},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := get_row(test.lst, test.x)\n\t\tif len(result) != len(test.expected) {\n\t\t\tt.Errorf(\"For %v and %d expected %v but got %v\", test.lst, test.x, test.expected, result)\n\t\t\tcontinue\n\t\t}\n\t\tfor i := range result {\n\t\t\tif result[i][0] != test.expected[i][0] || result[i][1] != test.expected[i][1] {\n\t\t\t\tt.Errorf(\"For %v and %d expected %v but got %v\", test.lst, test.x, test.expected, result)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t}\n}\n```", "task_id": "HumanEval_87_get_row"}
{"name": "HumanEval_88_sort_array", "language": "go_test.go", "prompt": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_88_sort_array.py", "prompt_terminology": "reworded", "tests": "func TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage sort_array_test\n\nimport (\n    \"sort\"\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a copy of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return []int{}\n    }\n\n    first := array[0]\n    last := array[len(array)-1]\n    sum := first + last\n\n    newArray := make([]int, len(array))\n    copy(newArray, array)\n\n    if sum % 2 == 0 {\n        sort.Sort(sort.Reverse(sort.IntSlice(newArray)))\n    } else {\n        sort.Ints(newArray)\n    }\n\n    return newArray\n}\n\nfunc TestSortArray(t *testing.T) {\n    cases := []struct {\n        input []int\n        expected []int\n    }{\n        {[]int{}, []int{}},\n        {[]int{5}, []int{5}},\n        {[]int{2, 4, 3, 0, 1, 5}, []int{0, 1, 2, 3, 4, 5}},\n        {[]int{2, 4, 3, 0, 1, 5, 6}, []int{6, 5, 4, 3, 2, 1, 0}},\n    }\n\n    for _, c := range cases {\n        got := sort_array(c.input)\n        if !equal(got, c.expected) {\n            t.Errorf(\"sort_array(%v) == %v, expected %v\", c.input, got, c.expected)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc ExampleSortArray() {\n    fmt.Println(sort_array([]int{})) // []\n    fmt.Println(sort_array([]int{5})) // []int{5}\n    fmt.Println(sort_array([]int{2, 4, 3, 0, 1, 5})) // []int{0, 1, 2, 3, 4, 5}\n    fmt.Println(sort_array([]int{2, 4, 3, 0, 1, 5, 6})) // []int{6, 5, 4, 3, 2, 1, 0}\n}\n```", "task_id": "HumanEval_88_sort_array"}
{"name": "HumanEval_89_encrypt", "language": "go_test.go", "prompt": "package encrypt_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt(\"hi\")\n// \"lm\"\n// >>> encrypt(\"asdfghjkl\")\n// \"ewhjklnop\"\n// >>> encrypt(\"gf\")\n// \"kj\"\n// >>> encrypt(\"et\")\n// \"ix\"\nfunc encrypt(s string) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_89_encrypt.py", "prompt_terminology": "reworded", "tests": "func TestEncrypt(t *testing.T) {\n  candidate := encrypt\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"hi\"), expected: \"lm\" },\n     { actual: candidate(\"asdfghjkl\"), expected: \"ewhjklnop\" },\n     { actual: candidate(\"gf\"), expected: \"kj\" },\n     { actual: candidate(\"et\"), expected: \"ix\" },\n     { actual: candidate(\"faewfawefaewg\"), expected: \"jeiajeaijeiak\" },\n     { actual: candidate(\"hellomyfriend\"), expected: \"lippsqcjvmirh\" },\n     { actual: candidate(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"), expected: \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" },\n     { actual: candidate(\"a\"), expected: \"e\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage encrypt\n\nfunc encrypt(s string) string {\n    result := []rune{}\n    for _, c := range s {\n        // Shift the character by 2 * 2 = 4 positions\n        shifted := c + 4\n        if shifted > 'z' { \n            shifted -= 26 // Wrap-around in case of overflow\n        }\n        result = append(result, shifted)\n    }\n    return string(result)\n}\n```\n\n```go\npackage encrypt_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"encrypt\"\n)\n\nfunc TestEncrypt(t *testing.T) {\n    testCases := []struct {\n        in, want string\n    }{\n        {\"hi\", \"lm\"},\n        {\"asdfghjkl\", \"ewhjklnop\"},\n        {\"gf\", \"kj\"},\n        {\"et\", \"ix\"},\n    }\n\n    for _, tc := range testCases {\n        got := encrypt.Encrypt(tc.in)\n        if got != tc.want {\n            t.Errorf(\"encrypt(%q) = %q; want %q\", tc.in, got, tc.want)\n        } else {\n            fmt.Printf(\"encrypt(%q) = %q; correct!\\n\", tc.in, got)\n        }\n    }\n}\n```\n\nHere is the explanation of the `encrypt` function:\n\n- It takes a string `s` as input and initializes an empty slice `result` of type `[]rune`.\n- It iterates through each character `c` of the input string `s`.\n- For each character, it shifts it by 4 positions, and if the shift goes beyond 'z', it wraps around by subtracting 26 from the shifted value.\n- Finally, it appends the shifted characters to the `result` slice and converts it back to a string to return.\n\nThe test function `TestEncrypt` tests the `encrypt` function with a variety of test cases to ensure it behaves as expected.", "task_id": "HumanEval_89_encrypt"}
{"name": "HumanEval_91_is_bored", "language": "go_test.go", "prompt": "package is_bored_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored(\"Hello world\")\n// 0\n// >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n// 1\nfunc is_bored(S string) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_91_is_bored.py", "prompt_terminology": "reworded", "tests": "func TestIs_Bored(t *testing.T) {\n  candidate := is_bored\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hello world\"), expected: 0 },\n     { actual: candidate(\"Is the sky blue?\"), expected: 0 },\n     { actual: candidate(\"I love It !\"), expected: 1 },\n     { actual: candidate(\"bIt\"), expected: 0 },\n     { actual: candidate(\"I feel good today. I will be productive. will kill It\"), expected: 2 },\n     { actual: candidate(\"You and I are going for a walk\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage is_bored_test\n\nimport (\n    \"strings\"\n    \"testing\"\n    \"fmt\"\n)\n\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored(\"Hello world\")\n// 0\n// >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n// 1\nfunc is_bored(S string) int {\n    // Split the string into sentences\n    sentences := strings.FieldsFunc(S, func(r rune) bool {\n        return r == '.' || r == '?' || r == '!'\n    })\n\n    count := 0\n    for _, sentence := range sentences {\n        trimmedSentence := strings.TrimSpace(sentence)\n        if len(trimmedSentence) > 0 && strings.HasPrefix(trimmedSentence, \"I \") {\n            count++\n        }\n    }\n\n    return count\n}\n\nfunc TestIsBored(t *testing.T) {\n    tests := []struct{\n        input string\n        expected int\n    }{\n        {\"Hello world\", 0},\n        {\"The sky is blue. The sun is shining. I love this weather\", 1},\n        {\"I am bored. Are you? I think we should do something fun.\", 2},\n        {\"Is anyone there? I am alone. Hello! I am still here.\", 2},\n        {\"This is a test. This is only a test.\", 0},\n        {\"I. I. I. I\", 4},\n    }\n\n    for _, test := range tests {\n        result := is_bored(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input '%s', expected %d but got %d\", test.input, test.expected, result)\n        }\n    }\n}\n\nfunc main() {\n\t// Running test cases\n\tTestIsBored(&testing.T{})\n\n\t// Example usage\n\tinput := \"The sky is blue. The sun is shining. I love this weather\"\n\tres := is_bored(input)\n\tfmt.Printf(\"Number of boredoms in the input string: %d\\n\", res)\n}\n```\n\nTo run the code and tests, save it to a `.go` file (e.g., `is_bored.go`) and use `go test` command to execute the tests. The `main` function is added to illustrate example usage of the `is_bored` function, but it's typically not included in a test file.", "task_id": "HumanEval_91_is_bored"}
{"name": "HumanEval_92_any_int", "language": "go_test.go", "prompt": "package any_int_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int(5, 2, 7)\n// true\n// >>> any_int(3, 2, 2)\n// false\n// >>> any_int(3, -2, 1)\n// true\n// >>> any_int(3.6, -2.2, 2)\n// false\nfunc any_int(x float64, y float64, z float64) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_92_any_int.py", "prompt_terminology": "reworded", "tests": "func TestAny_Int(t *testing.T) {\n  candidate := any_int\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2, 3, 1), expected: true },\n     { actual: candidate(2.5, 2, 3), expected: false },\n     { actual: candidate(1.5, 5, 3.5), expected: false },\n     { actual: candidate(2, 6, 2), expected: false },\n     { actual: candidate(4, 2, 2), expected: true },\n     { actual: candidate(2.2, 2.2, 2.2), expected: false },\n     { actual: candidate(-4, 6, 2), expected: true },\n     { actual: candidate(2, 1, 1), expected: true },\n     { actual: candidate(3, 4, 7), expected: true },\n     { actual: candidate(3.0, 4, 7), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage any_int_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int(5, 2, 7)\n// true\n// >>> any_int(3, 2, 2)\n// false\n// >>> any_int(3, -2, 1)\n// true\n// >>> any_int(3.6, -2.2, 2)\n// false\nfunc any_int(x float64, y float64, z float64) bool {\n    if !isInteger(x) || !isInteger(y) || !isInteger(z) {\n        return false\n    }\n    return x == y+z || y == x+z || z == x+y\n}\n\n// Helper function to check if the number is an integer.\nfunc isInteger(val float64) bool {\n    return val == math.Trunc(val)\n}\n\nfunc TestAnyInt(t *testing.T) {\n    var tests = []struct{\n        x float64\n        y float64\n        z float64\n        expected bool\n    }{\n        {5, 2, 7, true},\n        {3, 2, 2, false},\n        {3, -2, 1, true},\n        {3.6, -2.2, 2, false},\n    }\n\n    for _, tt := range tests {\n        testName := fmt.Sprintf(\"%f,%f,%f\", tt.x, tt.y, tt.z)\n        t.Run(testName, func(t *testing.T) {\n            result := any_int(tt.x, tt.y, tt.z)\n            if result != tt.expected {\n                t.Fatalf(\"expected %v but got %v\", tt.expected, result)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_92_any_int"}
{"name": "HumanEval_93_encode", "language": "go_test.go", "prompt": "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message string) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_93_encode.py", "prompt_terminology": "reworded", "tests": "func TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage encode_test\n\nimport (\n    \"strings\"\n    \"testing\"\n    \"unicode\"\n)\n\n// encode takes a message and encodes it by swapping the case of all letters \n// and replacing all vowels with the letter that appears 2 places ahead of that vowel.\nfunc encode(message string) string {\n    var encodedMessage strings.Builder\n    vowels := map[rune]rune{\n        'a': 'c', 'A': 'C',\n        'e': 'g', 'E': 'G',\n        'i': 'k', 'I': 'K',\n        'o': 'q', 'O': 'Q',\n        'u': 'w', 'U': 'W',\n    }\n\n    for _, char := range message {\n        if unicode.IsLetter(char) {\n            if newChar, isVowel := vowels[char]; isVowel {\n                // If char is a vowel, replace it with the corresponding character\n                encodedMessage.WriteRune(newChar)\n            } else {\n                // Otherwise, simply swap the case\n                if unicode.IsUpper(char) {\n                    encodedMessage.WriteRune(unicode.ToLower(char))\n                } else {\n                    encodedMessage.WriteRune(unicode.ToUpper(char))\n                }\n            }\n        } else {\n            // If not a letter, just append as is (though we expect only letters)\n            encodedMessage.WriteRune(char)\n        }\n    }\n    return encodedMessage.String()\n}\n\nfunc TestEncode(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected string\n    }{\n        {\"test\", \"TGST\"},\n        {\"This is a message\", \"tHKS KS C MGSSCGG\"},\n        {\"Hello World\", \"hGLLQ wQRLd\"},\n        {\"Vowel\", \"vQwGL\"},\n        {\"Encoding\", \"GNCQDKKG\"},\n    }\n\n    for _, test := range tests {\n        t.Run(test.input, func(t *testing.T) {\n            result := encode(test.input)\n            if result != test.expected {\n                t.Errorf(\"expected: %s, got: %s\", test.expected, result)\n            } else {\n                fmt.Printf(\"Encode(%q) = %q\\n\", test.input, result)\n            }\n        })\n    }\n}\n```\n\nThis code includes the `encode` function that performs the required encoding by swapping cases and replacing vowels as specified. The `TestEncode` function is provided to test the `encode` function with different test cases.", "task_id": "HumanEval_93_encode"}
{"name": "HumanEval_94_skjkasdkd", "language": "go_test.go", "prompt": "package skjkasdkd_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a list of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})\n// 10\n// >>> skjkasdkd([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1})\n// 25\n// >>> skjkasdkd([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3})\n// 13\n// >>> skjkasdkd([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6})\n// 11\n// >>> skjkasdkd([]int{0, 81, 12, 3, 1, 21})\n// 3\n// >>> skjkasdkd([]int{0, 8, 1, 2, 1, 7})\n// 7\nfunc skjkasdkd(lst []int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_94_skjkasdkd.py", "prompt_terminology": "reworded", "tests": "func TestSkjkasdkd(t *testing.T) {\n  candidate := skjkasdkd\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}), expected: 10 },\n     { actual: candidate([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}), expected: 25 },\n     { actual: candidate([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}), expected: 13 },\n     { actual: candidate([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}), expected: 11 },\n     { actual: candidate([]int{0, 81, 12, 3, 1, 21}), expected: 3 },\n     { actual: candidate([]int{0, 8, 1, 2, 1, 7}), expected: 7 },\n     { actual: candidate([]int{8191}), expected: 19 },\n     { actual: candidate([]int{8191, 123456, 127, 7}), expected: 19 },\n     { actual: candidate([]int{127, 97, 8192}), expected: 10 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage skjkasdkd_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\n// Helper function to check if a number is prime\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n%2 == 0 {\n        return false\n    }\n    sqrtN := int(math.Sqrt(float64(n)))\n    for i := 3; i <= sqrtN; i += 2 {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\n// Function to return the sum of digits of a number\nfunc sumOfDigits(n int) int {\n    sum := 0\n    for n > 0 {\n        sum += n % 10\n        n /= 10\n    }\n    return sum\n}\n\n// Main function as specified in the requirements\nfunc skjkasdkd(lst []int) int {\n    largestPrime := -1\n    for _, num := range lst {\n        if isPrime(num) && num > largestPrime {\n            largestPrime = num\n        }\n    }\n    \n    if largestPrime == -1 {\n        return 0\n    }\n    \n    return sumOfDigits(largestPrime)\n}\n\nfunc TestSkjkasdkd(t *testing.T) {\n    testCases := []struct {\n        input    []int\n        expected int\n    }{\n        {[]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}, 10},\n        {[]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}, 25},\n        {[]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}, 13},\n        {[]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}, 11},\n        {[]int{0, 81, 12, 3, 1, 21}, 3},\n        {[]int{0, 8, 1, 2, 1, 7}, 7},\n    }\n\n    for _, testCase := range testCases {\n        result := skjkasdkd(testCase.input)\n        if result != testCase.expected {\n            t.Errorf(\"For input %v: expected %d, got %d\", testCase.input, testCase.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(skjkasdkd([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})) // 10\n    fmt.Println(skjkasdkd([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}))                // 25\n    fmt.Println(skjkasdkd([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}))       // 13\n    fmt.Println(skjkasdkd([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}))                       // 11\n    fmt.Println(skjkasdkd([]int{0, 81, 12, 3, 1, 21}))                                                   // 3\n    fmt.Println(skjkasdkd([]int{0, 8, 1, 2, 1, 7}))                                                      // 7", "task_id": "HumanEval_94_skjkasdkd"}
{"name": "HumanEval_95_check_dict_case", "language": "go_test.go", "prompt": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_95_check_dict_case.py", "prompt_terminology": "reworded", "tests": "func TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage check_dict_case_test\n\nimport (\n\t\"unicode\"\n\t\"testing\"\n\t\"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false if the given map is empty.\n\nfunc check_dict_case(dict map[string]string) bool {\n\tif len(dict) == 0 {\n\t\treturn false\n\t}\n\n\tallLower := true\n\tallUpper := true\n\n\tfor key := range dict {\n\t\tfor _, char := range key {\n\t\t\tif !unicode.IsLower(char) {\n\t\t\t\tallLower = false\n\t\t\t}\n\t\t\tif !unicode.IsUpper(char) {\n\t\t\t\tallUpper = false\n\t\t\t}\n\t\t}\n\t}\n\n\treturn allLower || allUpper\n}\n\n// Test cases\nfunc TestCheckDictCase(t *testing.T) {\n\ttests := []struct {\n\t\tinput    map[string]string\n\t\texpected bool\n\t}{\n\t\t{map[string]string{\"a\": \"apple\", \"b\": \"banana\"}, true},\n\t\t{map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"}, false},\n\t\t{map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"}, false},\n\t\t{map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}, false},\n\t\t{map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}, true},\n\t\t{map[string]string{}, false},\n\t\t{map[string]string{\"key\": \"value\", \"KEY\": \"value\"}, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Input: %v\", test.input), func(t *testing.T) {\n\t\t\tresult := check_dict_case(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"Expected %v but got %v\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n```", "task_id": "HumanEval_95_check_dict_case"}
{"name": "HumanEval_96_count_up_to", "language": "go_test.go", "prompt": "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Implement a function that takes an non-negative integer and returns a list of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n// []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n// []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_96_count_up_to.py", "prompt_terminology": "reworded", "tests": "func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_up_to(n int) []int {\n    if n < 2 {\n        return []int{}\n    }\n\t\n    primes := []int{}\n    isPrime := make([]bool, n)\n\n    for i := 2; i < n; i++ {\n        isPrime[i] = true\n    }\n\n    for i := 2; i < n; i++ {\n        if isPrime[i] {\n            primes = append(primes, i)\n            for j := i * 2; j < n; j += i {\n                isPrime[j] = false\n            }\n        }\n    }\n\n    return primes\n}\n\nfunc TestCountUpTo(t *testing.T) {\n    testData := map[int][]int{\n        5:    {2, 3},\n        11:   {2, 3, 5, 7},\n        0:    {},\n        20:   {2, 3, 5, 7, 11, 13, 17, 19},\n        1:    {},\n        18:   {2, 3, 5, 7, 11, 13, 17},\n    }\n\n    for input, expected := range testData {\n        result := count_up_to(input)\n        if !equal(result, expected) {\n            t.Errorf(\"For input %d, expected %v but got %v\", input, expected, result)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    fmt.Println(count_up_to(5))  // Output: [2, 3]\n    fmt.Println(count_up_to(11)) // Output: [2, 3, 5, 7]\n    fmt.Println(count_up_to(0))  // Output: []\n    fmt.Println(count_up_to(20)) // Output: [2, 3, 5, 7, 11, 13, 17, 19]\n    fmt.Println(count_up_to(1))  // Output: []\n    fmt.Println(count_up_to(18)) // Output: [2, 3, 5, 7, 11, 13, 17]\n}\n```", "task_id": "HumanEval_96_count_up_to"}
{"name": "HumanEval_97_multiply", "language": "go_test.go", "prompt": "package multiply_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply(148, 412)\n// 16\n// >>> multiply(19, 28)\n// 72\n// >>> multiply(2020, 1851)\n// 0\n// >>> multiply(14, -15)\n// 20\nfunc multiply(a int, b int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_97_multiply.py", "prompt_terminology": "reworded", "tests": "func TestMultiply(t *testing.T) {\n  candidate := multiply\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(148, 412), expected: 16 },\n     { actual: candidate(19, 28), expected: 72 },\n     { actual: candidate(2020, 1851), expected: 0 },\n     { actual: candidate(14, -15), expected: 20 },\n     { actual: candidate(76, 67), expected: 42 },\n     { actual: candidate(17, 27), expected: 49 },\n     { actual: candidate(0, 1), expected: 0 },\n     { actual: candidate(0, 0), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage multiply_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply(148, 412)\n// 16\n// >>> multiply(19, 28)\n// 72\n// >>> multiply(2020, 1851)\n// 0\n// >>> multiply(14, -15)\n// 20\nfunc multiply(a int, b int) int {\n    unitDigitA := abs(a) % 10\n    unitDigitB := abs(b) % 10\n    return unitDigitA * unitDigitB\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n\nfunc TestMultiply(t *testing.T) {\n    tests := []struct {\n        a, b     int\n        expected int\n    }{\n        {148, 412, 16},\n        {19, 28, 72},\n        {2020, 1851, 0},\n        {14, -15, 20},\n    }\n\n    for _, test := range tests {\n        result := multiply(test.a, test.b)\n        if result != test.expected {\n            t.Errorf(\"multiply(%d, %d) = %d; expected %d\", test.a, test.b, result, test.expected)\n        }\n    }\n}\n\nfunc main() {\n    // This is used to run the tests outside the usual 'go test' command for demonstration purposes.\n    TestMultiply(&testing.T{})\n    fmt.Println(\"All tests passed!\")\n}\n```", "task_id": "HumanEval_97_multiply"}
{"name": "HumanEval_98_count_upper", "language": "go_test.go", "prompt": "package count_upper_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper(\"aBCdEf\")\n// 1\n// >>> count_upper(\"abcdefg\")\n// 0\n// >>> count_upper(\"dBBE\")\n// 0\nfunc count_upper(s string) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_98_count_upper.py", "prompt_terminology": "reworded", "tests": "func TestCount_Upper(t *testing.T) {\n  candidate := count_upper\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"aBCdEf\"), expected: 1 },\n     { actual: candidate(\"abcdefg\"), expected: 0 },\n     { actual: candidate(\"dBBE\"), expected: 0 },\n     { actual: candidate(\"B\"), expected: 0 },\n     { actual: candidate(\"U\"), expected: 1 },\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"EEEE\"), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage count_upper_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"unicode\"\n)\n\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper(\"aBCdEf\")\n// 1\n// >>> count_upper(\"abcdefg\")\n// 0\n// >>> count_upper(\"dBBE\")\n// 0\nfunc count_upper(s string) int {\n    count := 0\n    for i, r := range s {\n        if i%2 == 0 && isUpperVowel(r) {\n            count++\n        }\n    }\n    return count\n}\n\n// Helper function to check if a rune is an uppercase vowel.\nfunc isUpperVowel(r rune) bool {\n    switch r {\n    case 'A', 'E', 'I', 'O', 'U':\n        return true\n    }\n    return false\n}\n\nfunc TestCountUpper(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected int\n    }{\n        {\"aBCdEf\", 1},\n        {\"abcdefg\", 0},\n        {\"dBBE\", 0},\n        {\"ACE\", 2},\n        {\"aAbIeOu\", 0},\n    }\n\n    for _, test := range tests {\n        result := count_upper(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input %q, expected %d but got %d\", test.input, test.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    tests := []struct {\n        input    string\n        expected int\n    }{\n        {\"aBCdEf\", 1},\n        {\"abcdefg\", 0},\n        {\"dBBE\", 0},\n        {\"ACE\", 2},\n        {\"aAbIeOu\", 0},\n    }\n\n    for _, test := range tests {\n        result := count_upper(test.input)\n        fmt.Printf(\"For input %q, expected %d, got %d\\n\", test.input, test.expected, result)\n    }\n}\n```\n\nSave the above code in a file and execute it to test the functionality. The `TestCountUpper` function uses the `testing` package for unit tests, while the `main` function prints out results for manual verification.", "task_id": "HumanEval_98_count_upper"}
{"name": "HumanEval_99_closest_integer", "language": "go_test.go", "prompt": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_99_closest_integer.py", "prompt_terminology": "reworded", "tests": "func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strconv\"\n    \"math\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n    num, err := strconv.ParseFloat(value, 64)\n    if err != nil {\n        return 0 // Or handle as needed\n    }\n\n    // Using math.Modf to separate the number into integer and fractional parts\n    intPart, fracPart := math.Modf(num)\n\n    if fracPart > 0.5 || (fracPart == 0.5 && intPart >= 0) {\n        return int(intPart + 1)\n    } else if fracPart < -0.5 || (fracPart == -0.5 && intPart <= 0) {\n        return int(intPart - 1)\n    }\n\n    return int(intPart)\n}\n\n// Unit tests\nfunc TestClosestInteger(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected int\n    }{\n        {\"10\", 10},\n        {\"15.3\", 15},\n        {\"14.5\", 15},\n        {\"-14.5\", -15},\n        {\"0.5\", 1},\n        {\"-0.5\", -1},\n    }\n\n    for _, test := range tests {\n        result := closest_integer(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input %s, expected %d, but got %d\", test.input, test.expected, result)\n        }\n    }\n}\n\n// Main function for manual testing\nfunc main() {\n    fmt.Println(closest_integer(\"10\"))    // Expected: 10\n    fmt.Println(closest_integer(\"15.3\"))  // Expected: 15\n    fmt.Println(closest_integer(\"14.5\"))  // Expected: 15\n    fmt.Println(closest_integer(\"-14.5\")) // Expected: -15\n    fmt.Println(closest_integer(\"0.5\"))   // Expected: 1\n    fmt.Println(closest_integer(\"-0.5\"))  // Expected: -1\n}\n```", "task_id": "HumanEval_99_closest_integer"}
{"name": "HumanEval_100_make_a_pile", "language": "go_test.go", "prompt": "package make_a_pile_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a list, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile(3)\n// []int{3, 5, 7}\nfunc make_a_pile(n int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_100_make_a_pile.py", "prompt_terminology": "reworded", "tests": "func TestMake_A_Pile(t *testing.T) {\n  candidate := make_a_pile\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3), expected: []int{3, 5, 7} },\n     { actual: candidate(4), expected: []int{4, 6, 8, 10} },\n     { actual: candidate(5), expected: []int{5, 7, 9, 11, 13} },\n     { actual: candidate(6), expected: []int{6, 8, 10, 12, 14, 16} },\n     { actual: candidate(8), expected: []int{8, 10, 12, 14, 16, 18, 20, 22} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage make_a_pile_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a list, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile(3)\n// []int{3, 5, 7}\nfunc make_a_pile(n int) []int {\n    pile := []int{n}\n    for i := 1; i < n; i++ {\n        if n % 2 == 0 {\n            n += 2\n        } else {\n            n += 2\n        }\n        pile = append(pile, n)\n    }\n    return pile\n}\n\n// Test function\nfunc TestMakeAPile(t *testing.T) {\n    cases := []struct{\n        input int\n        expected []int\n    }{\n        {1, []int{1}},\n        {2, []int{2, 4}},\n        {3, []int{3, 5, 7}},\n        {4, []int{4, 6, 8, 10}},\n        {5, []int{5, 7, 9, 11, 13}},\n    }\n\n    for _, c := range cases {\n        t.Run(fmt.Sprintf(\"make_a_pile(%d)\", c.input), func(t *testing.T) {\n            result := make_a_pile(c.input)\n            for i, v := range result {\n                if v != c.expected[i] {\n                    t.Errorf(\"Expected %v, but got %v\", c.expected, result)\n                    break\n                }\n            }\n        })\n    }\n}\n```\n\nIn the `make_a_pile` function, we start with the first level having `n` stones. We then loop through to build the levels of stones according to the rules specified (odd or even increment). Finally, we return the `pile`.\n\nThe test function `TestMakeAPile` includes a set of test cases with different `n` values to verify the correctness of the `make_a_pile` function. Each test case runs and checks if the output matches the expected result.", "task_id": "HumanEval_100_make_a_pile"}
{"name": "HumanEval_101_words_string", "language": "go_test.go", "prompt": "package words_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a list of the words.\n// For example:\n// >>> words_string(\"Hi, my name is John\")\n// []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"}\n// >>> words_string(\"One, two, three, four, five, six\")\n// []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}\nfunc words_string(s string) []string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_101_words_string.py", "prompt_terminology": "reworded", "tests": "func TestWords_String(t *testing.T) {\n  candidate := words_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hi, my name is John\"), expected: []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"} },\n     { actual: candidate(\"One, two, three, four, five, six\"), expected: []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"} },\n     { actual: candidate(\"Hi, my name\"), expected: []string{\"Hi\", \"my\", \"name\"} },\n     { actual: candidate(\"One,, two, three, four, five, six,\"), expected: []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"} },\n     { actual: candidate(\"\"), expected: []string{} },\n     { actual: candidate(\"ahmed     , gamal\"), expected: []string{\"ahmed\", \"gamal\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage words_string_test\n\nimport (\n    \"strings\"\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a list of the words.\n// For example:\n// >>> words_string(\"Hi, my name is John\")\n// []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"}\n// >>> words_string(\"One, two, three, four, five, six\")\n// []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}\nfunc words_string(s string) []string {\n    // Replace commas with spaces\n    s = strings.ReplaceAll(s, \",\", \" \")\n    // Split the string using spaces\n    words := strings.Fields(s)\n    return words\n}\n\nfunc TestWordsString(t *testing.T) {\n    tests := []struct {\n        input  string\n        output []string\n    }{\n        {\"Hi, my name is John\", []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"}},\n        {\"One, two, three, four, five, six\", []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}},\n        {\"Hello,world,this,is,Go\", []string{\"Hello\", \"world\", \"this\", \"is\", \"Go\"}},\n        {\"   No,commas here  \", []string{\"No\", \"commas\", \"here\"}},\n    }\n\n    for _, test := range tests {\n        result := words_string(test.input)\n        if len(result) != len(test.output) {\n            t.Errorf(\"Expected length %v, but got length %v\", len(test.output), len(result))\n        }\n        for i := range result {\n            if result[i] != test.output[i] {\n                t.Errorf(\"Expected %v, but got %v\", test.output, result)\n                break\n            }\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(words_string(\"Hi, my name is John\"))  // Output: []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"}\n    fmt.Println(words_string(\"One, two, three, four, five, six\"))  // Output: []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}\n}\n```\n\nThis Go code defines the function `words_string` which splits a string into words, based on spaces and commas as delimiters. Additionally, a test function `TestWordsString` is provided to validate the functionality with various test cases. The `main` function prints out example calls to `words_string`.", "task_id": "HumanEval_101_words_string"}
{"name": "HumanEval_102_choose_num", "language": "go_test.go", "prompt": "package choose_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num(12, 15)\n// 14\n// >>> choose_num(13, 12)\n// -1\nfunc choose_num(x int, y int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_102_choose_num.py", "prompt_terminology": "reworded", "tests": "func TestChoose_Num(t *testing.T) {\n  candidate := choose_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(12, 15), expected: 14 },\n     { actual: candidate(13, 12), expected: -1 },\n     { actual: candidate(33, 12354), expected: 12354 },\n     { actual: candidate(5234, 5233), expected: -1 },\n     { actual: candidate(6, 29), expected: 28 },\n     { actual: candidate(27, 10), expected: -1 },\n     { actual: candidate(7, 7), expected: -1 },\n     { actual: candidate(546, 546), expected: 546 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage choose_num_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num(12, 15)\n// 14\n// >>> choose_num(13, 12)\n// -1\nfunc choose_num(x int, y int) int {\n\tif x > y {\n\t\treturn -1\n\t}\n\n\t// To find the largest even number in the range [x, y]\n\t// Start checking from y to x\n\tfor i := y; i >= x; i-- {\n\t\tif i % 2 == 0 {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn -1\n}\n\n// TestChooseNum tests choose_num function\nfunc TestChooseNum(t *testing.T) {\n\ttests := []struct {\n\t\tx, y   int\n\t\texpect int\n\t}{\n\t\t{12, 15, 14},\n\t\t{13, 12, -1},\n\t\t{1, 10, 10},\n\t\t{4, 4, 4},\n\t\t{3, 5, 4},\n\t\t{7, 7, -1},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%d,%d\", test.x, test.y), func(t *testing.T) {\n\t\t\tresult := choose_num(test.x, test.y)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"choose_num(%d, %d) = %d; want %d\", test.x, test.y, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}\n```", "task_id": "HumanEval_102_choose_num"}
{"name": "HumanEval_104_unique_digits", "language": "go_test.go", "prompt": "package unique_digits_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of positive integers x. return a sorted list of all \n// elements that hasn't any even digit.\n// Note: Returned list should be sorted in increasing order.\n// For example:\n// >>> unique_digits([]int{15, 33, 1422, 1})\n// []int{1, 15, 33}\n// >>> unique_digits([]int{152, 323, 1422, 10})\n// []int{}\nfunc unique_digits(x []int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_104_unique_digits.py", "prompt_terminology": "reworded", "tests": "func TestUnique_Digits(t *testing.T) {\n  candidate := unique_digits\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{15, 33, 1422, 1}), expected: []int{1, 15, 33} },\n     { actual: candidate([]int{152, 323, 1422, 10}), expected: []int{} },\n     { actual: candidate([]int{12345, 2033, 111, 151}), expected: []int{111, 151} },\n     { actual: candidate([]int{135, 103, 31}), expected: []int{31, 135} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage unique_digits_test\n\nimport (\n    \"sort\"\n    \"testing\"\n    \"fmt\"\n)\n\nfunc unique_digits(x []int) []int {\n    var result []int\n    for _, num := range x {\n        if hasNoEvenDigit(num) {\n            result = append(result, num)\n        }\n    }\n    sort.Ints(result)\n    return result\n}\n\nfunc hasNoEvenDigit(n int) bool {\n    for n > 0 {\n        digit := n % 10\n        if digit%2 == 0 {\n            return false\n        }\n        n /= 10\n    }\n    return true\n}\n\nfunc TestUniqueDigits(t *testing.T) {\n    tests := []struct {\n        input  []int\n        output []int\n    }{\n        {[]int{15, 33, 1422, 1}, []int{1, 15, 33}},\n        {[]int{152, 323, 1422, 10}, []int{}},\n        {[]int{3, 111, 135, 222}, []int{3, 111, 135}},\n    }\n\n    for _, test := range tests {\n        result := unique_digits(test.input)\n        if !equal(result, test.output) {\n            t.Errorf(\"For input %v, expected %v, got %v\", test.input, test.output, result)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    tests := []struct {\n        input  []int\n        output []int\n    }{\n        {[]int{15, 33, 1422, 1}, []int{1, 15, 33}},\n        {[]int{152, 323, 1422, 10}, []int{}},\n        {[]int{3, 111, 135, 222}, []int{3, 111, 135}},\n    }\n\n    for _, test := range tests {\n        result := unique_digits(test.input)\n        fmt.Printf(\"Input: %v, Output: %v\\n\", test.input, result)\n    }\n}\n```\n\nThe code defines a function `unique_digits` that filters out integers containing even digits from a list, sorts the resulting list, and returns it. Additionally, there are helper functions and test cases to verify the functionality of the `unique_digits` function.", "task_id": "HumanEval_104_unique_digits"}
{"name": "HumanEval_105_by_length", "language": "go_test.go", "prompt": "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting list, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5, 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>> by_length([]int{})\n// []string{}\n// If the list has any strange number ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr []int) []string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_105_by_length.py", "prompt_terminology": "reworded", "tests": "func TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage by_length_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n\t\"sort\"\n)\n\n// Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting list, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5, 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>> by_length([]int{})\n// []string{}\n// If the list has any strange number ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr []int) []string {\n\t// Define a map to convert integer digits to their corresponding names\n\tdigitNames := map[int]string{\n\t\t1: \"One\",\n\t\t2: \"Two\",\n\t\t3: \"Three\",\n\t\t4: \"Four\",\n\t\t5: \"Five\",\n\t\t6: \"Six\",\n\t\t7: \"Seven\",\n\t\t8: \"Eight\",\n\t\t9: \"Nine\",\n\t}\n\n\t// Filter the array to keep only digits between 1 and 9\n\tvar filtered []int\n\tfor _, v := range arr {\n\t\tif v >= 1 && v <= 9 {\n\t\t\tfiltered = append(filtered, v)\n\t\t}\n\t}\n\n\t// Sort the filtered array\n\tsort.Ints(filtered)\n\n\t// Reverse the array\n\tfor i, j := 0, len(filtered)-1; i < j; i, j = i+1, j-1 {\n\t\tfiltered[i], filtered[j] = filtered[j], filtered[i]\n\t}\n\n\t// Convert the sorted and reversed digits to their corresponding names\n\tvar result []string\n\tfor _, v := range filtered {\n\t\tresult = append(result, digitNames[v])\n\t}\n\n\treturn result\n}\n\nfunc TestByLength(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected []string\n\t}{\n\t\t{[]int{2, 1, 1, 4, 5, 8, 2, 3}, []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}},\n\t\t{[]int{}, []string{}},\n\t\t{[]int{1, -1, 55}, []string{\"One\"}},\n\t\t{[]int{9, 1, 1, 4, 5, 8, 2, 6}, []string{\"Nine\", \"Eight\", \"Six\", \"Five\", \"Four\", \"Two\", \"One\", \"One\"}},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"input=%v\", test.input), func(t *testing.T) {\n\t\t\tresult := by_length(test.input)\n\t\t\tif !equal(result, test.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equal(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n```", "task_id": "HumanEval_105_by_length"}
{"name": "HumanEval_106_f", "language": "go_test.go", "prompt": "package f_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Implement the function f that takes n as a parameter,\n// and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f(5)\n// []int{1, 2, 6, 24, 15}\nfunc f(n int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_106_f.py", "prompt_terminology": "reworded", "tests": "func TestF(t *testing.T) {\n  candidate := f\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{1, 2, 6, 24, 15} },\n     { actual: candidate(7), expected: []int{1, 2, 6, 24, 15, 720, 28} },\n     { actual: candidate(1), expected: []int{1} },\n     { actual: candidate(3), expected: []int{1, 2, 6} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage f_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Implement the function f that takes n as a parameter,\n// and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f(5)\n// []int{1, 2, 6, 24, 15}\n\nfunc factorial(num int) int {\n    if num == 0 {\n        return 1\n    }\n    result := 1\n    for i := 1; i <= num; i++ {\n        result *= i\n    }\n    return result\n}\n\nfunc sum(num int) int {\n    result := 0\n    for i := 1; i <= num; i++ {\n        result += i\n    }\n    return result\n}\n\nfunc f(n int) []int {\n    result := make([]int, n)\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            result[i-1] = factorial(i)\n        } else {\n            result[i-1] = sum(i)\n        }\n    }\n    return result\n}\n\nfunc TestF(t *testing.T) {\n    cases := []struct {\n        input  int\n        expect []int\n    }{\n        {5, []int{1, 2, 6, 24, 15}},\n        {1, []int{1}},\n        {0, []int{}},\n        {3, []int{1, 2, 6}},\n        {4, []int{1, 2, 6, 24}},\n    }\n\n    for _, c := range cases {\n        got := f(c.input)\n        for i, v := range got {\n            if v != c.expect[i] {\n                t.Errorf(\"f(%d) == %v, expect %v\", c.input, got, c.expect)\n                break\n            }\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(f(5))  // Output: [1 2 6 24 15]\n}\n```", "task_id": "HumanEval_106_f"}
{"name": "HumanEval_107_even_odd_palindrome", "language": "go_test.go", "prompt": "package even_odd_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a list that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome(3)\n// []interface{}{1, 2}\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome(12)\n// []interface{}{4, 6}\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned list has the number of even and odd integer palindromes respectively.\nfunc even_odd_palindrome(n int) []interface{} {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_107_even_odd_palindrome.py", "prompt_terminology": "reworded", "tests": "func TestEven_Odd_Palindrome(t *testing.T) {\n  candidate := even_odd_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(123), expected: []interface{}{8, 13} },\n     { actual: candidate(12), expected: []interface{}{4, 6} },\n     { actual: candidate(3), expected: []interface{}{1, 2} },\n     { actual: candidate(63), expected: []interface{}{6, 8} },\n     { actual: candidate(25), expected: []interface{}{5, 6} },\n     { actual: candidate(19), expected: []interface{}{4, 6} },\n     { actual: candidate(9), expected: []interface{}{4, 5} },\n     { actual: candidate(1), expected: []interface{}{0, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage even_odd_palindrome_test\n\nimport (\n    \"strconv\"\n    \"testing\"\n    \"fmt\"\n)\n\n// Function to check if a number is a palindrome.\nfunc isPalindrome(num int) bool {\n    str := strconv.Itoa(num)\n    length := len(str)\n    for i := 0; i < length/2; i++ {\n        if str[i] != str[length-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\n// Given a positive integer n, return a list that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\nfunc even_odd_palindrome(n int) []interface{} {\n    evenCount := 0\n    oddCount := 0\n\n    for i := 1; i <= n; i++ {\n        if isPalindrome(i) {\n            if i%2 == 0 {\n                evenCount++\n            } else {\n                oddCount++\n            }\n        }\n    }\n\n    return []interface{}{evenCount, oddCount}\n}\n\n// Unit test for the even_odd_palindrome function.\nfunc TestEvenOddPalindrome(t *testing.T) {\n    testCases := []struct {\n        input    int\n        expected []interface{}\n    }{\n        {3, []interface{}{1, 2}},\n        {12, []interface{}{4, 6}},\n        {10, []interface{}{4, 5}},\n        {1, []interface{}{0, 1}},\n        {22, []interface{}{6, 10}},\n    }\n\n    for _, tc := range testCases {\n        result := even_odd_palindrome(tc.input)\n        if fmt.Sprintf(\"%v\", result) != fmt.Sprintf(\"%v\", tc.expected) {\n            t.Errorf(\"Expected %v, but got %v for input %d\", tc.expected, result, tc.input)\n        }\n    }\n}\n```", "task_id": "HumanEval_107_even_odd_palindrome"}
{"name": "HumanEval_108_count_nums", "language": "go_test.go", "prompt": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_108_count_nums.py", "prompt_terminology": "reworded", "tests": "func TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strconv\"\n)\n\n// Function to calculate the sum of digits of an integer\nfunc sumOfDigits(n int) int {\n    sum := 0\n    str := strconv.Itoa(n)\n    for _, r := range str {\n        if r == '-' {\n            continue\n        }\n        digit, _ := strconv.Atoi(string(r))\n        sum += digit\n    }\n    return sum\n}\n\n// Function to count the number of integers in the list with sum of digits > 0\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, num := range arr {\n        if sumOfDigits(num) > 0 {\n            count++\n        }\n    }\n    return count\n}\n\n// Unit tests\nfunc TestCountNums(t *testing.T) {\n    tests := []struct {\n        input  []int\n        output int\n    }{\n        {[]int{}, 0},\n        {[]int{-1, 11, -11}, 1},\n        {[]int{1, 1, 2}, 3},\n        {[]int{-123, 222, 0}, 2},\n        {[]int{-456, -789, 100}, 3},\n    }\n\n    for _, test := range tests {\n        result := count_nums(test.input)\n        if result != test.output {\n            t.Errorf(\"count_nums(%v) = %d; expected %d\", test.input, result, test.output)\n        }\n    }\n}\n\n// Running the unit tests\nfunc main() {\n    fmt.Println(\"Running tests...\")\n    TestCountNums(nil)\n    fmt.Println(\"Tests completed!\")\n}\n```", "task_id": "HumanEval_108_count_nums"}
{"name": "HumanEval_109_move_one_ball", "language": "go_test.go", "prompt": "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the list will be randomly ordered. Your task is to determine if\n// it is possible to get a list sorted in non-decreasing order by performing \n// the following operation on the given list:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the list by one\n// position in the right direction. The last element of the list will be moved to\n// the starting position in the list i.e. 0th index. \n// If it is possible to obtain the sorted list by performing the above operation\n// then return true else return false.\n// If the given list is empty then return true.\n// Note: The given list is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing order for the given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr []int) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_109_move_one_ball.py", "prompt_terminology": "reworded", "tests": "func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage move_one_ball_test\n\nimport (\n    \"testing\"\n)\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the list will be randomly ordered. Your task is to determine if\n// it is possible to get a list sorted in non-decreasing order by performing \n// the following operation on the given list:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the list by one\n// position in the right direction. The last element of the list will be moved to\n// the starting position in the list i.e. 0th index. \n// If it is possible to obtain the sorted list by performing the above operation\n// then return true else return false.\n// If the given list is empty then return true.\n// Note: The given list is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n// Explanation: By performing 2 right shift operations, non-decreasing order can\n// be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n// false\n// Explanation: It is not possible to get non-decreasing order for the given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr []int) bool {\n    n := len(arr)\n    if n == 0 {\n        return true\n    }\n    \n    count := 0\n    for i := 0; i < n; i++ {\n        if arr[i] > arr[(i+1)%n] {\n            count++\n        }\n    }\n    \n    return count <= 1\n}\n\n// Test function for the move_one_ball function\nfunc TestMoveOneBall(t *testing.T) {\n    cases := []struct {\n        input    []int\n        expected bool\n    }{\n        {[]int{3, 4, 5, 1, 2}, true},\n        {[]int{3, 5, 4, 1, 2}, false},\n        {[]int{1, 2, 3, 4, 5}, true},\n        {[]int{5, 1, 2, 3, 4}, true},\n        {[]int{2, 3, 4, 5, 1}, true},\n        {[]int{}, true},\n    }\n\n    for _, c := range cases {\n        got := move_one_ball(c.input)\n        if got != c.expected {\n            t.Errorf(\"move_one_ball(%v) == %v, expected %v\", c.input, got, c.expected)\n        }\n    }\n}\n```", "task_id": "HumanEval_109_move_one_ball"}
{"name": "HumanEval_110_exchange", "language": "go_test.go", "prompt": "package exchange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// In this problem, you will implement a function that takes two lists of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a list of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange([]int{1, 2, 3, 4}, []int{1, 2, 3, 4})\n// \"YES\"\n// >>> exchange([]int{1, 2, 3, 4}, []int{1, 5, 3, 4})\n// \"NO\"\n// It is assumed that the input lists will be non-empty.\nfunc exchange(lst1 []int, lst2 []int) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_110_exchange.py", "prompt_terminology": "reworded", "tests": "func TestExchange(t *testing.T) {\n  candidate := exchange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4}, []int{1, 2, 3, 4}), expected: \"YES\" },\n     { actual: candidate([]int{1, 2, 3, 4}, []int{1, 5, 3, 4}), expected: \"NO\" },\n     { actual: candidate([]int{1, 2, 3, 4}, []int{2, 1, 4, 3}), expected: \"YES\" },\n     { actual: candidate([]int{5, 7, 3}, []int{2, 6, 4}), expected: \"YES\" },\n     { actual: candidate([]int{5, 7, 3}, []int{2, 6, 3}), expected: \"NO\" },\n     { actual: candidate([]int{3, 2, 6, 1, 8, 9}, []int{3, 5, 5, 1, 1, 1}), expected: \"NO\" },\n     { actual: candidate([]int{100, 200}, []int{200, 200}), expected: \"YES\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage exchange_test\n\nimport (\n    \"testing\"\n)\n\n// exchange determines whether it is possible to exchange elements between lst1 and lst2 \n// to make lst1 contain only even numbers.\nfunc exchange(lst1 []int, lst2 []int) string {\n    containsEven := func(lst []int) bool {\n        for _, num := range lst {\n            if num%2 == 0 {\n                return true\n            }\n        }\n        return false\n    }\n    \n    // Check if lst2 contains any even numbers\n    if !containsEven(lst2) {\n        return \"NO\"\n    }\n\n    // Iterate over lst1, if there's an odd number, we attempt to swap it out\n    for _, num := range lst1 {\n        if num%2 != 0 {\n            if !containsEven(lst2) {\n                return \"NO\"\n            }\n        }\n    }\n    \n    return \"YES\"\n}\n\nfunc TestExchange(t *testing.T) {\n    testCases := []struct {\n        input1   []int\n        input2   []int\n        expected string\n    }{\n        {[]int{1, 2, 3, 4}, []int{1, 2, 3, 4}, \"YES\"},\n        {[]int{1, 2, 3, 4}, []int{1, 5, 3, 4}, \"NO\"},\n        {[]int{2, 4, 6}, []int{1, 3, 5}, \"YES\"},\n        {[]int{1, 3, 5}, []int{1, 3, 5}, \"NO\"},\n        {[]int{1, 1, 1}, []int{2, 4, 6}, \"YES\"},\n    }\n\n    for _, tc := range testCases {\n        result := exchange(tc.input1, tc.input2)\n        if result != tc.expected {\n            t.Errorf(\"For inputs %v and %v, expected %s but got %s\", tc.input1, tc.input2, tc.expected, result)\n        }\n    }\n}\n```\n\nThis completes the function `exchange` along with a set of unit tests in the `TestExchange` function. The test cases are carefully selected to cover different scenarios where exchanges might or might not be needed. The implementation relies on checking if the second list contains even numbers because it would not be possible to replace odd numbers in the first list otherwise.", "task_id": "HumanEval_110_exchange"}
{"name": "HumanEval_111_histogram", "language": "go_test.go", "prompt": "package histogram_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram(\"a b c\")\n// map[string]int{\"a\": 1, \"b\": 1, \"c\": 1}\n// >>> histogram(\"a b b a\")\n// map[string]int{\"a\": 2, \"b\": 2}\n// >>> histogram(\"a b c a b\")\n// map[string]int{\"a\": 2, \"b\": 2}\n// >>> histogram(\"b b b b a\")\n// map[string]int{\"b\": 4}\n// >>> histogram(\"\")\n// map[string]int{}\nfunc histogram(test string) map[string]int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_111_histogram.py", "prompt_terminology": "reworded", "tests": "func TestHistogram(t *testing.T) {\n  candidate := histogram\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"a b b a\"), expected: map[string]int{\"a\": 2, \"b\": 2} },\n     { actual: candidate(\"a b c a b\"), expected: map[string]int{\"a\": 2, \"b\": 2} },\n     { actual: candidate(\"a b c d g\"), expected: map[string]int{\"a\": 1, \"b\": 1, \"c\": 1, \"d\": 1, \"g\": 1} },\n     { actual: candidate(\"r t g\"), expected: map[string]int{\"r\": 1, \"t\": 1, \"g\": 1} },\n     { actual: candidate(\"b b b b a\"), expected: map[string]int{\"b\": 4} },\n     { actual: candidate(\"r t g\"), expected: map[string]int{\"r\": 1, \"t\": 1, \"g\": 1} },\n     { actual: candidate(\"\"), expected: map[string]int{} },\n     { actual: candidate(\"a\"), expected: map[string]int{\"a\": 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage histogram_test\n\nimport (\n    \"strings\"\n    \"testing\"\n    \"fmt\"\n)\n\nfunc histogram(test string) map[string]int {\n    counts := make(map[string]int)\n    letters := strings.Fields(test) // Split the string by spaces and get the letters\n    for _, letter := range letters {\n        counts[letter]++ // Count occurrences\n    }\n\n    if len(counts) == 0 {\n        return counts // Return immediately if no elements\n    }\n\n    maxCount := 0\n    for _, count := range counts {\n        if count > maxCount {\n            maxCount = count // Identify the maximum count\n        }\n    }\n\n    result := make(map[string]int)\n    for letter, count := range counts {\n        if count == maxCount {\n            result[letter] = count // Include only letters with the maximum count\n        }\n    }\n\n    return result\n}\n\nfunc TestHistogram(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected map[string]int\n    }{\n        {\"a b c\", map[string]int{\"a\": 1, \"b\": 1, \"c\": 1}},\n        {\"a b b a\", map[string]int{\"a\": 2, \"b\": 2}},\n        {\"a b c a b\", map[string]int{\"a\": 2, \"b\": 2}},\n        {\"b b b b a\", map[string]int{\"b\": 4}},\n        {\"\", map[string]int{}},\n    }\n\n    for _, test := range tests {\n        result := histogram(test.input)\n        if !equal(result, test.expected) {\n            t.Errorf(\"For input '%s', expected %v but got %v\", test.input, test.expected, result)\n        }\n    }\n}\n\n// Helper function to compare two maps\nfunc equal(a, b map[string]int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for k, v := range a {\n        if b[k] != v {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    // Running the test function to output results\n    TestHistogram(nil)\n}\n```", "task_id": "HumanEval_111_histogram"}
{"name": "HumanEval_112_reverse_delete", "language": "go_test.go", "prompt": "package reverse_delete_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a list containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete(\"abcde\", \"ae\")\n// []interface{}{\"bcd\", false}\n// >>> reverse_delete(\"abcdef\", \"b\")\n// []interface{}{\"acdef\", false}\n// >>> reverse_delete(\"abcdedcba\", \"ab\")\n// []interface{}{\"cdedc\", true}\nfunc reverse_delete(s string, c string) []interface{} {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_112_reverse_delete.py", "prompt_terminology": "reworded", "tests": "func TestReverse_Delete(t *testing.T) {\n  candidate := reverse_delete\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"abcde\", \"ae\"), expected: []interface{}{\"bcd\", false} },\n     { actual: candidate(\"abcdef\", \"b\"), expected: []interface{}{\"acdef\", false} },\n     { actual: candidate(\"abcdedcba\", \"ab\"), expected: []interface{}{\"cdedc\", true} },\n     { actual: candidate(\"dwik\", \"w\"), expected: []interface{}{\"dik\", false} },\n     { actual: candidate(\"a\", \"a\"), expected: []interface{}{\"\", true} },\n     { actual: candidate(\"abcdedcba\", \"\"), expected: []interface{}{\"abcdedcba\", true} },\n     { actual: candidate(\"abcdedcba\", \"v\"), expected: []interface{}{\"abcdedcba\", true} },\n     { actual: candidate(\"vabba\", \"v\"), expected: []interface{}{\"abba\", true} },\n     { actual: candidate(\"mamma\", \"mia\"), expected: []interface{}{\"\", true} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage reverse_delete_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc reverse_delete(s string, c string) []interface{} {\n    // Create a map to store characters to be deleted for quick lookup\n    deleteMap := make(map[rune]bool)\n    for _, char := range c {\n        deleteMap[char] = true\n    }\n\n    // Remove characters in s that are in deleteMap\n    filteredString := \"\"\n    for _, char := range s {\n        if !deleteMap[char] {\n            filteredString += string(char)\n        }\n    }\n\n    // Check if the filtered string is a palindrome\n    isPalindrome := true\n    length := len(filteredString)\n    for i := 0; i < length/2; i++ {\n        if filteredString[i] != filteredString[length-i-1] {\n            isPalindrome = false\n            break\n        }\n    }\n\n    // Return the result as per the requirements\n    return []interface{}{filteredString, isPalindrome}\n}\n\nfunc TestReverseDelete(t *testing.T) {\n    tests := []struct{\n        inputString string\n        inputChars string\n        expected []interface{}\n    }{\n        {\"abcde\", \"ae\", []interface{}{\"bcd\", false}},\n        {\"abcdef\", \"b\", []interface{}{\"acdef\", false}},\n        {\"abcdedcba\", \"ab\", []interface{}{\"cdedc\", true}},\n    }\n\n    for _, test := range tests {\n        result := reverse_delete(test.inputString, test.inputChars)\n        if fmt.Sprintf(\"%v\", result) != fmt.Sprintf(\"%v\", test.expected) {\n            t.Errorf(\"reverse_delete(%q, %q) = %v; want %v\", test.inputString, test.inputChars, result, test.expected)\n        }\n    }\n}\n```", "task_id": "HumanEval_112_reverse_delete"}
{"name": "HumanEval_113_odd_count", "language": "go_test.go", "prompt": "package odd_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of strings, where each string consists of only digits, return a list.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count([]string{\"1234567\"})\n// []string{\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}\n// >>> odd_count([]string{\"3\", \"11111111\"})\n// []string{\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}\nfunc odd_count(lst []string) []string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_113_odd_count.py", "prompt_terminology": "reworded", "tests": "func TestOdd_Count(t *testing.T) {\n  candidate := odd_count\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"1234567\"}), expected: []string{\"the number of odd elements 4n the str4ng 4 of the 4nput.\"} },\n     { actual: candidate([]string{\"3\", \"11111111\"}), expected: []string{\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"} },\n     { actual: candidate([]string{\"271\", \"137\", \"314\"}), expected: []string{\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage odd_count_test\n\nimport (\n    \"strconv\"\n    \"strings\"\n    \"testing\"\n    \"fmt\"\n)\n\nfunc odd_count(lst []string) []string {\n    result := make([]string, len(lst))\n    \n    for i, str := range lst {\n        oddCount := 0\n        for _, ch := range str {\n            if ch % 2 != 0 {\n                oddCount++\n            }\n        }\n        oddStr := strconv.Itoa(oddCount)\n        result[i] = fmt.Sprintf(\"the number of odd elements %sn the str%sng %s of the %snput.\", oddStr, oddStr, oddStr, oddStr)\n    }\n    \n    return result\n}\n\nfunc TestOddCount(t *testing.T) {\n    inputs := [][]string{\n        {\"1234567\"},\n        {\"3\", \"11111111\"},\n    }\n    expected := [][]string{\n        {\"the number of odd elements 4n the str4ng 4 of the 4nput.\"},\n        {\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"},\n    }\n    for i, input := range inputs {\n        got := odd_count(input)\n        if !equal(got, expected[i]) {\n            t.Errorf(\"odd_count(%v) = %v; want %v\", input, got, expected[i])\n        }\n    }\n}\n\nfunc equal(a, b []string) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n```\n\nThis code defines the `odd_count` function according to the requirements specified in the docstring. It also includes a test function `TestOddCount` to check the correctness of the implementation. The `equal` function is used to compare the expected output with the result.", "task_id": "HumanEval_113_odd_count"}
{"name": "HumanEval_114_minSubArraySum", "language": "go_test.go", "prompt": "package minSubArraySum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of integers nums, find the minimum sum of any non-empty sub-list\n// of nums.\n// Example\n// >>> minSubArraySum([]int{2, 3, 4, 1, 2, 4})\n// 1\n// >>> minSubArraySum([]int{-1, -2, -3})\n// -6\nfunc minSubArraySum(nums []int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_114_minSubArraySum.py", "prompt_terminology": "reworded", "tests": "func TestMinsubarraysum(t *testing.T) {\n  candidate := minSubArraySum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2, 3, 4, 1, 2, 4}), expected: 1 },\n     { actual: candidate([]int{-1, -2, -3}), expected: -6 },\n     { actual: candidate([]int{-1, -2, -3, 2, -10}), expected: -14 },\n     { actual: candidate([]int{-9999999999999999}), expected: -9999999999999999 },\n     { actual: candidate([]int{0, 10, 20, 1000000}), expected: 0 },\n     { actual: candidate([]int{-1, -2, -3, 10, -5}), expected: -6 },\n     { actual: candidate([]int{100, -1, -2, -3, 10, -5}), expected: -6 },\n     { actual: candidate([]int{10, 11, 13, 8, 3, 4}), expected: 3 },\n     { actual: candidate([]int{100, -33, 32, -1, 0, -2}), expected: -33 },\n     { actual: candidate([]int{-10}), expected: -10 },\n     { actual: candidate([]int{7}), expected: 7 },\n     { actual: candidate([]int{1, -1}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage minSubArraySum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\n// Given a list of integers nums, find the minimum sum of any non-empty sub-list\n// of nums.\n// Example\n// >>> minSubArraySum([]int{2, 3, 4, 1, 2, 4})\n// 1\n// >>> minSubArraySum([]int{-1, -2, -3})\n// -6\nfunc minSubArraySum(nums []int) int {\n    if len(nums) == 0 {\n        return 0\n    }\n\n    minSum := math.MaxInt64\n    currentSum := 0\n\n    for _, num := range nums {\n        currentSum += num\n        if currentSum < minSum {\n            minSum = currentSum\n        }\n        if currentSum > 0 {\n            currentSum = 0\n        }\n    }\n\n    return minSum\n}\n\nfunc TestMinSubArraySum(t *testing.T) {\n    cases := []struct {\n        nums     []int\n        expected int\n    }{\n        {[]int{2, 3, 4, 1, 2, 4}, 1},\n        {[]int{-1, -2, -3}, -6},\n        {[]int{2, 1, -6, 4, -2, -1, 2}, -6},\n        {[]int{1, 2, 3, -2, -5, 4}, -5},\n    }\n\n    for _, c := range cases {\n        result := minSubArraySum(c.nums)\n        if result != c.expected {\n            t.Errorf(\"minSubArraySum(%v) == %d, expected %d\", c.nums, result, c.expected)\n        } else {\n            fmt.Printf(\"minSubArraySum(%v) == %d, as expected\\n\", c.nums, result)\n        }\n    }\n}\n```\n\nThis code implements the `minSubArraySum` function to find the minimum sum of any non-empty sub-list of integers in the `nums` slice. It also includes test cases to verify the correctness of the function implementation using the `testing` package.", "task_id": "HumanEval_114_minSubArraySum"}
{"name": "HumanEval_115_max_fill", "language": "go_test.go", "prompt": "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunc max_fill(grid [][]int, capacity int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_115_max_fill.py", "prompt_terminology": "reworded", "tests": "func TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_fill(grid [][]int, capacity int) int {\n    bucketLowers := 0\n\n    for _, row := range grid {\n        waterUnits := 0\n        for _, cell := range row {\n            if cell == 1 {\n                waterUnits++\n            }\n        }\n        bucketLowers += (waterUnits + capacity - 1) / capacity\n    }\n\n    return bucketLowers\n}\n\nfunc TestMaxFill(t *testing.T) {\n    testCases := []struct {\n        grid     [][]int\n        capacity int\n        expected int\n    }{\n        {[][]int{{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1, 6},\n        {[][]int{{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2, 5},\n        {[][]int{{0, 0, 0}, {0, 0, 0}}, 5, 0},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"grid: %v, capacity: %d\", tc.grid, tc.capacity), func(t *testing.T) {\n            result := max_fill(tc.grid, tc.capacity)\n            if result != tc.expected {\n                t.Errorf(\"expected %d, but got %d\", tc.expected, result)\n            }\n        })\n    }\n}\n```\n\nYou can run the `TestMaxFill` function to verify the correctness of the `max_fill` logic with the provided test cases. This implementation should meet the requirements described in the docstring.", "task_id": "HumanEval_115_max_fill"}
{"name": "HumanEval_116_sort_array", "language": "go_test.go", "prompt": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// In this Kata, you have to sort a list of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array([]int{1, 5, 2, 3, 4})\n// []int{1, 2, 3, 4, 5}\n// >>> sort_array([]int{-2, -3, -4, -5, -6})\n// []int{-6, -5, -4, -3, -2}\n// >>> sort_array([]int{1, 0, 2, 3, 4})\n// []int{0, 1, 2, 3, 4}\nfunc sort_array(arr []int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_116_sort_array.py", "prompt_terminology": "reworded", "tests": "func TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 5, 2, 3, 4}), expected: []int{1, 2, 4, 3, 5} },\n     { actual: candidate([]int{-2, -3, -4, -5, -6}), expected: []int{-4, -2, -6, -5, -3} },\n     { actual: candidate([]int{1, 0, 2, 3, 4}), expected: []int{0, 1, 2, 4, 3} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4}), expected: []int{2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77} },\n     { actual: candidate([]int{3, 6, 44, 12, 32, 5}), expected: []int{32, 3, 5, 6, 12, 44} },\n     { actual: candidate([]int{2, 4, 8, 16, 32}), expected: []int{2, 4, 8, 16, 32} },\n     { actual: candidate([]int{2, 4, 8, 16, 32}), expected: []int{2, 4, 8, 16, 32} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage sort_array_test\n\nimport (\n    \"sort\"\n    \"testing\"\n    \"fmt\"\n)\n\n// In this Kata, you have to sort a list of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array([]int{1, 5, 2, 3, 4})\n// []int{1, 2, 3, 4, 5}\n// >>> sort_array([]int{-2, -3, -4, -5, -6})\n// []int{-6, -5, -4, -3, -2}\n// >>> sort_array([]int{1, 0, 2, 3, 4})\n// []int{0, 1, 2, 3, 4}\nfunc sort_array(arr []int) []int {\n    // Custom comparator for sorting\n    sort.Slice(arr, func(i, j int) bool {\n        countOnes := func(n int) int {\n            count := 0\n            for n != 0 {\n                count += n & 1\n                n >>= 1\n            }\n            return count\n        }\n        \n        onesI := countOnes(arr[i])\n        onesJ := countOnes(arr[j])\n        \n        if onesI == onesJ {\n            return arr[i] < arr[j]\n        }\n        return onesI < onesJ\n    })\n    return arr\n}\n\nfunc TestSortArray(t *testing.T) {\n    tests := []struct {\n        input, expected []int\n    }{\n        {[]int{1, 5, 2, 3, 4}, []int{1, 2, 3, 4, 5}},\n        {[]int{-2, -3, -4, -5, -6}, []int{-6, -5, -4, -3, -2}},\n        {[]int{1, 0, 2, 3, 4}, []int{0, 1, 2, 3, 4}},\n    }\n\n    for _, test := range tests {\n        result := sort_array(test.input)\n        if fmt.Sprintf(\"%v\", result) != fmt.Sprintf(\"%v\", test.expected) {\n            t.Errorf(\"For input %v, expected %v, but got %v\", test.input, test.expected, result)\n        }\n    }\n}\n```", "task_id": "HumanEval_116_sort_array"}
{"name": "HumanEval_117_select_words", "language": "go_test.go", "prompt": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_117_select_words.py", "prompt_terminology": "reworded", "tests": "func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage select_words_test\n\nimport (\n    \"strings\"\n    \"testing\"\n    \"unicode\"\n)\n\n// Helper function to check if a character is a vowel\nfunc isVowel(c rune) bool {\n    vowels := \"aeiouAEIOU\"\n    return strings.ContainsRune(vowels, c)\n}\n\nfunc select_words(s string, n int) []string {\n    if s == \"\" {\n        return []string{}\n    }\n\n    words := strings.Fields(s) // Split the input string into words\n    result := []string{}\n\n    for _, word := range words {\n        consonantCount := 0\n        for _, char := range word {\n            if unicode.IsLetter(char) && !isVowel(char) {\n                consonantCount++\n            }\n        }\n        if consonantCount == n {\n            result = append(result, word)\n        }\n    }\n\n    return result\n}\n\nfunc TestSelectWords(t *testing.T) {\n    tests := []struct {\n        input string\n        n     int\n        want  []string\n    }{\n        {\"Mary had a little lamb\", 4, []string{\"little\"}},\n        {\"Mary had a little lamb\", 3, []string{\"Mary\", \"lamb\"}},\n        {\"simple white space\", 2, []string{}},\n        {\"Hello world\", 4, []string{\"world\"}},\n        {\"Uncle sam\", 3, []string{\"Uncle\"}},\n        {\"\", 3, []string{}},\n        {\"Alaska is cold\", 2, []string{\"cold\"}},\n    }\n\n    for _, tt := range tests {\n        got := select_words(tt.input, tt.n)\n        if len(got) != len(tt.want) {\n            t.Errorf(\"select_words(%q, %d) = %v; want %v\", tt.input, tt.n, got, tt.want)\n            continue\n        }\n        for i := range got {\n            if got[i] != tt.want[i] {\n                t.Errorf(\"select_words(%q, %d) = %v; want %v\", tt.input, tt.n, got, tt.want)\n                break\n            }\n        }\n    }\n}\n```", "task_id": "HumanEval_117_select_words"}
{"name": "HumanEval_118_get_closest_vowel", "language": "go_test.go", "prompt": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_118_get_closest_vowel.py", "prompt_terminology": "reworded", "tests": "func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc get_closest_vowel(word string) string {\n    vowels := \"aeiouAEIOU\"\n    length := len(word)\n    \n    for i := length - 2; i > 0; i-- {\n        if strings.ContainsRune(vowels, rune(word[i])) {\n            if !strings.ContainsRune(vowels, rune(word[i-1])) && !strings.ContainsRune(vowels, rune(word[i+1])) {\n                return string(word[i])\n            }\n        }\n    }\n\n    return \"\"\n}\n\nfunc TestGetClosestVowel(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected string\n    }{\n        {\"yogurt\", \"u\"},\n        {\"FULLLLLL\", \"U\"},\n        {\"quick\", \"\"},\n        {\"ab\", \"\"},\n        {\"Hippopotamus\", \"a\"},\n        {\"bIt\", \"I\"},\n        {\"easyWEEK\", \"\"},\n    }\n\n    for _, test := range tests {\n        result := get_closest_vowel(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input '%s', expected '%s' but got '%s'\", test.input, test.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(get_closest_vowel(\"yogurt\"))        // \"u\"\n    fmt.Println(get_closest_vowel(\"FULLLLLL\"))      // \"U\"\n    fmt.Println(get_closest_vowel(\"quick\"))         // \"\"\n    fmt.Println(get_closest_vowel(\"ab\"))            // \"\"\n    fmt.Println(get_closest_vowel(\"Hippopotamus\"))  // \"a\"\n    fmt.Println(get_closest_vowel(\"bIt\"))           // \"I\"\n    fmt.Println(get_closest_vowel(\"easyWEEK\"))      // \"\"\n}\n```", "task_id": "HumanEval_118_get_closest_vowel"}
{"name": "HumanEval_119_match_parens", "language": "go_test.go", "prompt": "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a list of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"No\"\nfunc match_parens(lst []string) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_119_match_parens.py", "prompt_terminology": "reworded", "tests": "func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc match_parens(lst []string) string {\n    // Helper function to check if a string has balanced parentheses\n    isBalanced := func(s string) bool {\n        counter := 0\n        for _, c := range s {\n            if c == '(' {\n                counter++\n            } else if c == ')' {\n                counter--\n            }\n            if counter < 0 {\n                return false\n            }\n        }\n        return counter == 0\n    }\n\n    // Try concatenating in both possible orders\n    combined1 := lst[0] + lst[1]\n    if isBalanced(combined1) {\n        return \"Yes\"\n    }\n\n    combined2 := lst[1] + lst[0]\n    if isBalanced(combined2) {\n        return \"Yes\"\n    }\n\n    // If neither order results in a balanced string\n    return \"No\"\n}\n\nfunc TestMatchParens(t *testing.T) {\n    testCases := []struct {\n        input    []string\n        expected string\n    }{\n        {[]string{\"()(\", \")\"}, \"Yes\"},\n        {[]string{\")\", \")\"}, \"No\"},\n        {[]string{\"(()\", \"())\"}, \"No\"},\n        {[]string{\"(\", \")\"}, \"Yes\"},\n        {[]string{\"(()(\", \"())\"}, \"Yes\"},\n        {[]string{\"\", \"\"}, \"Yes\"},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"%v\", tc.input), func(t *testing.T) {\n            result := match_parens(tc.input)\n            if result != tc.expected {\n                t.Errorf(\"Expected %v, but got %v\", tc.expected, result)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_119_match_parens"}
{"name": "HumanEval_120_maximum", "language": "go_test.go", "prompt": "package maximum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list arr of integers and a positive integer k, return a sorted list \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum([]int{-3, -4, 5}, 3)\n// []int{-4, -3, 5}\n// Example 2:\n// >>> maximum([]int{4, -4, 4}, 2)\n// []int{4, 4}\n// Example 3:\n// >>> maximum([]int{-3, 2, 1, 2, -1, -2, 1}, 1)\n// []int{2}\n// Note:\n// 1. The length of the list will be in the range of [1, 1000].\n// 2. The elements in the list will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nfunc maximum(arr []int, k int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_120_maximum.py", "prompt_terminology": "reworded", "tests": "func TestMaximum(t *testing.T) {\n  candidate := maximum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{-3, -4, 5}, 3), expected: []int{-4, -3, 5} },\n     { actual: candidate([]int{4, -4, 4}, 2), expected: []int{4, 4} },\n     { actual: candidate([]int{-3, 2, 1, 2, -1, -2, 1}, 1), expected: []int{2} },\n     { actual: candidate([]int{123, -123, 20, 0, 1, 2, -3}, 3), expected: []int{2, 20, 123} },\n     { actual: candidate([]int{-123, 20, 0, 1, 2, -3}, 4), expected: []int{0, 1, 2, 20} },\n     { actual: candidate([]int{5, 15, 0, 3, -13, -8, 0}, 7), expected: []int{-13, -8, 0, 0, 3, 5, 15} },\n     { actual: candidate([]int{-1, 0, 2, 5, 3, -10}, 2), expected: []int{3, 5} },\n     { actual: candidate([]int{1, 0, 5, -7}, 1), expected: []int{5} },\n     { actual: candidate([]int{4, -4}, 2), expected: []int{-4, 4} },\n     { actual: candidate([]int{-10, 10}, 2), expected: []int{-10, 10} },\n     { actual: candidate([]int{1, 2, 3, -23, 243, -400, 0}, 0), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage maximum_test\n\nimport (\n    \"sort\"\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list arr of integers and a positive integer k, return a sorted list \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum([]int{-3, -4, 5}, 3)\n// []int{-4, -3, 5}\n// Example 2:\n// >>> maximum([]int{4, -4, 4}, 2)\n// []int{4, 4}\n// Example 3:\n// >>> maximum([]int{-3, 2, 1, 2, -1, -2, 1}, 1)\n// []int{2}\n// Note:\n// 1. The length of the list will be in the range of [1, 1000].\n// 2. The elements in the list will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nfunc maximum(arr []int, k int) []int {\n    if k == 0 {\n        return []int{}\n    }\n    // Sort the array in descending order\n    sort.Slice(arr, func(i, j int) bool {\n        return arr[i] > arr[j]\n    })\n    // Get the first k elements\n    result := arr[:k]\n    // Sort the result in ascending order as required\n    sort.Ints(result)\n    return result\n}\n\nfunc TestMaximum(t *testing.T) {\n    cases := []struct{\n        arr []int\n        k int\n        expected []int\n    }{\n        {[]int{-3, -4, 5}, 3, []int{-4, -3, 5}},\n        {[]int{4, -4, 4}, 2, []int{4, 4}},\n        {[]int{-3, 2, 1, 2, -1, -2, 1}, 1, []int{2}},\n        {[]int{1, 2, 3, 4, 5}, 0, []int{}},\n        {[]int{2, 2, 2}, 2, []int{2, 2}},\n    }\n\n    for _, c := range cases {\n        got := maximum(c.arr, c.k)\n        if len(got) != len(c.expected) {\n            t.Errorf(\"maximum(%v, %d) = %v; expected %v\", c.arr, c.k, got, c.expected)\n        }\n        for i, val := range got {\n            if val != c.expected[i] {\n                t.Errorf(\"maximum(%v, %d) = %v; expected %v\", c.arr, c.k, got, c.expected)\n                break\n            }\n        }\n    }\n}\n```", "task_id": "HumanEval_120_maximum"}
{"name": "HumanEval_121_solution", "language": "go_test.go", "prompt": "package solution_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution([]int{5, 8, 7, 1})\n// 12\n// >>> solution([]int{3, 3, 3, 3, 3})\n// 9\n// >>> solution([]int{30, 13, 24, 321})\n// 0\nfunc solution(lst []int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_121_solution.py", "prompt_terminology": "reworded", "tests": "func TestSolution(t *testing.T) {\n  candidate := solution\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 8, 7, 1}), expected: 12 },\n     { actual: candidate([]int{3, 3, 3, 3, 3}), expected: 9 },\n     { actual: candidate([]int{30, 13, 24, 321}), expected: 0 },\n     { actual: candidate([]int{5, 9}), expected: 5 },\n     { actual: candidate([]int{2, 4, 8}), expected: 0 },\n     { actual: candidate([]int{30, 13, 23, 32}), expected: 23 },\n     { actual: candidate([]int{3, 13, 2, 9}), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage solution_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution([]int{5, 8, 7, 1})\n// 12\n// >>> solution([]int{3, 3, 3, 3, 3})\n// 9\n// >>> solution([]int{30, 13, 24, 321})\n// 0\nfunc solution(lst []int) int {\n    sum := 0\n    for i := 0; i < len(lst); i += 2 {\n        if lst[i]%2 != 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}\n\nfunc TestSolution(t *testing.T) {\n    tests := []struct{\n        input []int\n        expected int\n    }{\n        {[]int{5, 8, 7, 1}, 12},\n        {[]int{3, 3, 3, 3, 3}, 9},\n        {[]int{30, 13, 24, 321}, 0},\n        {[]int{1, 2, 3, 4, 5, 6}, 9}, // 1 + 3 + 5 = 9\n        {[]int{0, 0, 0, 0, 0}, 0},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"input: %v\", test.input), func(t *testing.T) {\n            got := solution(test.input)\n            if got != test.expected {\n                t.Errorf(\"expected %d but got %d\", test.expected, got)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_121_solution"}
{"name": "HumanEval_122_add_elements", "language": "go_test.go", "prompt": "package add_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a non-empty list of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4)\n// 24\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nfunc add_elements(arr []int, k int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_122_add_elements.py", "prompt_terminology": "reworded", "tests": "func TestAdd_Elements(t *testing.T) {\n  candidate := add_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 41, 57, 76, 87, 88, 99}, 3), expected: -4 },\n     { actual: candidate([]int{111, 121, 3, 4000, 5, 6}, 2), expected: 0 },\n     { actual: candidate([]int{11, 21, 3, 90, 5, 6, 7, 8, 9}, 4), expected: 125 },\n     { actual: candidate([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4), expected: 24 },\n     { actual: candidate([]int{1}, 1), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage add_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a non-empty list of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4)\n// 24\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nfunc add_elements(arr []int, k int) int {\n    sum := 0\n    for i := 0; i < k; i++ {\n        if arr[i] >= -99 && arr[i] <= 99 {\n            sum += arr[i]\n        }\n    }\n    return sum\n}\n\nfunc TestAddElements(t *testing.T) {\n    tests := []struct{\n        arr []int\n        k int\n        expected int\n    }{\n        {[]int{111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4, 24},\n        {[]int{50, 60, 70, 20, 110, 210}, 3, 180},\n        {[]int{10, 11, 12, 13, 14, 15}, 6, 75},\n        {[]int{100, 101, 102}, 2, 0},\n        {[]int{10, 20, 30, 40, 50}, 5, 150},\n        {[]int{-10, -20, -30, 100, 200, 300}, 4, -60},\n    }\n\n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"add_elements(%v, %d)\", tt.arr, tt.k), func(t *testing.T) {\n            result := add_elements(tt.arr, tt.k)\n            if result != tt.expected {\n                t.Errorf(\"expected %d, got %d\", tt.expected, result)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_122_add_elements"}
{"name": "HumanEval_123_get_odd_collatz", "language": "go_test.go", "prompt": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_123_get_odd_collatz.py", "prompt_terminology": "reworded", "tests": "func TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"sort\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n\tvar odds []int\n\tseen := make(map[int]bool)\n\n\tfor n != 1 {\n\t\tif n % 2 != 0 {\n\t\t\tif !seen[n] {\n\t\t\t\todds = append(odds, n)\n\t\t\t\tseen[n] = true\n\t\t\t}\n\t\t}\n\t\tif n % 2 == 0 {\n\t\t\tn = n / 2\n\t\t} else {\n\t\t\tn = 3 * n + 1\n\t\t}\n\t}\n\n\tif !seen[1] {\n\t\todds = append(odds, 1)\n\t}\n\n\tsort.Ints(odds)\n\treturn odds\n}\n\n// Tests for get_odd_collatz\nfunc TestGetOddCollatz(t *testing.T) {\n\ttests := []struct {\n\t\tinput int\n\t\texpected []int\n\t}{\n\t\t{5, []int{1, 5}},\n\t\t{6, []int{1, 5}},\n\t\t{7, []int{1, 7}},\n\t\t{1, []int{1}},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Input:%d\", test.input), func(t *testing.T) {\n\t\t\tresult := get_odd_collatz(test.input)\n\t\t\tfor i, v := range result {\n\t\t\t\tif v != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"For input %d, expected %v but got %v\", test.input, test.expected, result)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n```", "task_id": "HumanEval_123_get_odd_collatz"}
{"name": "HumanEval_124_valid_date", "language": "go_test.go", "prompt": "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_124_valid_date.py", "prompt_terminology": "reworded", "tests": "func TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage valid_date_test\n\nimport (\n    \"fmt\"\n    \"strconv\"\n    \"strings\"\n    \"testing\"\n)\n\n// Function to validate a given date string according to the specified rules\nfunc valid_date(date string) bool {\n    // Check if the date string is empty\n    if date == \"\" {\n        return false\n    }\n\n    // Split the date string by \"-\"\n    parts := strings.Split(date, \"-\")\n    if len(parts) != 3 {\n        return false\n    }\n\n    // Convert the parts to integers\n    month, err1 := strconv.Atoi(parts[0])\n    day, err2 := strconv.Atoi(parts[1])\n    year, err3 := strconv.Atoi(parts[2])\n\n    // Check if any conversion failed\n    if err1 != nil || err2 != nil || err3 != nil {\n        return false\n    }\n\n    // Rule 3: The month should not be less than 1 or higher than 12\n    if month < 1 || month > 12 {\n        return false\n    }\n\n    // Rule 2: Validate the number of days in the month\n    switch month {\n    case 1, 3, 5, 7, 8, 10, 12:\n        if day < 1 || day > 31 {\n            return false\n        }\n    case 4, 6, 9, 11:\n        if day < 1 || day > 30 {\n            return false\n        }\n    case 2:\n        if day < 1 || day > 29 {\n            return false\n        }\n    }\n\n    // If all checks passed, the date is valid\n    return true\n}\n\nfunc TestValidDate(t *testing.T) {\n    tests := []struct {\n        date string\n        want bool\n    }{\n        {\"03-11-2000\", true},\n        {\"15-01-2012\", false},\n        {\"04-0-2040\", false},\n        {\"06-04-2020\", true},\n        {\"06/04/2020\", false},\n        {\"\", false},\n        {\"02-29-2020\", true},\n        {\"02-30-2020\", false},\n        {\"13-01-2020\", false},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"date=%s\", test.date), func(t *testing.T) {\n            got := valid_date(test.date)\n            if got != test.want {\n                t.Errorf(\"valid_date(%q) = %v; want %v\", test.date, got, test.want)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_124_valid_date"}
{"name": "HumanEval_126_is_sorted", "language": "go_test.go", "prompt": "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of numbers, return whether or not they are sorted\n// in ascending order. If list has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n// true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1, 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1, 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n// true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst []int) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_126_is_sorted.py", "prompt_terminology": "reworded", "tests": "func TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_sorted(lst []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    \n    duplicates := make(map[int]int)\n    \n    for i := 0; i < len(lst)-1; i++ {\n        if lst[i] > lst[i+1] {\n            return false\n        }\n        duplicates[lst[i]]++\n        if duplicates[lst[i]] > 2 {\n            return false\n        }\n    }\n    // Check last element for duplicates\n    duplicates[lst[len(lst)-1]]++\n    if duplicates[lst[len(lst)-1]] > 2 {\n        return false\n    }\n\n    return true\n}\n\nfunc TestIsSorted(t *testing.T) {\n    tests := []struct {\n        input    []int\n        expected bool\n    }{\n        {[]int{5}, true},\n        {[]int{1, 2, 3, 4, 5}, true},\n        {[]int{1, 3, 2, 4, 5}, false},\n        {[]int{1, 2, 3, 4, 5, 6}, true},\n        {[]int{1, 2, 3, 4, 5, 6, 7}, true},\n        {[]int{1, 3, 2, 4, 5, 6, 7}, false},\n        {[]int{1, 2, 2, 3, 3, 4}, true},\n        {[]int{1, 2, 2, 2, 3, 4}, false},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%v\", test.input), func(t *testing.T) {\n            result := is_sorted(test.input)\n            if result != test.expected {\n                t.Errorf(\"expected %v, but got %v\", test.expected, result)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_126_is_sorted"}
{"name": "HumanEval_127_intersection", "language": "go_test.go", "prompt": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_127_intersection.py", "prompt_terminology": "reworded", "tests": "func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\n// Checks if a number is prime.\nfunc isPrime(num int) bool {\n    if num <= 1 {\n        return false\n    }\n    if num == 2 {\n        return true\n    }\n    for i := 2; i <= int(math.Sqrt(float64(num))); i++ {\n        if num % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\n// Determines the length of intersection of the two intervals.\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n\n    // Determine the range of intersection\n    startIntersection := max(start1, start2)\n    endIntersection := min(end1, end2)\n\n    // If the intervals don't intersect\n    if startIntersection > endIntersection {\n        return \"NO\"\n    }\n\n    // Calculate the intersection length\n    intersectionLength := endIntersection - startIntersection + 1\n\n    // Determine if the intersection length is a prime number\n    if isPrime(intersectionLength) {\n        return \"YES\"\n    } else {\n        return \"NO\"\n    }\n}\n\n// Helper function to return max of two integers.\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n\n// Helper function to return min of two integers.\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n\nfunc TestIntersection(t *testing.T) {\n    samples := []struct {\n        interval1   []interface{}\n        interval2   []interface{}\n        expected    string\n    }{\n        {[]interface{}{1, 2}, []interface{}{2, 3}, \"NO\"},\n        {[]interface{}{-1, 1}, []interface{}{0, 4}, \"NO\"},\n        {[]interface{}{-3, -1}, []interface{}{-5, 5}, \"YES\"},\n    }\n\n    for _, sample := range samples {\n        result := intersection(sample.interval1, sample.interval2)\n        if result != sample.expected {\n            t.Errorf(\"For intervals %v and %v, expected %v but got %v\", sample.interval1, sample.interval2, sample.expected, result)\n        } else {\n            fmt.Printf(\"For intervals %v and %v, got the correct result: %v\\n\", sample.interval1, sample.interval2, result)\n        }\n    }\n}\n\n```", "task_id": "HumanEval_127_intersection"}
{"name": "HumanEval_129_minPath", "language": "go_test.go", "prompt": "package minPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered lists of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered list of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}, 3)\n// []int{1, 2, 1}\n// >>> minPath([][]int{[]int{5, 9, 3}, []int{4, 1, 6}, []int{7, 8, 2}}, 1)\n// []int{1}\nfunc minPath(grid [][]int, k int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_129_minPath.py", "prompt_terminology": "reworded", "tests": "func TestMinpath(t *testing.T) {\n  candidate := minPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}, 3), expected: []int{1, 2, 1} },\n     { actual: candidate([][]int{[]int{5, 9, 3}, []int{4, 1, 6}, []int{7, 8, 2}}, 1), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4}, []int{5, 6, 7, 8}, []int{9, 10, 11, 12}, []int{13, 14, 15, 16}}, 4), expected: []int{1, 2, 1, 2} },\n     { actual: candidate([][]int{[]int{6, 4, 13, 10}, []int{5, 7, 12, 1}, []int{3, 16, 11, 15}, []int{8, 14, 9, 2}}, 7), expected: []int{1, 10, 1, 10, 1, 10, 1} },\n     { actual: candidate([][]int{[]int{8, 14, 9, 2}, []int{6, 4, 13, 15}, []int{5, 7, 1, 12}, []int{3, 10, 11, 16}}, 5), expected: []int{1, 7, 1, 7, 1} },\n     { actual: candidate([][]int{[]int{11, 8, 7, 2}, []int{5, 16, 14, 4}, []int{9, 3, 15, 6}, []int{12, 13, 10, 1}}, 9), expected: []int{1, 6, 1, 6, 1, 6, 1, 6, 1} },\n     { actual: candidate([][]int{[]int{12, 13, 10, 1}, []int{9, 3, 15, 6}, []int{5, 16, 14, 4}, []int{11, 8, 7, 2}}, 12), expected: []int{1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6} },\n     { actual: candidate([][]int{[]int{2, 7, 4}, []int{3, 1, 5}, []int{6, 8, 9}}, 8), expected: []int{1, 3, 1, 3, 1, 3, 1, 3} },\n     { actual: candidate([][]int{[]int{6, 1, 5}, []int{3, 8, 9}, []int{2, 7, 4}}, 8), expected: []int{1, 5, 1, 5, 1, 5, 1, 5} },\n     { actual: candidate([][]int{[]int{1, 2}, []int{3, 4}}, 10), expected: []int{1, 2, 1, 2, 1, 2, 1, 2, 1, 2} },\n     { actual: candidate([][]int{[]int{1, 3}, []int{3, 2}}, 10), expected: []int{1, 3, 1, 3, 1, 3, 1, 3, 1, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage minPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"sort\"\n)\n\n// Structure to hold cell information\ntype Cell struct {\n    x, y, value int\n}\n\n// Helper function to check valid moves\nfunc isValid(x, y, n int) bool {\n    return (x >= 0 && x < n && y >= 0 && y < n)\n}\n\n// DFS function to find the minimum path\nfunc dfs(grid [][]int, x, y, k int, path []int, result *[]int) {\n    if k == 0 {\n        if *result == nil || lexicographicallyLess(path, *result) {\n            copied := make([]int, len(path))\n            copy(copied, path)\n            *result = copied\n        }\n        return\n    }\n    \n    directions := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\n    for _, dir := range directions {\n        nx, ny := x + dir[0], y + dir[1]\n        if isValid(nx, ny, len(grid)) {\n            path = append(path, grid[nx][ny])\n            dfs(grid, nx, ny, k - 1, path, result)\n            path = path[:len(path) - 1]\n        }\n    }\n}\n\n// Function to compare two paths lexicographically\nfunc lexicographicallyLess(a, b []int) bool {\n    for i := 0; i < len(a) && i < len(b); i++ {\n        if a[i] < b[i] {\n            return true\n        } else if a[i] > b[i] {\n            return false\n        }\n    }\n    return len(a) < len(b)\n}\n\nfunc minPath(grid [][]int, k int) []int {\n    n := len(grid)\n    \n    var result []int\n    \n    // Iterate through each cell and initiate DFS\n    for i := 0; i < n; i++ {\n        for j := 0; j < n; j++ {\n            path := []int{grid[i][j]}\n            dfs(grid, i, j, k - 1, path, &result)\n        }\n    }\n    \n    return result\n}\n\nfunc TestMinPath(t *testing.T) {\n    tests := []struct {\n        grid   [][]int\n        k      int\n        result []int\n    }{\n        {[][]int{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3, []int{1, 2, 1}},\n        {[][]int{{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1, []int{1}},\n    }\n\n    for _, test := range tests {\n        res := minPath(test.grid, test.k)\n        if !equal(res, test.result) {\n            t.Errorf(\"For grid %v and k = %d, expected %v but got %v\", test.grid, test.k, test.result, res)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    // To run unit tests\n    fmt.Println(\"Running unit tests...\")\n    TestMinPath(nil)\n    fmt.Println(\"All tests passed.\")\n}\n```", "task_id": "HumanEval_129_minPath"}
{"name": "HumanEval_130_tri", "language": "go_test.go", "prompt": "package tri_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a list of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri(3)\n// []int{1, 3, 2, 8}\nfunc tri(n int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_130_tri.py", "prompt_terminology": "reworded", "tests": "func TestTri(t *testing.T) {\n  candidate := tri\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3), expected: []int{1, 3, 2, 8} },\n     { actual: candidate(4), expected: []int{1, 3, 2, 8, 3} },\n     { actual: candidate(5), expected: []int{1, 3, 2, 8, 3, 15} },\n     { actual: candidate(6), expected: []int{1, 3, 2, 8, 3, 15, 4} },\n     { actual: candidate(7), expected: []int{1, 3, 2, 8, 3, 15, 4, 24} },\n     { actual: candidate(8), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5} },\n     { actual: candidate(9), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5, 35} },\n     { actual: candidate(20), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11} },\n     { actual: candidate(0), expected: []int{1} },\n     { actual: candidate(1), expected: []int{1, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage tri_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc tri(n int) []int {\n    seq := make([]int, n+1)\n    if n >= 0 {\n        seq[0] = 1\n    }\n    if n >= 1 {\n        seq[1] = 3\n    }\n    if n >= 2 {\n        seq[2] = 1 + (2 / 2)\n    }\n    for i := 3; i <= n; i++ {\n        if i % 2 == 0 {\n            seq[i] = 1 + (i / 2)\n        } else {\n            seq[i] = seq[i-1] + seq[i-2] + seq[i+1-4+2]\n        }\n    }\n    return seq\n}\n\nfunc TestTri(t *testing.T) {\n    cases := []struct {\n        n        int\n        expected []int\n    }{\n        {0, []int{1}},\n        {1, []int{1, 3}},\n        {2, []int{1, 3, 2}},\n        {3, []int{1, 3, 2, 8}},\n        {4, []int{1, 3, 2, 8, 3}},\n    }\n    \n    for _, c := range cases {\n        result := tri(c.n)\n        if fmt.Sprint(result) != fmt.Sprint(c.expected) {\n            t.Errorf(\"Failed tri(%d): expected %v, got %v\", c.n, c.expected, result)\n        }\n    }\n}\n```", "task_id": "HumanEval_130_tri"}
{"name": "HumanEval_131_digits", "language": "go_test.go", "prompt": "package digits_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits(1)\n// 1\n// >>> digits(4)\n// 0\n// >>> digits(235)\n// 15\nfunc digits(n int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_131_digits.py", "prompt_terminology": "reworded", "tests": "func TestDigits(t *testing.T) {\n  candidate := digits\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: 5 },\n     { actual: candidate(54), expected: 5 },\n     { actual: candidate(120), expected: 1 },\n     { actual: candidate(5014), expected: 5 },\n     { actual: candidate(98765), expected: 315 },\n     { actual: candidate(5576543), expected: 2625 },\n     { actual: candidate(2468), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage digits_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits(1)\n// 1\n// >>> digits(4)\n// 0\n// >>> digits(235)\n// 15\nfunc digits(n int) int {\n    product := 1\n    hasOdd := false\n    \n    for n > 0 {\n        digit := n % 10\n        if digit % 2 != 0 {\n            product *= digit\n            hasOdd = true\n        }\n        n /= 10\n    }\n\n    if !hasOdd {\n        return 0\n    }\n    return product\n}\n\nfunc TestDigits(t *testing.T) {\n    tests := []struct {\n        input int\n        expected int\n    }{\n        {1, 1},\n        {4, 0},\n        {235, 15},\n        {2468, 0},\n        {13579, 945},\n        {222, 0},\n        {1111, 1},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"digits(%d)\", test.input), func(t *testing.T) {\n            result := digits(test.input)\n            if result != test.expected {\n                t.Errorf(\"expected %d, got %d\", test.expected, result)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_131_digits"}
{"name": "HumanEval_132_is_nested", "language": "go_test.go", "prompt": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunc is_nested(myString string) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_132_is_nested.py", "prompt_terminology": "reworded", "tests": "func TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage is_nested_test\n\nimport (\n    \"testing\"\n)\n\nfunc is_nested(myString string) bool {\n    stack := []rune{}\n\n    for _, char := range myString {\n        if char == '[' {\n            stack = append(stack, char)\n        } else if char == ']' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n\n    maxDepth := 0\n    currentDepth := 0\n\n    for _, char := range myString {\n        if char == '[' {\n            currentDepth++\n            if currentDepth > 1 {\n                return true\n            }\n            if currentDepth > maxDepth {\n                maxDepth = currentDepth\n            }\n        } else if char == ']' {\n            if currentDepth > maxDepth {\n                maxDepth = currentDepth\n            }\n            currentDepth--\n        }\n    }\n\n    return false\n}\n\n// below is a basic test suite for the function.\nfunc TestIsNested(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected bool\n    }{\n        {\"[[]]\", true},\n        {\"[]]]]]]][[[[[]\", false},\n        {\"[][]\", false},\n        {\"[]\", false},\n        {\"[[][]]\", true},\n        {\"[[]][[\", true},\n    }\n\n    for _, test := range tests {\n        result := is_nested(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input '%s', expected result was '%v', but got '%v'\", test.input, test.expected, result)\n        }\n    }\n}\n```", "task_id": "HumanEval_132_is_nested"}
{"name": "HumanEval_133_sum_squares", "language": "go_test.go", "prompt": "package sum_squares_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a list of numbers.\n// You need to return the sum of squared numbers in the given list,\n// round each element in the list to the upper int(Ceiling) first.\n// Examples:\n// >>> lst([]float64{1.0, 2.0, 3.0})\n// 14\n// >>> lst([]float64{1.0, 4.0, 9.0})\n// 98\n// >>> lst([]float64{1.0, 3.0, 5.0, 7.0})\n// 84\n// >>> lst([]float64{1.4, 4.2, 0.0})\n// 29\n// >>> lst([]float64{-2.4, 1.0, 1.0})\n// 6\nfunc sum_squares(lst []float64) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_133_sum_squares.py", "prompt_terminology": "reworded", "tests": "func TestSum_Squares(t *testing.T) {\n  candidate := sum_squares\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.0}), expected: 14 },\n     { actual: candidate([]float64{1.0, 2.0, 3.0}), expected: 14 },\n     { actual: candidate([]float64{1.0, 3.0, 5.0, 7.0}), expected: 84 },\n     { actual: candidate([]float64{1.4, 4.2, 0.0}), expected: 29 },\n     { actual: candidate([]float64{-2.4, 1.0, 1.0}), expected: 6 },\n     { actual: candidate([]float64{100.0, 1.0, 15.0, 2.0}), expected: 10230 },\n     { actual: candidate([]float64{10000.0, 10000.0}), expected: 200000000 },\n     { actual: candidate([]float64{-1.4, 4.6, 6.3}), expected: 75 },\n     { actual: candidate([]float64{-1.4, 17.9, 18.9, 19.9}), expected: 1086 },\n     { actual: candidate([]float64{0.0}), expected: 0 },\n     { actual: candidate([]float64{-1.0}), expected: 1 },\n     { actual: candidate([]float64{-1.0, 1.0, 0.0}), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage sum_squares_test\n\nimport (\n    \"math\"\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a list of numbers.\n// You need to return the sum of squared numbers in the given list,\n// round each element in the list to the upper int(Ceiling) first.\n// Examples:\n// >>> sum_squares([]float64{1.0, 2.0, 3.0})\n// 14\n// >>> sum_squares([]float64{1.0, 4.0, 9.0})\n// 98\n// >>> sum_squares([]float64{1.0, 3.0, 5.0, 7.0})\n// 84\n// >>> sum_squares([]float64{1.4, 4.2, 0.0})\n// 29\n// >>> sum_squares([]float64{-2.4, 1.0, 1.0})\n// 6\nfunc sum_squares(lst []float64) int {\n    sum := 0\n    for _, v := range lst {\n        ceiling := int(math.Ceil(v))\n        sum += ceiling * ceiling\n    }\n    return sum\n}\n\nfunc TestSumSquares(t *testing.T) {\n    tests := []struct {\n        input []float64\n        expected int\n    }{\n        {[]float64{1.0, 2.0, 3.0}, 14},\n        {[]float64{1.0, 4.0, 9.0}, 98},\n        {[]float64{1.0, 3.0, 5.0, 7.0}, 84},\n        {[]float64{1.4, 4.2, 0.0}, 29},\n        {[]float64{-2.4, 1.0, 1.0}, 6},\n    }\n\n    for _, test := range tests {\n        result := sum_squares(test.input)\n        if result != test.expected {\n            t.Errorf(\"Expected %d but got %d for input %v\", test.expected, result, test.input)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(sum_squares([]float64{1.0, 2.0, 3.0}))        // 14\n    fmt.Println(sum_squares([]float64{1.0, 4.0, 9.0}))        // 98\n    fmt.Println(sum_squares([]float64{1.0, 3.0, 5.0, 7.0}))   // 84\n    fmt.Println(sum_squares([]float64{1.4, 4.2, 0.0}))        // 29\n    fmt.Println(sum_squares([]float64{-2.4, 1.0, 1.0}))       // 6\n}\n```\n\nThis Go code defines the `sum_squares` function which calculates the sum of the squares of the elements in the list after rounding each element up to the nearest integer. It also includes a test function `TestSumSquares` that verifies the implementation using several test cases.", "task_id": "HumanEval_133_sum_squares"}
{"name": "HumanEval_134_check_if_last_char_is_a_letter", "language": "go_test.go", "prompt": "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n// false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>> check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_134_check_if_last_char_is_a_letter.py", "prompt_terminology": "reworded", "tests": "func TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage check_if_last_char_is_a_letter_test\n\nimport (\n    \"strings\"\n    \"unicode\"\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n// false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>> check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    txt = strings.TrimSpace(txt)\n    if len(txt) == 0 {\n        return false\n    }\n    \n    lastChar := rune(txt[len(txt)-1])\n    if unicode.IsLetter(lastChar) {\n        words := strings.Fields(txt)\n        lastWord := words[len(words)-1]\n        return len(lastWord) == 1\n    }\n    return false\n}\n\nfunc TestCheckIfLastCharIsALetter(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected bool\n    }{\n        {\"apple pie\", false},\n        {\"apple pi e\", true},\n        {\"apple pi e \", false},\n        {\"\", false},\n        {\"a\", true},\n        {\"a \", false},\n        {\" a\", true},\n        {\"apple pi eel \", false},\n        {\"apple pi e l\", true},\n    }\n\n    for _, test := range tests {\n        result := check_if_last_char_is_a_letter(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input %q, expected %v but got %v\", test.input, test.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    tests := []struct {\n        input    string\n        expected bool\n    }{\n        {\"apple pie\", false},\n        {\"apple pi e\", true},\n        {\"apple pi e \", false},\n        {\"\", false},\n    }\n\n    for _, test := range tests {\n        result := check_if_last_char_is_a_letter(test.input)\n        fmt.Printf(\"For input %q, expected %v, got %v\\n\", test.input, test.expected, result)\n    }\n}\n```", "task_id": "HumanEval_134_check_if_last_char_is_a_letter"}
{"name": "HumanEval_135_can_arrange", "language": "go_test.go", "prompt": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_135_can_arrange.py", "prompt_terminology": "reworded", "tests": "func TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i-1] {\n            return i\n        }\n    }\n    return -1\n}\n\n// Test cases\nfunc TestCanArrange(t *testing.T) {\n    tests := []struct {\n        arr []int\n        expected int\n    }{\n        {[]int{1, 2, 4, 3, 5}, 3},\n        {[]int{1, 2, 3}, -1},\n        {[]int{5, 4, 3, 2, 1}, 1},\n        {[]int{1, 3, 2, 4}, 2},\n        {[]int{10, 20, 30, 40, 25}, 4},\n        {[]int{1, 5, 9, 12, 8}, 4},\n    }\n\n    for _, test := range tests {\n        result := can_arrange(test.arr)\n        if result != test.expected {\n            t.Errorf(\"For %v expected %d but got %d\", test.arr, test.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    tests := []struct {\n        arr []int\n        expected int\n    }{\n        {[]int{1, 2, 4, 3, 5}, 3},\n        {[]int{1, 2, 3}, -1},\n    }\n\n    for _, test := range tests {\n        fmt.Printf(\"can_arrange(%v) = %d\\n\", test.arr, can_arrange(test.arr))\n    }\n}\n```", "task_id": "HumanEval_135_can_arrange"}
{"name": "HumanEval_136_largest_smallest_integers", "language": "go_test.go", "prompt": "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that returns a list (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a list.\n// If there is no negative or positive integers, return them as nil.\n// Examples:\n// >>> largest_smallest_integers([]int{2, 4, 1, 3, 5, 7})\n// []interface{}{nil, 1}\n// >>> largest_smallest_integers([]int{})\n// []interface{}{nil, nil}\n// >>> largest_smallest_integers([]int{0})\n// []interface{}{nil, nil}\nfunc largest_smallest_integers(lst []int) []interface{} {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_136_largest_smallest_integers.py", "prompt_terminology": "reworded", "tests": "func TestLargest_Smallest_Integers(t *testing.T) {\n  candidate := largest_smallest_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected: []interface{}{nil, 1} },\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7, 0}), expected: []interface{}{nil, 1} },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2, 1} },\n     { actual: candidate([]int{4, 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },\n     { actual: candidate([]int{7, 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },\n     { actual: candidate([]int{}), expected: []interface{}{nil, nil} },\n     { actual: candidate([]int{0}), expected: []interface{}{nil, nil} },\n     { actual: candidate([]int{-1, -3, -5, -6}), expected: []interface{}{-1, nil} },\n     { actual: candidate([]int{-1, -3, -5, -6, 0}), expected: []interface{}{-1, nil} },\n     { actual: candidate([]int{-6, -4, -4, -3, 1}), expected: []interface{}{-3, 1} },\n     { actual: candidate([]int{-6, -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage largest_smallest_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function that returns a list (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a list.\n// If there is no negative or positive integers, return them as nil.\n// Examples:\n// >>> largest_smallest_integers([]int{2, 4, 1, 3, 5, 7})\n// []interface{}{nil, 1}\n// >>> largest_smallest_integers([]int{})\n// []interface{}{nil, nil}\n// >>> largest_smallest_integers([]int{0})\n// []interface{}{nil, nil}\nfunc largest_smallest_integers(lst []int) []interface{} {\n    var maxNegative *int\n    var minPositive *int\n\n    for _, num := range lst {\n        if num < 0 {\n            if maxNegative == nil || num > *maxNegative {\n                maxNegative = &num\n            }\n        } else if num > 0 {\n            if minPositive == nil || num < *minPositive {\n                minPositive = &num\n            }\n        }\n    }\n\n    result := []interface{}{nil, nil}\n    if maxNegative != nil {\n        result[0] = *maxNegative\n    }\n    if minPositive != nil {\n        result[1] = *minPositive\n    }\n    return result\n}\n\nfunc TestLargestSmallestIntegers(t *testing.T) {\n    cases := []struct {\n        input    []int\n        expected []interface{}\n    }{\n        {[]int{2, 4, 1, 3, 5, 7}, []interface{}{nil, 1}},\n        {[]int{}, []interface{}{nil, nil}},\n        {[]int{0}, []interface{}{nil, nil}},\n        {[]int{-1, -2, -3, 1, 2, 3}, []interface{}{-1, 1}},\n        {[]int{-5, -10, 10, 3}, []interface{}{-5, 3}},\n    }\n\n    for _, c := range cases {\n        got := largest_smallest_integers(c.input)\n        if fmt.Sprintf(\"%v\", got) != fmt.Sprintf(\"%v\", c.expected) {\n            t.Errorf(\"largest_smallest_integers(%v) == %v, want %v\", c.input, got, c.expected)\n        }\n    }\n}\n```", "task_id": "HumanEval_136_largest_smallest_integers"}
{"name": "HumanEval_138_is_equal_to_sum_even", "language": "go_test.go", "prompt": "package is_equal_to_sum_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even(4)\n// false\n// >>> is_equal_to_sum_even(6)\n// false\n// >>> is_equal_to_sum_even(8)\n// true\nfunc is_equal_to_sum_even(n int) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_138_is_equal_to_sum_even.py", "prompt_terminology": "reworded", "tests": "func TestIs_Equal_To_Sum_Even(t *testing.T) {\n  candidate := is_equal_to_sum_even\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(4), expected: false },\n     { actual: candidate(6), expected: false },\n     { actual: candidate(8), expected: true },\n     { actual: candidate(10), expected: true },\n     { actual: candidate(11), expected: false },\n     { actual: candidate(12), expected: true },\n     { actual: candidate(13), expected: false },\n     { actual: candidate(16), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage is_equal_to_sum_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even(4)\n// false\n// >>> is_equal_to_sum_even(6)\n// false\n// >>> is_equal_to_sum_even(8)\n// true\nfunc is_equal_to_sum_even(n int) bool {\n    // If n is less than 8, it is not possible to write it as the sum of 4 positive even numbers\n    if n < 8 {\n        return false\n    }\n    // If n is even number then it can be written as the sum of 4 positive even number\n    return n%2 == 0\n}\n\n// Test cases\nfunc TestIsEqualToSumEven(t *testing.T) {\n    tests := []struct {\n        input int\n        expected bool\n    }{\n        {4, false},\n        {6, false},\n        {8, true},\n        {10, true},\n        {12, true},\n        {14, true},\n        {18, true},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"is_equal_to_sum_even(%d)\", test.input), func(t *testing.T) {\n            result := is_equal_to_sum_even(test.input)\n            if result != test.expected {\n                t.Errorf(\"expected %v, got %v\", test.expected, result)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_138_is_equal_to_sum_even"}
{"name": "HumanEval_139_special_factorial", "language": "go_test.go", "prompt": "package special_factorial_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial(4)\n// 288\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nfunc special_factorial(n int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_139_special_factorial.py", "prompt_terminology": "reworded", "tests": "func TestSpecial_Factorial(t *testing.T) {\n  candidate := special_factorial\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(4), expected: 288 },\n     { actual: candidate(5), expected: 34560 },\n     { actual: candidate(7), expected: 125411328000 },\n     { actual: candidate(1), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage special_factorial_test\n\nimport (\n    \"testing\"\n    \"math/big\"\n\t\"fmt\"\n)\n\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial(4)\n// 288\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nfunc special_factorial(n int) *big.Int {\n    result := big.NewInt(1) // Initiate the result to 1 as it's the multiplicative identity\n    for i := n; i > 0; i-- {\n        result.Mul(result, factorial(i))\n    }\n    return result\n}\n\n// Helper function to calculate factorial of a number\nfunc factorial(n int) *big.Int {\n    fact := big.NewInt(1)\n    for i := 2; i <= n; i++ {\n         fact.Mul(fact, big.NewInt(int64(i)))\n    }\n    return fact\n}\n\nfunc TestSpecialFactorial(t *testing.T) {\n    cases := []struct{\n        input int\n        expected *big.Int\n    }{\n        {4, big.NewInt(288)},\n        {3, big.NewInt(12)},\n        {2, big.NewInt(2)},\n        {1, big.NewInt(1)},\n    }\n\n    for _, c := range cases {\n        result := special_factorial(c.input)\n        if result.Cmp(c.expected) != 0 {\n            t.Errorf(\"special_factorial(%d) == %d, expected %d\", c.input, result, c.expected)\n        } else {\n            fmt.Printf(\"special_factorial(%d) == %d\\n\", c.input, result)\n        }\n    }\n}\n```", "task_id": "HumanEval_139_special_factorial"}
{"name": "HumanEval_140_fix_spaces", "language": "go_test.go", "prompt": "package fix_spaces_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces(\" Example\")\n// \"Example\"\n// >>> fix_spaces(\" Example 1\")\n// \"Example_1\"\n// >>> fix_spaces(\" Example 2\")\n// \"_Example_2\"\n// >>> fix_spaces(\" Example 3\")\n// \"_Example-3\"\nfunc fix_spaces(text string) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_140_fix_spaces.py", "prompt_terminology": "reworded", "tests": "func TestFix_Spaces(t *testing.T) {\n  candidate := fix_spaces\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Example\"), expected: \"Example\" },\n     { actual: candidate(\"Mudasir Hanif \"), expected: \"Mudasir_Hanif_\" },\n     { actual: candidate(\"Yellow Yellow  Dirty  Fellow\"), expected: \"Yellow_Yellow__Dirty__Fellow\" },\n     { actual: candidate(\"Exa   mple\"), expected: \"Exa-mple\" },\n     { actual: candidate(\"   Exa 1 2 2 mple\"), expected: \"-Exa_1_2_2_mple\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage fix_spaces_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces(\" Example\")\n// \"Example\"\n// >>> fix_spaces(\" Example 1\")\n// \"Example_1\"\n// >>> fix_spaces(\" Example 2\")\n// \"_Example_2\"\n// >>> fix_spaces(\" Example 3\")\n// \"_Example-3\"\nfunc fix_spaces(text string) string {\n    // Replace occurrences of more than 2 consecutive spaces with a hyphen\n    for strings.Contains(text, \"   \") {\n        text = strings.ReplaceAll(text, \"   \", \" - \")\n    }\n\n    // Replace single spaces with underscores\n    text = strings.ReplaceAll(text, \" \", \"_\")\n\n    // Remove any leading underscores that might have been added\n    text = strings.TrimPrefix(text, \"_\")\n\n    return text\n}\n\nfunc TestFixSpaces(t *testing.T) {\n    testCases := []struct {\n        input    string\n        expected string\n    }{\n        {\" Example\", \"Example\"},\n        {\" Example 1\", \"Example_1\"},\n        {\" Example  2\", \"_Example_2\"},\n        {\" Example   3\", \"_Example-3\"},\n        {\"    Example   4\", \"_-Example-4\"},\n        {\"Another    example   \", \"Another_-example_-\"},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"%v -> %v\", tc.input, tc.expected), func(t *testing.T) {\n            actual := fix_spaces(tc.input)\n            if actual != tc.expected {\n                t.Errorf(\"expected %q, but got %q\", tc.expected, actual)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_140_fix_spaces"}
{"name": "HumanEval_141_file_name_check", "language": "go_test.go", "prompt": "package file_name_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check(\"example.txt\")\n// \"Yes\"\n// >>> file_name_check(\"1example.dll\")\n// \"No\"\nfunc file_name_check(file_name string) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_141_file_name_check.py", "prompt_terminology": "reworded", "tests": "func TestFile_Name_Check(t *testing.T) {\n  candidate := file_name_check\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"example.txt\"), expected: \"Yes\" },\n     { actual: candidate(\"1example.dll\"), expected: \"No\" },\n     { actual: candidate(\"s1sdf3.asd\"), expected: \"No\" },\n     { actual: candidate(\"K.dll\"), expected: \"Yes\" },\n     { actual: candidate(\"MY16FILE3.exe\"), expected: \"Yes\" },\n     { actual: candidate(\"His12FILE94.exe\"), expected: \"No\" },\n     { actual: candidate(\"_Y.txt\"), expected: \"No\" },\n     { actual: candidate(\"?aREYA.exe\"), expected: \"No\" },\n     { actual: candidate(\"/this_is_valid.dll\"), expected: \"No\" },\n     { actual: candidate(\"this_is_valid.wow\"), expected: \"No\" },\n     { actual: candidate(\"this_is_valid.txt\"), expected: \"Yes\" },\n     { actual: candidate(\"this_is_valid.txtexe\"), expected: \"No\" },\n     { actual: candidate(\"#this2_i4s_5valid.ten\"), expected: \"No\" },\n     { actual: candidate(\"@this1_is6_valid.exe\"), expected: \"No\" },\n     { actual: candidate(\"this_is_12valid.6exe4.txt\"), expected: \"No\" },\n     { actual: candidate(\"all.exe.txt\"), expected: \"No\" },\n     { actual: candidate(\"I563_No.exe\"), expected: \"Yes\" },\n     { actual: candidate(\"Is3youfault.txt\"), expected: \"Yes\" },\n     { actual: candidate(\"no_one#knows.dll\"), expected: \"Yes\" },\n     { actual: candidate(\"1I563_Yes3.exe\"), expected: \"No\" },\n     { actual: candidate(\"I563_Yes3.txtt\"), expected: \"No\" },\n     { actual: candidate(\"final..txt\"), expected: \"No\" },\n     { actual: candidate(\"final132\"), expected: \"No\" },\n     { actual: candidate(\"_f4indsartal132.\"), expected: \"No\" },\n     { actual: candidate(\".txt\"), expected: \"No\" },\n     { actual: candidate(\"s.\"), expected: \"No\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage file_name_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"unicode\"\n    \"strings\"\n)\n\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphabet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check(\"example.txt\")\n// \"Yes\"\n// >>> file_name_check(\"1example.dll\")\n// \"No\"\nfunc file_name_check(file_name string) string {\n    digitCount := 0\n    dotCount := strings.Count(file_name, \".\")\n    \n    // There must be exactly one dot in the filename\n    if dotCount != 1 {\n        return \"No\"\n    }\n    \n    parts := strings.Split(file_name, \".\")\n    \n    // Filename must contain exactly one dot which means parts should have exactly two elements\n    if len(parts) != 2 {\n        return \"No\"\n    }\n    \n    beforeDot := parts[0]\n    afterDot := parts[1]\n    \n    // The substring before the dot should not be empty and should start with a letter\n    if len(beforeDot) == 0 || !unicode.IsLetter(rune(beforeDot[0])) {\n        return \"No\"\n    }\n    \n    // The substring after the dot should be one of: ['txt', 'exe', 'dll']\n    validExtensions := map[string]bool{\"txt\": true, \"exe\": true, \"dll\": true}\n    if !validExtensions[afterDot] {\n        return \"No\"\n    }\n    \n    // The filename must not contain more than three digits\n    for _, char := range beforeDot {\n        if unicode.IsDigit(char) {\n            digitCount++\n            if digitCount > 3 {\n                return \"No\"\n            }\n        }\n    }\n    \n    return \"Yes\"\n}\n\n// Test cases\nfunc TestFileNameCheck(t *testing.T) {\n    tests := []struct {\n        fileName string\n        expected string\n    }{\n        {\"example.txt\", \"Yes\"},\n        {\"1example.dll\", \"No\"},\n        {\"example.exe\", \"Yes\"},\n        {\"exam.ple.txt\", \"No\"},\n        {\"exa.mple.txt\", \"No\"},\n        {\"exampletxt\", \"No\"},\n        {\"ex4mple.txt\", \"Yes\"},\n        {\"ex4mp5le5.txt\", \"Yes\"},\n        {\"ex4mp5le55.txt\", \"No\"},\n        {\"example.jjd\", \"No\"},\n    }\n\n    for _, test := range tests {\n        result := file_name_check(test.fileName)\n        if result != test.expected {\n            t.Errorf(\"file_name_check(%s) = %s; expected %s\", test.fileName, result, test.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(file_name_check(\"example.txt\")) // \"Yes\"\n    fmt.Println(file_name_check(\"1example.dll\")) // \"No\"\n    fmt.Println(file_name_check(\"exa.mple.txt\")) // \"No\"\n    fmt.Println(file_name_check(\"ex4mple.txt\")) // \"Yes\"\n}\n```", "task_id": "HumanEval_141_file_name_check"}
{"name": "HumanEval_142_sum_squares", "language": "go_test.go", "prompt": "package sum_squares_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// \"\n// This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// []int{1, 2, 3}\n// >>> lst\n// int{}\n// >>> lst\n// []int{-1, -5, 2, -1, -5}\nfunc sum_squares(lst []int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_142_sum_squares.py", "prompt_terminology": "reworded", "tests": "func TestSum_Squares(t *testing.T) {\n  candidate := sum_squares\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3}), expected: 6 },\n     { actual: candidate([]int{1, 4, 9}), expected: 14 },\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{1, 1, 1, 1, 1, 1, 1, 1, 1}), expected: 9 },\n     { actual: candidate([]int{-1, -1, -1, -1, -1, -1, -1, -1, -1}), expected: -3 },\n     { actual: candidate([]int{0}), expected: 0 },\n     { actual: candidate([]int{-1, -5, 2, -1, -5}), expected: -126 },\n     { actual: candidate([]int{-56, -99, 1, 0, -2}), expected: 3030 },\n     { actual: candidate([]int{-1, 0, 0, 0, 0, 0, 0, 0, -1}), expected: 0 },\n     { actual: candidate([]int{-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}), expected: -14196 },\n     { actual: candidate([]int{-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}), expected: -1448 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage sum_squares_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sum_squares(lst []int) int {\n    sum := 0\n    for idx, val := range lst {\n        if idx % 3 == 0 {\n            sum += val * val\n        } else if idx % 4 == 0 {\n            sum += val * val * val\n        } else {\n            sum += val\n        }\n    }\n    return sum\n}\n\nfunc TestSumSquares(t *testing.T) {\n    tests := []struct{\n        input []int\n        expected int\n    }{\n        {[]int{1, 2, 3}, 12},\n        {[]int{}, 0},\n        {[]int{-1, -5, 2, -1, -5}, 27},\n        {[]int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 0},\n        {[]int{1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 11},\n    }\n\n    for _, test := range tests {\n        result := sum_squares(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input %v, expected %v, but got %v\", test.input, test.expected, result)\n        } else {\n            fmt.Printf(\"Test passed for input %v\\n\", test.input)\n        }\n    }\n}\n```", "task_id": "HumanEval_142_sum_squares"}
{"name": "HumanEval_143_words_in_sentence", "language": "go_test.go", "prompt": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_143_words_in_sentence.py", "prompt_terminology": "reworded", "tests": "func TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage words_in_sentence_test\n\nimport (\n    \"strings\"\n    \"testing\"\n    \"unicode\"\n)\n\n// Helper function to check if a number is prime\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i*i <= n; i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\n// Function to return words with lengths that are prime numbers\nfunc words_in_sentence(sentence string) string {\n    words := strings.Fields(sentence)\n    var result []string\n    \n    for _, word := range words {\n        if isPrime(len(word)) {\n            result = append(result, word)\n        }\n    }\n    \n    return strings.Join(result, \" \")\n}\n\n// Test cases\nfunc TestWordsInSentence(t *testing.T) {\n    testCases := []struct {\n        input, expected string\n    }{\n        {\"This is a test\", \"is\"},\n        {\"lets go for swimming\", \"go for\"},\n        {\"abc defg hijklmnop\", \"abc\"},\n        {\"a\", \"\"},\n        {\"I love to code in Go\", \"to in\"},\n    }\n    \n    for _, tc := range testCases {\n        t.Run(tc.input, func(t *testing.T) {\n            actual := words_in_sentence(tc.input)\n            if actual != tc.expected {\n                t.Fatalf(\"Expected %s but got %s\", tc.expected, actual)\n            }\n        })\n    }\n}\n\n// Main function to run tests\nfunc main() {\n    fmt.Println(words_in_sentence(\"This is a test\"))      // Output: \"is\"\n    fmt.Println(words_in_sentence(\"lets go for swimming\")) // Output: \"go for\"\n}\n```\n\nIn the provided code, a helper function `isPrime` is used to determine if a number is a prime. In the main function `words_in_sentence`, the words are extracted using `strings.Fields`, and we check the length of each word. If the length is a prime number, the word is added to the result. The test cases in `TestWordsInSentence` ensure that the function behaves as expected.", "task_id": "HumanEval_143_words_in_sentence"}
{"name": "HumanEval_144_simplify", "language": "go_test.go", "prompt": "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\", \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_144_simplify.py", "prompt_terminology": "reworded", "tests": "func TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage simplify_test\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n)\n\n// Helper function to parse a fraction string and return the numerator and denominator as integers\nfunc parseFraction(fraction string) (int, int) {\n\tparts := strings.Split(fraction, \"/\")\n\tnumerator, _ := strconv.Atoi(parts[0])\n\tdenominator, _ := strconv.Atoi(parts[1])\n\treturn numerator, denominator\n}\n\n// Function to simplify the expression x * n\nfunc simplify(x string, n string) bool {\n\t// Parse the fractions x and n\n\tnumX, denX := parseFraction(x)\n\tnumN, denN := parseFraction(n)\n\n\t// Calculate the result of multiplying numX/denX by numN/denN\n\tresultNumerator := numX * numN\n\tresultDenominator := denX * denN\n\n\t// Check if the result is a whole number\n\treturn resultNumerator%resultDenominator == 0\n}\n\n// Test cases to verify the function\nfunc TestSimplify(t *testing.T) {\n\ttests := []struct {\n\t\tx        string\n\t\tn        string\n\t\texpected bool\n\t}{\n\t\t{\"1/5\", \"5/1\", true},\n\t\t{\"1/6\", \"2/1\", false},\n\t\t{\"7/10\", \"10/2\", false},\n\t\t// Adding more edge cases to test\n\t\t{\"2/3\", \"3/2\", true},\n\t\t{\"4/5\", \"5/4\", true},\n\t\t{\"1/1\", \"1/1\", true},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%s * %s\", test.x, test.n), func(t *testing.T) {\n\t\t\tresult := simplify(test.x, test.n)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"Expected simplify(%s, %s) to be %v, got %v\", test.x, test.n, test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n```", "task_id": "HumanEval_144_simplify"}
{"name": "HumanEval_145_order_by_points", "language": "go_test.go", "prompt": "package order_by_points_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function which sorts the given list of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original list.\n// For example:\n// >>> order_by_points([]int{1, 11, -1, -11, -12})\n// []int{-1, -11, 1, -12, 11}\n// >>> order_by_points([]int{})\n// []int{}\nfunc order_by_points(nums []int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_145_order_by_points.py", "prompt_terminology": "reworded", "tests": "func TestOrder_By_Points(t *testing.T) {\n  candidate := order_by_points\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 11, -1, -11, -12}), expected: []int{-1, -11, 1, -12, 11} },\n     { actual: candidate([]int{1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46}), expected: []int{0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, -11, -32, 43, 54, -98, 2, -3}), expected: []int{-3, -32, -98, -11, 1, 2, 43, 54} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}), expected: []int{1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9} },\n     { actual: candidate([]int{0, 6, 6, -76, -21, 23, 4}), expected: []int{-76, -21, 0, 4, 23, 6, 6} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage order_by_points_test\n\nimport (\n\t\"sort\"\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc sumOfDigits(n int) int {\n\tnStr := strconv.Itoa(n)\n\tsum := 0\n\tfor _, char := range nStr {\n\t\tif char == '-' {\n\t\t\tcontinue\n\t\t}\n\t\tdigit := int(char - '0')\n\t\tsum += digit\n\t}\n\treturn sum\n}\n\nfunc order_by_points(nums []int) []int {\n\ttype indexedNum struct {\n\t\tindex int\n\t\tvalue int\n\t}\n\n\twithIndex := make([]indexedNum, len(nums))\n\tfor i, num := range nums {\n\t\twithIndex[i] = indexedNum{\n\t\t\tindex: i,\n\t\t\tvalue: num,\n\t\t}\n\t}\n\n\tsort.Slice(withIndex, func(i, j int) bool {\n\t\tsumI := sumOfDigits(withIndex[i].value)\n\t\tsumJ := sumOfDigits(withIndex[j].value)\n\t\tif sumI == sumJ {\n\t\t\treturn withIndex[i].index < withIndex[j].index\n\t\t}\n\t\treturn sumI < sumJ\n\t})\n\n\tresult := make([]int, len(nums))\n\tfor i, item := range withIndex {\n\t\tresult[i] = item.value\n\t}\n\n\treturn result\n}\n\nfunc TestOrderByPoints(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected []int\n\t}{\n\t\t{[]int{1, 11, -1, -11, -12}, []int{-1, -11, 1, -12, 11}},\n\t\t{[]int{}, []int{}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := order_by_points(test.input)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"For input %v, expected %v, but got %v\", test.input, test.expected, result)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n```", "task_id": "HumanEval_145_order_by_points"}
{"name": "HumanEval_146_specialFilter", "language": "go_test.go", "prompt": "package specialFilter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes a list of numbers as input and returns \n// the number of elements in the list that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter([]int{15, -73, 14, -15})\n// 1\n// >>> specialFilter([]int{33, -2, -3, 45, 21, 109})\n// 2\nfunc specialFilter(nums []int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_146_specialFilter.py", "prompt_terminology": "reworded", "tests": "func TestSpecialfilter(t *testing.T) {\n  candidate := specialFilter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, -2, 1, -5}), expected: 0 },\n     { actual: candidate([]int{15, -73, 14, -15}), expected: 1 },\n     { actual: candidate([]int{33, -2, -3, 45, 21, 109}), expected: 2 },\n     { actual: candidate([]int{43, -12, 93, 125, 121, 109}), expected: 4 },\n     { actual: candidate([]int{71, -2, -33, 75, 21, 19}), expected: 3 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{}), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage specialFilter_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc specialFilter(nums []int) int {\n\tcount := 0\n\n\tisOdd := func(digit int) bool {\n\t\toddDigits := map[int]bool{1: true, 3: true, 5: true, 7: true, 9: true}\n\t\treturn oddDigits[digit]\n\t}\n\n\tfirstDigit := func(num int) int {\n\t\tnum = int(math.Abs(float64(num)))\n\t\tfor num >= 10 {\n\t\t\tnum /= 10\n\t\t}\n\t\treturn num\n\t}\n\n\tlastDigit := func(num int) int {\n\t\treturn int(math.Abs(float64(num))) % 10\n\t}\n\n\tfor _, num := range nums {\n\t\tif num > 10 && isOdd(firstDigit(num)) && isOdd(lastDigit(num)) {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\nfunc TestSpecialFilter(t *testing.T) {\n\ttests := []struct{\n\t\tinput []int\n\t\texpected int\n\t} {\n\t\t{[]int{15, -73, 14, -15}, 1},\n\t\t{[]int{33, -2, -3, 45, 21, 109}, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tif result := specialFilter(test.input); result != test.expected {\n\t\t\tt.Errorf(\"For input %v, expected %d but got %d\", test.input, test.expected, result)\n\t\t}\n\t}\n}\n\nfunc main() {\n\tfmt.Println(specialFilter([]int{15, -73, 14, -15})) // 1\n\tfmt.Println(specialFilter([]int{33, -2, -3, 45, 21, 109})) // 2\n}\n```", "task_id": "HumanEval_146_specialFilter"}
{"name": "HumanEval_147_get_max_triples", "language": "go_test.go", "prompt": "package get_max_triples_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a positive integer n. You have to create an integer list a of length n.\n// For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples(5)\n// 1\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nfunc get_max_triples(n int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_147_get_max_triples.py", "prompt_terminology": "reworded", "tests": "func TestGet_Max_Triples(t *testing.T) {\n  candidate := get_max_triples\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: 1 },\n     { actual: candidate(6), expected: 4 },\n     { actual: candidate(10), expected: 36 },\n     { actual: candidate(100), expected: 53361 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage get_max_triples_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a positive integer n. You have to create an integer list a of length n.\n// For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples(5)\n// 1\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nfunc get_max_triples(n int) int {\n    a := make([]int, n)\n    for i := 1; i <= n; i++ {\n        a[i-1] = i*i - i + 1\n    }\n    \n    count := 0\n    for i := 0; i < n-2; i++ {\n        for j := i+1; j < n-1; j++ {\n            for k := j+1; k < n; k++ {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count++\n                }\n            }\n        }\n    }\n    \n    return count\n}\n\nfunc TestGetMaxTriples(t *testing.T) {\n    tests := []struct {\n        n        int\n        expected int\n    }{\n        {5, 1},\n        {6, 1},\n        {7, 1},\n        {8, 2},\n        {9, 3},\n        {10, 3},\n    }\n    \n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"n=%d\", test.n), func(t *testing.T) {\n            got := get_max_triples(test.n)\n            if got != test.expected {\n                t.Errorf(\"get_max_triples(%d) = %d; expected %d\", test.n, got, test.expected)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_147_get_max_triples"}
{"name": "HumanEval_148_bf", "language": "go_test.go", "prompt": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_148_bf.py", "prompt_terminology": "reworded", "tests": "func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closest to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// []interface{}{\"Venus\"}\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    planetIndex := make(map[string]int)\n    for i, planet := range planets {\n        planetIndex[planet] = i\n    }\n\n    index1, found1 := planetIndex[planet1]\n    index2, found2 := planetIndex[planet2]\n\n    if !found1 || !found2 {\n        return []interface{}{}\n    }\n\n    if index1 > index2 {\n        index1, index2 = index2, index1\n    }\n\n    result := []interface{}{}\n    for i := index1 + 1; i < index2; i++ {\n        result = append(result, planets[i])\n    }\n\n    return result\n}\n\nfunc TestBF(t *testing.T) {\n    tests := []struct{\n        planet1 string\n        planet2 string\n        expected []interface{}\n    }{\n        {\"Jupiter\", \"Neptune\", []interface{}{\"Saturn\", \"Uranus\"}},\n        {\"Earth\", \"Mercury\", []interface{}{\"Venus\"}},\n        {\"Mercury\", \"Uranus\", []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}},\n        {\"Earth\", \"Earth\", []interface{}{}},\n        {\"Earth\", \"Pluto\", []interface{}{}},\n    }\n\n    for _, test := range tests {\n        result := bf(test.planet1, test.planet2)\n        if len(result) != len(test.expected) {\n            t.Errorf(\"For %s and %s expected %v got %v\", test.planet1, test.planet2, test.expected, result)\n            continue\n        }\n\n        for i := range result {\n            if result[i] != test.expected[i] {\n                t.Errorf(\"For %s and %s expected %v got %v\", test.planet1, test.planet2, test.expected, result)\n                break\n            }\n        }\n    }\n}\n\n// Example of using the function\nfunc main() {\n    fmt.Println(bf(\"Jupiter\", \"Neptune\")) // Output: [Saturn Uranus]\n    fmt.Println(bf(\"Earth\", \"Mercury\"))   // Output: [Venus]\n    fmt.Println(bf(\"Mercury\", \"Uranus\"))  // Output: [Venus Earth Mars Jupiter Saturn]\n}\n```", "task_id": "HumanEval_148_bf"}
{"name": "HumanEval_149_sorted_list_sum", "language": "go_test.go", "prompt": "package sorted_list_sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that accepts a list of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted list with a sorted order,\n// The list is always a list of strings and never a list of numbers,\n// and it may contain duplicates.\n// The order of the list should be ascending by length of each word, and you\n// should return the list sorted by that rule.\n// If two words have the same length, sort the list alphabetically.\n// The function should return a list of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort([]string{\"aa\", \"a\", \"aaa\"})\n// []string{\"aa\"}\n// >>> list_sort([]string{\"ab\", \"a\", \"aaa\", \"cd\"})\n// []string{\"ab\", \"cd\"}\nfunc sorted_list_sum(lst []string) []string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_149_sorted_list_sum.py", "prompt_terminology": "reworded", "tests": "func TestSorted_List_Sum(t *testing.T) {\n  candidate := sorted_list_sum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"aa\", \"a\", \"aaa\"}), expected: []string{\"aa\"} },\n     { actual: candidate([]string{\"school\", \"AI\", \"asdf\", \"b\"}), expected: []string{\"AI\", \"asdf\", \"school\"} },\n     { actual: candidate([]string{\"d\", \"b\", \"c\", \"a\"}), expected: []string{} },\n     { actual: candidate([]string{\"d\", \"dcba\", \"abcd\", \"a\"}), expected: []string{\"abcd\", \"dcba\"} },\n     { actual: candidate([]string{\"AI\", \"ai\", \"au\"}), expected: []string{\"AI\", \"ai\", \"au\"} },\n     { actual: candidate([]string{\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"}), expected: []string{} },\n     { actual: candidate([]string{\"aaaa\", \"bbbb\", \"dd\", \"cc\"}), expected: []string{\"cc\", \"dd\", \"aaaa\", \"bbbb\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage sorted_list_sum_test\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\t\"fmt\"\n)\n\n// Write a function that accepts a list of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted list with a sorted order.\n// The list is always a list of strings and never a list of numbers,\n// and it may contain duplicates.\n// The order of the list should be ascending by length of each word, and you\n// should return the list sorted by that rule.\n// If two words have the same length, sort the list alphabetically.\n// The function should return a list of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> sorted_list_sum([]string{\"aa\", \"a\", \"aaa\"})\n// []string{\"aa\"}\n// >>> sorted_list_sum([]string{\"ab\", \"a\", \"aaa\", \"cd\"})\n// []string{\"ab\", \"cd\"}\nfunc sorted_list_sum(lst []string) []string {\n\tvar result []string\n\t// Remove strings with odd lengths\n\tfor _, str := range lst {\n\t\tif len(str)%2 == 0 {\n\t\t\tresult = append(result, str)\n\t\t}\n\t}\n\t// Sort by length and then alphabetically\n\tsort.SliceStable(result, func(i, j int) bool {\n\t\tif len(result[i]) == len(result[j]) {\n\t\t\treturn result[i] < result[j]\n\t\t}\n\t\treturn len(result[i]) < len(result[j])\n\t})\n\treturn result\n}\n\n// Test function\nfunc TestSortedListSum(t *testing.T) {\n\ttests := []struct {\n\t\tinput  []string\n\t\toutput []string\n\t}{\n\t\t{[]string{\"aa\", \"a\", \"aaa\"}, []string{\"aa\"}},\n\t\t{[]string{\"ab\", \"a\", \"aaa\", \"cd\"}, []string{\"ab\", \"cd\"}},\n\t\t{[]string{\"this\", \"is\", \"a\", \"test\", \"example\"}, []string{\"test\", \"this\"}},\n\t\t{[]string{\"one\", \"two\", \"three\", \"four\"}, []string{\"four\"}},\n\t\t{[]string{\"red\", \"blue\", \"green\"}, []string{\"blue\"}},\n\t}\n\tfor _, test := range tests {\n\t\tresult := sorted_list_sum(test.input)\n\t\tif !equal(result, test.output) {\n\t\t\tt.Errorf(\"sorted_list_sum(%v) = %v; want %v\", test.input, result, test.output)\n\t\t}\n\t}\n}\n\n// Helper function to compare two slices for equality\nfunc equal(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc main() {\n    fmt.Println(sorted_list_sum([]string{\"aa\", \"a\", \"aaa\"})) // []string{\"aa\"}\n    fmt.Println(sorted_list_sum([]string{\"ab\", \"a\", \"aaa\", \"cd\"})) // []string{\"ab\", \"cd\"}\n}\n```", "task_id": "HumanEval_149_sorted_list_sum"}
{"name": "HumanEval_150_x_or_y", "language": "go_test.go", "prompt": "package x_or_y_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y(7, 34, 12)\n// 34\n// >>> x_or_y(15, 8, 5)\n// 5\nfunc x_or_y(n int, x int, y int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_150_x_or_y.py", "prompt_terminology": "reworded", "tests": "func TestX_Or_Y(t *testing.T) {\n  candidate := x_or_y\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(7, 34, 12), expected: 34 },\n     { actual: candidate(15, 8, 5), expected: 5 },\n     { actual: candidate(3, 33, 5212), expected: 33 },\n     { actual: candidate(1259, 3, 52), expected: 3 },\n     { actual: candidate(7919, -1, 12), expected: -1 },\n     { actual: candidate(3609, 1245, 583), expected: 583 },\n     { actual: candidate(91, 56, 129), expected: 129 },\n     { actual: candidate(6, 34, 1234), expected: 1234 },\n     { actual: candidate(1, 2, 0), expected: 0 },\n     { actual: candidate(2, 2, 0), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage x_or_y_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y(7, 34, 12)\n// 34\n// >>> x_or_y(15, 8, 5)\n// 5\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i*i <= n; i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc x_or_y(n int, x int, y int) int {\n    if isPrime(n) {\n        return x\n    }\n    return y\n}\n\nfunc TestXOrY(t *testing.T) {\n    tests := []struct {\n        n, x, y, expected int\n    }{\n        {7, 34, 12, 34},\n        {15, 8, 5, 5},\n        {2, 10, 20, 10},\n        {1, 0, 1, 1},\n        {13, 5, 9, 5},\n    }\n\n    for _, test := range tests {\n        result := x_or_y(test.n, test.x, test.y)\n        if result != test.expected {\n            t.Errorf(\"For n=%d, x=%d, y=%d; expected %d but got %d\", test.n, test.x, test.y, test.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(x_or_y(7, 34, 12)) // 34\n    fmt.Println(x_or_y(15, 8, 5))  // 5\n}\n```", "task_id": "HumanEval_150_x_or_y"}
{"name": "HumanEval_151_double_the_difference", "language": "go_test.go", "prompt": "package double_the_difference_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of numbers, return the sum of squares of the numbers\n// in the list that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference([]int{1, 3, 2, 0})\n// 10\n// >>> double_the_difference([]int{-1, -2, 0})\n// 0\n// >>> double_the_difference([]int{9, -2})\n// 81\n// >>> double_the_difference([]int{0})\n// 0\n// If the input list is empty, return 0.\nfunc double_the_difference(lst []float64) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_151_double_the_difference.py", "prompt_terminology": "reworded", "tests": "func TestDouble_The_Difference(t *testing.T) {\n  candidate := double_the_difference\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{}), expected: 0 },\n     { actual: candidate([]float64{5.0, 4.0}), expected: 25 },\n     { actual: candidate([]float64{0.1, 0.2, 0.3}), expected: 0 },\n     { actual: candidate([]float64{-10.0, -20.0, -30.0}), expected: 0 },\n     { actual: candidate([]float64{-1.0, -2.0, 8.0}), expected: 0 },\n     { actual: candidate([]float64{0.2, 3.0, 5.0}), expected: 34 },\n     { actual: candidate([]float64{-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0}), expected: 165 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage double_the_difference_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\n// Given a list of numbers, return the sum of squares of the numbers \n// in the list that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference([]int{1, 3, 2, 0})\n// 10\n// >>> double_the_difference([]int{-1, -2, 0})\n// 0\n// >>> double_the_difference([]int{9, -2})\n// 81\n// >>> double_the_difference([]int{0})\n// 0\n// If the input list is empty, return 0.\nfunc double_the_difference(lst []float64) int {\n    sum := 0\n    for _, num := range lst {\n        // Check if the number is an integer and positive\n        if num == math.Trunc(num) && num > 0 {\n            intNum := int(num)\n            // Check if the number is odd\n            if intNum % 2 != 0 {\n                sum += intNum * intNum\n            }\n        }\n    }\n    return sum\n}\n\n// TestDoubleTheDifference tests the double_the_difference function\nfunc TestDoubleTheDifference(t *testing.T) {\n    testCases := []struct {\n        input    []float64\n        expected int\n    }{\n        {[]float64{1, 3, 2, 0}, 10},\n        {[]float64{-1, -2, 0}, 0},\n        {[]float64{9, -2}, 81},\n        {[]float64{0}, 0},\n        {[]float64{}, 0},\n        {[]float64{1.5, 2.3, 3.7}, 0},\n        {[]float64{3, 5, 7.0, 9}, 155},\n    }\n\n    for _, tc := range testCases {\n        result := double_the_difference(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"Expected %v but got %v for input %v\", tc.expected, result, tc.input)\n        }\n    }\n}\n\nfunc main() {\n    // Run tests\n    testing.M()\n}\n```", "task_id": "HumanEval_151_double_the_difference"}
{"name": "HumanEval_152_compare", "language": "go_test.go", "prompt": "package compare_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two lists of scores and guesses of equal length, where each index shows a match. \n// Return a list of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare([]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2})\n// []int{0, 0, 0, 0, 3, 3}\n// >>> compare([]int{0, 5, 0, 0, 0, 4}, []int{4, 1, 1, 0, 0, -2})\n// []int{4, 4, 1, 0, 0, 6}\nfunc compare(game []int, guess []int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_152_compare.py", "prompt_terminology": "reworded", "tests": "func TestCompare(t *testing.T) {\n  candidate := compare\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2}), expected: []int{0, 0, 0, 0, 3, 3} },\n     { actual: candidate([]int{0, 0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0, 0}), expected: []int{0, 0, 0, 0, 0, 0} },\n     { actual: candidate([]int{1, 2, 3}, []int{-1, -2, -3}), expected: []int{2, 4, 6} },\n     { actual: candidate([]int{1, 2, 3, 5}, []int{-1, 2, 3, 4}), expected: []int{2, 0, 0, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage compare_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two lists of scores and guesses of equal length, where each index shows a match. \n// Return a list of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare([]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2})\n// []int{0, 0, 0, 0, 3, 3}\n// >>> compare([]int{0, 5, 0, 0, 0, 4}, []int{4, 1, 1, 0, 0, -2})\n// []int{4, 4, 1, 0, 0, 6}\nfunc compare(game []int, guess []int) []int {\n    result := make([]int, len(game))\n    for i := range game {\n        if game[i] == guess[i] {\n            result[i] = 0\n        } else {\n            result[i] = int(math.Abs(float64(game[i] - guess[i])))\n        }\n    }\n    return result\n}\n\nfunc TestCompare(t *testing.T) {\n    tests := []struct {\n        game, guess, expected []int\n    }{\n        {[]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2}, []int{0, 0, 0, 0, 3, 3}},\n        {[]int{0, 5, 0, 0, 0, 4}, []int{4, 1, 1, 0, 0, -2}, []int{4, 4, 1, 0, 0, 6}},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%v vs %v\", test.game, test.guess), func(t *testing.T) {\n            if got := compare(test.game, test.guess); !equal(got, test.expected) {\n                t.Errorf(\"compare(%v, %v) = %v; want %v\", test.game, test.guess, got, test.expected)\n            }\n        })\n    }\n}\n\n// Helper function to check if two slices are equal\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n```", "task_id": "HumanEval_152_compare"}
{"name": "HumanEval_153_Strongest_Extension", "language": "go_test.go", "prompt": "package Strongest_Extension_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given the name of a class (a string) and a list of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the list.\n// For example, if you are given \"Slices\" as the class and a list of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension(\"my_class\", []string{\"AA\", \"Be\", \"CC\"})\n// \"my_class.AA\"\nfunc Strongest_Extension(class_name string, extensions []string) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_153_Strongest_Extension.py", "prompt_terminology": "reworded", "tests": "func TestStrongest_Extension(t *testing.T) {\n  candidate := Strongest_Extension\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Watashi\", []string{\"tEN\", \"niNE\", \"eIGHt8OKe\"}), expected: \"Watashi.eIGHt8OKe\" },\n     { actual: candidate(\"Boku123\", []string{\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}), expected: \"Boku123.YEs.WeCaNe\" },\n     { actual: candidate(\"__YESIMHERE\", []string{\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}), expected: \"__YESIMHERE.NuLl__\" },\n     { actual: candidate(\"K\", []string{\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}), expected: \"K.TAR\" },\n     { actual: candidate(\"__HAHA\", []string{\"Tab\", \"123\", \"781345\", \"-_-\"}), expected: \"__HAHA.123\" },\n     { actual: candidate(\"YameRore\", []string{\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}), expected: \"YameRore.okIWILL123\" },\n     { actual: candidate(\"finNNalLLly\", []string{\"Die\", \"NowW\", \"Wow\", \"WoW\"}), expected: \"finNNalLLly.WoW\" },\n     { actual: candidate(\"_\", []string{\"Bb\", \"91245\"}), expected: \"_.Bb\" },\n     { actual: candidate(\"Sp\", []string{\"671235\", \"Bb\"}), expected: \"Sp.671235\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage Strongest_Extension_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc Strongest_Extension(class_name string, extensions []string) string {\n    strongestExtension := \"\"\n    maxStrength := -1 << 31 // initialize to min int value\n    \n    for _, ext := range extensions {\n        capCount := 0\n        smCount := 0\n        for _, char := range ext {\n            if char >= 'A' && char <= 'Z' {\n                capCount++\n            }\n            if char >= 'a' && char <= 'z' {\n                smCount++\n            }\n        }\n        strength := capCount - smCount\n        if strength > maxStrength {\n            maxStrength = strength\n            strongestExtension = ext\n        }\n    }\n    \n    return fmt.Sprintf(\"%s.%s\", class_name, strongestExtension)\n}\n\nfunc TestStrongestExtension(t *testing.T) {\n    cases := []struct {\n        className  string\n        extensions []string\n        expected   string\n    }{\n        {\"my_class\", []string{\"AA\", \"Be\", \"CC\"}, \"my_class.AA\"},\n        {\"Slices\", []string{\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"}, \"Slices.SErviNGSliCes\"},\n        {\"Fruit\", []string{\"ApPle\", \"bAnanA\", \"CherrY\"}, \"Fruit.ApPle\"},\n        {\"Shapes\", []string{\"CirCle\", \"triAngLe\", \"SQUAre\"}, \"Shapes.SQUAre\"},\n    }\n\n    for _, c := range cases {\n        got := Strongest_Extension(c.className, c.extensions)\n        if got != c.expected {\n            t.Errorf(\"Strongest_Extension(%q, %v) == %q, want %q\", c.className, c.extensions, got, c.expected)\n        }\n    }\n}\n```\n\nThis code first defines the `Strongest_Extension` function to compute the strongest extension based on the given requirements. It iterates through the list of extensions, calculates the strength of each extension, and keeps track of the extension with the highest strength. Finally, it formats the output as `ClassName.StrongestExtensionName`.\n\nThe `TestStrongestExtension` function contains test cases to verify the correct behavior of the `Strongest_Extension` function.", "task_id": "HumanEval_153_Strongest_Extension"}
{"name": "HumanEval_154_cycpattern_check", "language": "go_test.go", "prompt": "package cycpattern_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check(\"abcd\", \"abd\")\n// false\n// >>> cycpattern_check(\"hello\", \"ell\")\n// true\n// >>> cycpattern_check(\"whassup\", \"psus\")\n// false\n// >>> cycpattern_check(\"abab\", \"baa\")\n// true\n// >>> cycpattern_check(\"efef\", \"eeff\")\n// false\n// >>> cycpattern_check(\"himenss\", \"simen\")\n// true\nfunc cycpattern_check(a string, b string) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_154_cycpattern_check.py", "prompt_terminology": "reworded", "tests": "func TestCycpattern_Check(t *testing.T) {\n  candidate := cycpattern_check\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"xyzw\", \"xyw\"), expected: false },\n     { actual: candidate(\"yello\", \"ell\"), expected: true },\n     { actual: candidate(\"whattup\", \"ptut\"), expected: false },\n     { actual: candidate(\"efef\", \"fee\"), expected: true },\n     { actual: candidate(\"abab\", \"aabb\"), expected: false },\n     { actual: candidate(\"winemtt\", \"tinem\"), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage cycpattern_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n// cycpattern_check returns true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check(\"abcd\", \"abd\")\n// false\n// >>> cycpattern_check(\"hello\", \"ell\")\n// true\n// >>> cycpattern_check(\"whassup\", \"psus\")\n// false\n// >>> cycpattern_check(\"abab\", \"baa\")\n// true\n// >>> cycpattern_check(\"efef\", \"eeff\")\n// false\n// >>> cycpattern_check(\"himenss\", \"simen\")\n// true\nfunc cycpattern_check(a string, b string) bool {\n    if len(b) == 0 {\n        return true\n    }\n    if len(b) > len(a) {\n        return false\n    }\n\n    // Create the expanded string by repeating b twice. Any rotation of b must appear as a substring in b + b.\n    doubledB := b + b\n\n    // Check if any rotation of b is a substring of a\n    for i := 0; i < len(b); i++ {\n        if len(b[i:]) <= len(a) { // To ensure we don't get out of range\n            if substring := doubledB[i : i+len(b)]; strings.Contains(a, substring) {\n                return true\n            }\n        }\n    }\n    return false\n}\n\nfunc TestCycPatternCheck(t *testing.T) {\n    testCases := []struct {\n        a string\n        b string\n        expected bool\n    }{\n        {\"abcd\", \"abd\", false},\n        {\"hello\", \"ell\", true},\n        {\"whassup\", \"psus\", false},\n        {\"abab\", \"baa\", true},\n        {\"efef\", \"eeff\", false},\n        {\"himenss\", \"simen\", true},\n    }\n\n    for _, testCase := range testCases {\n        t.Run(fmt.Sprintf(\"%s_%s\", testCase.a, testCase.b), func(t *testing.T) {\n            result := cycpattern_check(testCase.a, testCase.b)\n            if result != testCase.expected {\n                t.Fatalf(\"expected %v but got %v\", testCase.expected, result)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_154_cycpattern_check"}
{"name": "HumanEval_155_even_odd_count", "language": "go_test.go", "prompt": "package even_odd_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given an integer. return a list that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count(-12)\n// []interface{}{1, 1}\n// >>> even_odd_count(123)\n// []interface{}{1, 2}\nfunc even_odd_count(num int) []interface{} {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_155_even_odd_count.py", "prompt_terminology": "reworded", "tests": "func TestEven_Odd_Count(t *testing.T) {\n  candidate := even_odd_count\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(7), expected: []interface{}{0, 1} },\n     { actual: candidate(-78), expected: []interface{}{1, 1} },\n     { actual: candidate(3452), expected: []interface{}{2, 2} },\n     { actual: candidate(346211), expected: []interface{}{3, 3} },\n     { actual: candidate(-345821), expected: []interface{}{3, 3} },\n     { actual: candidate(-2), expected: []interface{}{1, 0} },\n     { actual: candidate(-45347), expected: []interface{}{2, 3} },\n     { actual: candidate(0), expected: []interface{}{1, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage even_odd_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given an integer, return a list that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count(-12)\n// []interface{}{1, 1}\n// >>> even_odd_count(123)\n// []interface{}{1, 2}\nfunc even_odd_count(num int) []interface{} {\n    evens, odds := 0, 0\n\n    num = abs(num)\n\n    for num > 0 {\n        digit := num % 10\n        if digit % 2 == 0 {\n            evens++\n        } else {\n            odds++\n        }\n        num /= 10\n    }\n\n    return []interface{}{evens, odds}\n}\n\n// Helper function to return the absolute value of an integer\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n\nfunc TestEvenOddCount(t *testing.T) {\n    testCases := []struct {\n        input int\n        expect []interface{}\n    }{\n        {123, []interface{}{1, 2}},\n        {-12, []interface{}{1, 1}},\n        {0, []interface{}{1, 0}},\n        {-1234, []interface{}{2, 2}},\n        {246, []interface{}{3, 0}},\n    }\n\n    for _, tc := range testCases {\n        result := even_odd_count(tc.input)\n        if fmt.Sprintf(\"%v\", result) != fmt.Sprintf(\"%v\", tc.expect) {\n            t.Errorf(\"For input %d: expected %v, got %v\", tc.input, tc.expect, result)\n        }\n    }\n}\n```", "task_id": "HumanEval_155_even_odd_count"}
{"name": "HumanEval_156_int_to_mini_roman", "language": "go_test.go", "prompt": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_156_int_to_mini_roman.py", "prompt_terminology": "reworded", "tests": "func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    val := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n    syb := []string{\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"}\n\n    result := \"\"\n    for i := 0; i < len(val); i++ {\n        for number >= val[i] {\n            number -= val[i]\n            result += syb[i]\n        }\n    }\n    return result\n}\n\nfunc TestIntToMiniRoman(t *testing.T) {\n    tests := []struct {\n        input    int\n        expected string\n    }{\n        {19, \"xix\"},\n        {152, \"clii\"},\n        {426, \"cdxxvi\"},\n        {1, \"i\"},\n        {1000, \"m\"},\n        {99, \"xcix\"},\n        {58, \"lviii\"},\n    }\n\n    for _, test := range tests {\n        result := int_to_mini_roman(test.input)\n        if result != test.expected {\n            t.Errorf(\"int_to_mini_roman(%d) = %s; expected %s\", test.input, result, test.expected)\n        }\n    }\n}\n\nfunc main() {\n    // Example usage\n    fmt.Println(int_to_mini_roman(19))   // Output: \"xix\"\n    fmt.Println(int_to_mini_roman(152))  // Output: \"clii\"\n    fmt.Println(int_to_mini_roman(426))  // Output: \"cdxxvi\"\n}\n```", "task_id": "HumanEval_156_int_to_mini_roman"}
{"name": "HumanEval_157_right_angle_triangle", "language": "go_test.go", "prompt": "package right_angle_triangle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle(3, 4, 5)\n// true\n// >>> right_angle_triangle(1, 2, 3)\n// false\nfunc right_angle_triangle(a int, b int, c int) bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_157_right_angle_triangle.py", "prompt_terminology": "reworded", "tests": "func TestRight_Angle_Triangle(t *testing.T) {\n  candidate := right_angle_triangle\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 4, 5), expected: true },\n     { actual: candidate(1, 2, 3), expected: false },\n     { actual: candidate(10, 6, 8), expected: true },\n     { actual: candidate(2, 2, 2), expected: false },\n     { actual: candidate(7, 24, 25), expected: true },\n     { actual: candidate(10, 5, 7), expected: false },\n     { actual: candidate(5, 12, 13), expected: true },\n     { actual: candidate(15, 8, 17), expected: true },\n     { actual: candidate(48, 55, 73), expected: true },\n     { actual: candidate(1, 1, 1), expected: false },\n     { actual: candidate(2, 2, 10), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage right_angle_triangle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle(3, 4, 5)\n// true\n// >>> right_angle_triangle(1, 2, 3)\n// false\nfunc right_angle_triangle(a int, b int, c int) bool {\n    // Calculate squares of the sides\n    a2 := a * a\n    b2 := b * b\n    c2 := c * c\n\n    // Check if the sum of the squares of any two sides is equal to the square of the third side\n    return (a2 + b2 == c2) || (a2 + c2 == b2) || (b2 + c2 == a2)\n}\n\n// Test function for the right_angle_triangle function\nfunc TestRightAngleTriangle(t *testing.T) {\n    tests := []struct {\n        a, b, c  int\n        expected bool\n    }{\n        {3, 4, 5, true},   // Example of right-angled triangle\n        {1, 2, 3, false},  // Not a right-angled triangle\n        {5, 12, 13, true}, // Another right-angled triangle\n        {7, 24, 25, true}, // Another right-angled triangle\n        {10, 6, 8, true},  // Right-angled triangle with sides unordered\n        {1, 1, 1, false},  // Equilateral triangle, not a right-angled triangle\n    }\n\n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"%d,%d,%d\", tt.a, tt.b, tt.c), func(t *testing.T) {\n            result := right_angle_triangle(tt.a, tt.b, tt.c)\n            if result != tt.expected {\n                t.Errorf(\"Expected %v, got %v\", tt.expected, result)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_157_right_angle_triangle"}
{"name": "HumanEval_158_find_max", "language": "go_test.go", "prompt": "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\", \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n// \"aaaaaaa\"\nfunc find_max(words []string) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_158_find_max.py", "prompt_terminology": "reworded", "tests": "func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\", \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n     { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected: \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\", \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\", \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage find_max_test\n\nimport (\n    \"testing\"\n    \"sort\"\n)\n\n// Write a function that accepts a list of strings.\n// The list contains different words. Return the word with the maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\", \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n// \"aaaaaaa\"\nfunc find_max(words []string) string {\n    uniqueCharCount := func(word string) int {\n        charSet := make(map[rune]struct{})\n        for _, char := range word {\n            charSet[char] = struct{}{}\n        }\n        return len(charSet)\n    }\n\n    maxWord := words[0]\n    maxUniqueChars := uniqueCharCount(maxWord)\n\n    for _, word := range words[1:] {\n        count := uniqueCharCount(word)\n        if count > maxUniqueChars || (count == maxUniqueChars && word < maxWord) {\n            maxUniqueChars = count\n            maxWord = word\n        }\n    }\n    return maxWord\n}\n\nfunc TestFindMax(t *testing.T) {\n    testCases := []struct {\n        words    []string\n        expected string\n    }{\n        {[]string{\"name\", \"of\", \"string\"}, \"string\"},\n        {[]string{\"name\", \"enam\", \"game\"}, \"enam\"},\n        {[]string{\"aaaaaaa\", \"bb\", \"cc\"}, \"aaaaaaa\"},\n        {[]string{\"a\", \"ab\", \"abc\", \"abcd\"}, \"abcd\"},\n        {[]string{\"racecar\", \"banana\", \"apple\"}, \"racecar\"},\n    }\n\n    for _, tc := range testCases {\n        result := find_max(tc.words)\n        if result != tc.expected {\n            t.Errorf(\"find_max(%v) = %v; expected %v\", tc.words, result, tc.expected)\n        }\n    }\n}\n```", "task_id": "HumanEval_158_find_max"}
{"name": "HumanEval_159_eat", "language": "go_test.go", "prompt": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_159_eat.py", "prompt_terminology": "reworded", "tests": "func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// You should return a list of [total number of eaten carrots after your meals,\n// the number of carrots left after your meals].\n// If there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// The number of carrots that you have eaten.\n// @need : integer\n// The number of carrots that you need to eat.\n// @remaining : integer\n// The number of remaining carrots that exist in stock\n// Constraint:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// \n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if need > remaining {\n        number += remaining\n        remaining = 0\n    } else {\n        number += need\n        remaining -= need\n    }\n    return []int{number, remaining}\n}\n\nfunc TestEat(t *testing.T) {\n    cases := []struct{\n        number    int\n        need      int\n        remaining int\n        expected  []int\n    }{\n        {5, 6, 10, []int{11, 4}},\n        {4, 8, 9, []int{12, 1}},\n        {1, 10, 10, []int{11, 0}},\n        {2, 11, 5, []int{7, 0}},\n        {0, 0, 0, []int{0, 0}},\n        {1000, 0, 1000, []int{1000, 1000}},\n        {0, 1000, 1000, []int{1000, 0}},\n        {500, 200, 300, []int{700, 100}},\n        {900, 200, 50, []int{950, 0}},\n    }\n    \n    for _, c := range cases {\n        result := eat(c.number, c.need, c.remaining)\n        if result[0] != c.expected[0] || result[1] != c.expected[1] {\n            t.Errorf(\"eat(%d, %d, %d) == %v, expected %v\", c.number, c.need, c.remaining, result, c.expected)\n        }\n    }\n}\n\nfunc main() {\n    // A simple function to run tests manually.\n    t := testing.T{}\n    TestEat(&t)\n    fmt.Println(\"Tests completed.\")\n}\n```\n\nHere's the complete code that follows the specifications. It includes the function `eat` to calculate the total number of eaten carrots and the remaining carrots after your meals, as well as a test function `TestEat` to validate the logic against several test cases. The `main` function is added to run the tests manually and print a message when the tests are completed.", "task_id": "HumanEval_159_eat"}
{"name": "HumanEval_160_do_algebra", "language": "go_test.go", "prompt": "package do_algebra_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given two lists operator, and operand. The first list has basic algebra operations, and \n// the second list is a list of integers. Use the two given lists to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// list = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator list is equal to the length of operand list minus one.\n// Operand is a list of of non-negative integers.\n// Operator list has at least one operator, and operand list has at least two operands.\nfunc do_algebra(operator []string, operand []int) int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_160_do_algebra.py", "prompt_terminology": "reworded", "tests": "func TestDo_Algebra(t *testing.T) {\n  candidate := do_algebra\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"**\", \"*\", \"+\"}, []int{2, 3, 4, 5}), expected: 37 },\n     { actual: candidate([]string{\"+\", \"*\", \"-\"}, []int{2, 3, 4, 5}), expected: 9 },\n     { actual: candidate([]string{\"//\", \"*\"}, []int{7, 3, 4}), expected: 8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage do_algebra_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n\t\"math\"\n)\n\n// Given two lists operator, and operand. The first list has basic algebra operations, and \n// the second list is a list of integers. Use the two given lists to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// list = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator list is equal to the length of operand list minus one.\n// Operand is a list of of non-negative integers.\n// Operator list has at least one operator, and operand list has at least two operands.\nfunc do_algebra(operator []string, operand []int) int {\n\t// Initiate result with the first operand\n\tresult := operand[0]\n\t\n\tfor i := 0; i < len(operator); i++ {\n\t\tswitch operator[i] {\n\t\tcase \"+\":\n\t\t\tresult += operand[i + 1]\n\t\tcase \"-\":\n\t\t\tresult -= operand[i + 1]\n\t\tcase \"*\":\n\t\t\tresult *= operand[i + 1]\n\t\tcase \"//\":\n\t\t\tresult /= operand[i + 1]\n\t\tcase \"**\":\n\t\t\tresult = int(math.Pow(float64(result), float64(operand[i + 1])))\n\t\t}\n\t}\n\t\n\treturn result\n}\n\n// Unit Test\nfunc TestDoAlgebra(t *testing.T) {\n\ttests := []struct{\n\t\toperator []string\n\t\toperand []int\n\t\twant int\n\t}{\n\t\t{[]string{\"+\", \"*\", \"-\"}, []int{2, 3, 4, 5}, 9},\n\t\t{[]string{\"*\"}, []int{2, 3}, 6},\n\t\t{[]string{\"//\"}, []int{8, 3}, 2},\n\t\t{[]string{\"**\"}, []int{2, 3}, 8},\n\t\t{[]string{\"+\", \"-\"}, []int{5, 3, 1}, 7},\n\t}\n\t\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%v %v\", test.operator, test.operand), func(t *testing.T) {\n\t\t\tgot := do_algebra(test.operator, test.operand)\n\t\t\tif got != test.want {\n\t\t\t\tt.Errorf(\"do_algebra(%v, %v) = %d; want %d\", test.operator, test.operand, got, test.want)\n\t\t\t}\n\t\t})\n\t}\n}\n```", "task_id": "HumanEval_160_do_algebra"}
{"name": "HumanEval_161_solve", "language": "go_test.go", "prompt": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\")\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_161_solve.py", "prompt_terminology": "reworded", "tests": "func TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"unicode\"\n)\n\nfunc solve(s string) string {\n    hasLetter := false\n    for _, ch := range s {\n        if unicode.IsLetter(ch) {\n            hasLetter = true\n            break\n        }\n    }\n\n    if hasLetter {\n        result := []rune(s)\n        for i, ch := range result {\n            if unicode.IsLower(ch) {\n                result[i] = unicode.ToUpper(ch)\n            } else if unicode.IsUpper(ch) {\n                result[i] = unicode.ToLower(ch)\n            }\n        }\n        return string(result)\n    }\n\n    // Reverse the string if it contains no letters\n    result := []rune(s)\n    for i, j := 0, len(result)-1; i < j; i, j = i+1, j-1 {\n        result[i], result[j] = result[j], result[i]\n    }\n    return string(result)\n}\n\nfunc TestSolve(t *testing.T) {\n    testCases := []struct {\n        input    string\n        expected string\n    }{\n        {\"1234\", \"4321\"},\n        {\"ab\", \"AB\"},\n        {\"#a@C\", \"#A@c\"},\n        {\"1234!\", \"!4321\"},\n        {\"Hello World!\", \"hELLO wORLD!\"},\n        {\"\", \"\"},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"%v\", tc.input), func(t *testing.T) {\n            actual := solve(tc.input)\n            if actual != tc.expected {\n                t.Errorf(\"expected %q, but got %q\", tc.expected, actual)\n            }\n        })\n    }\n}\n```", "task_id": "HumanEval_161_solve"}
{"name": "HumanEval_163_generate_integers", "language": "go_test.go", "prompt": "package generate_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers(2, 8)\n// []int{2, 4, 6, 8}\n// >>> generate_integers(8, 2)\n// []int{2, 4, 6, 8}\n// >>> generate_integers(10, 14)\n// []int{}\nfunc generate_integers(a int, b int) []int {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_163_generate_integers.py", "prompt_terminology": "reworded", "tests": "func TestGenerate_Integers(t *testing.T) {\n  candidate := generate_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2, 10), expected: []int{2, 4, 6, 8} },\n     { actual: candidate(10, 2), expected: []int{2, 4, 6, 8} },\n     { actual: candidate(132, 2), expected: []int{2, 4, 6, 8} },\n     { actual: candidate(17, 89), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "stop_tokens": ["\nfunc", "struct", "\n// "], "gpt_solution": "```go\npackage generate_integers_test\n\nimport (\n    \"sort\"\n    \"testing\"\n    \"fmt\"\n)\n\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers(2, 8)\n// []int{2, 4, 6, 8}\n// >>> generate_integers(8, 2)\n// []int{2, 4, 6, 8}\n// >>> generate_integers(10, 14)\n// []int{}\nfunc generate_integers(a int, b int) []int {\n    if a > b {\n        a, b = b, a\n    }\n\n    evens := []int{}\n    for i := a; i <= b; i++ {\n        if i%2 == 0 {\n            evens = append(evens, i)\n        }\n    }\n\n    return evens\n}\n\nfunc TestGenerateIntegers(t *testing.T) {\n    tests := []struct {\n        a        int\n        b        int\n        expected []int\n    }{\n        {2, 8, []int{2, 4, 6, 8}},\n        {8, 2, []int{2, 4, 6, 8}},\n        {10, 14, []int{}},\n        {1, 10, []int{2, 4, 6, 8, 10}},\n        {3, 3, []int{}},\n    }\n\n    for _, test := range tests {\n        result := generate_integers(test.a, test.b)\n        if !equals(result, test.expected) {\n            t.Errorf(\"generate_integers(%d, %d) = %v; expected %v\", test.a, test.b, result, test.expected)\n        }\n    }\n}\n\nfunc equals(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    // Run unit tests\n    results := testing.RunTests(func(string, string) (bool, error) { return true, nil },\n        []testing.InternalTest{{\"TestGenerateIntegers\", TestGenerateIntegers}})\n\n    if results.Failed > 0 {\n        fmt.Println(\"Tests Failed!\")\n    } else {\n        fmt.Println(\"Tests Passed!\")\n    }\n}\n```", "task_id": "HumanEval_163_generate_integers"}

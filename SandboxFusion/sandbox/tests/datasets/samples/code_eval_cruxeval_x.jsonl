{"id": "D_ut_0", "code": "import std.math;\nimport std.typecons;\nimport std.algorithm;\nimport std.array;\n\nTuple!(long, long)[] f(long[] nums) \n{\n    Tuple!(long, long)[] output;\n    foreach (n; nums)\n    {\n        long count = 0;\n        foreach (num; nums)\n        {\n            if (num == n)\n            {\n                count++;\n            }\n        }\n        output ~= tuple(count, n);\n    }\n    output.sort!((a, b) => a > b);\n    return output;\n}\n", "input": "unittest\n{\n    alias candidate = f;\n\n    assert(candidate(????) == [tuple(4L, 1L), tuple(4L, 1L), tuple(4L, 1L), tuple(4L, 1L), tuple(2L, 3L), tuple(2L, 3L)]);\n}\nvoid main(){}", "output": "unittest\n{\n    alias candidate = f;\n\n    assert(candidate([1L, 1L, 3L, 1L, 3L, 1L]) == ????);\n}\nvoid main(){}", "gt": "unittest\n{\n    alias candidate = f;\n\n    assert(candidate([1L, 1L, 3L, 1L, 3L, 1L]) == [tuple(4L, 1L), tuple(4L, 1L), tuple(4L, 1L), tuple(4L, 1L), tuple(2L, 3L), tuple(2L, 3L)]);\n}\nvoid main(){}"}
{"id": "java_0", "code": "import java.io.*;\nimport java.lang.reflect.*;\nimport java.math.*;\nimport java.security.*;\nimport java.util.*;\nimport java.util.stream.*;\nimport org.javatuples.*;\nimport org.javatuples.Pair;\nimport java.util.*;\n\n\nclass Main {\n    public static ArrayList<Pair<Long, Long>> f(ArrayList<Long> nums) {\n        ArrayList<Pair<Long, Long>> output = new ArrayList<>();\n        for (Long n : nums) {\n            output.add(new Pair<>((long) Collections.frequency(nums, n), n));\n        }\n        output.sort((a, b) -> b.getValue0().compareTo(a.getValue0()));\n        return output;\n", "input": "    }\n    public static void main(String[] args) {\n    assert(f(????).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(2l, 3l), (Pair<Long, Long>)Pair.with(2l, 3l))))));\n    }\n\n}\n", "output": "    }\n    public static void main(String[] args) {\n    assert(f((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)1l, (long)3l, (long)1l)))).equals(????));\n    }\n\n}\n", "gt": "    }\n    public static void main(String[] args) {\n    assert(f((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)1l, (long)3l, (long)1l)))).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(2l, 3l), (Pair<Long, Long>)Pair.with(2l, 3l))))));\n    }\n\n}\n"}
{"id": "python_0", "code": "from typing import List, Tuple\n\ndef f(nums: List[int]) -> List[Tuple[int, int]]:    \n    output = []\n    for n in nums:\n        output.append((nums.count(n), n))\n    output.sort(reverse=True)\n    return output\n\n", "input": "def check(candidate):\n    assert candidate(????) == [(4, 1), (4, 1), (4, 1), (4, 1), (2, 3), (2, 3)]\n\ndef test_check():\n    check(f)\n\ntest_check()\n", "output": "def check(candidate):\n    assert candidate([1, 1, 3, 1, 3, 1]) == ????\n\ndef test_check():\n    check(f)\n\ntest_check()\n", "gt": "def check(candidate):\n    assert candidate([1, 1, 3, 1, 3, 1]) == [(4, 1), (4, 1), (4, 1), (4, 1), (2, 3), (2, 3)]\n\ndef test_check():\n    check(f)\n\ntest_check()\n"}
{"id": "perl_0", "code": "\n# \nsub f {\n    my($nums) = @_;\n    my @output;\n    foreach my $n (@$nums) {\n        push @output, (scalar(grep {$_ == $n} @$nums), $n);\n    }\n    @output = sort {$b <=> $a} @output;\n    return @output;\n}\n", "input": "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&f;\n        if(eq_deeply($candidate->(????),[[4, 1], [4, 1], [4, 1], [4, 1], [2, 3], [2, 3]])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();", "output": "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&f;\n        if(eq_deeply($candidate->([1, 1, 3, 1, 3, 1]),????)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();", "gt": "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&f;\n        if(eq_deeply($candidate->([1, 1, 3, 1, 3, 1]),[[4, 1], [4, 1], [4, 1], [4, 1], [2, 3], [2, 3]])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"}
{"id": "ruby_0", "code": "def f(nums)\n  output = []\n  nums.each do |n|\n    output.append([nums.count(n), n])\n  end\n  output.sort.reverse\nend\n", "input": "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_f\n    candidate = method(:f)\n    assert_equal([[4, 1], [4, 1], [4, 1], [4, 1], [2, 3], [2, 3]], candidate.call(????))\n  end\nend\n", "output": "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_f\n    candidate = method(:f)\n    assert_equal(????, candidate.call([1, 1, 3, 1, 3, 1]))\n  end\nend\n", "gt": "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_f\n    candidate = method(:f)\n    assert_equal([[4, 1], [4, 1], [4, 1], [4, 1], [2, 3], [2, 3]], candidate.call([1, 1, 3, 1, 3, 1]))\n  end\nend\n"}
{"id": "lua_0", "code": "function f(nums)\n    local output = {}\n    for i, n in ipairs(nums) do\n        local count = 0\n        for _, v in ipairs(nums) do\n            if v == n then\n                count = count + 1\n            end\n        end\n        table.insert(output, {count, n})\n    end\n    table.sort(output, function(a, b) return a[1] > b[1] end)\n    return output\nend\n", "input": "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = f\n    lu.assertEquals(candidate(????), {{4, 1}, {4, 1}, {4, 1}, {4, 1}, {2, 3}, {2, 3}})\nend\n\nos.exit(lu.LuaUnit.run())", "output": "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = f\n    lu.assertEquals(candidate({1, 1, 3, 1, 3, 1}), ????)\nend\n\nos.exit(lu.LuaUnit.run())", "gt": "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = f\n    lu.assertEquals(candidate({1, 1, 3, 1, 3, 1}), {{4, 1}, {4, 1}, {4, 1}, {4, 1}, {2, 3}, {2, 3}})\nend\n\nos.exit(lu.LuaUnit.run())"}
{"id": "rust_0", "code": "fn f(nums: Vec<isize>) -> Vec<(isize, isize)> {\n    let mut output: Vec<(isize, isize)> = Vec::new();\n    for &n in &nums {\n        output.push((nums.iter().filter(|&x| *x == n).count() as isize, n));\n    }\n    output.sort_by(|a, b| b.0.cmp(&a.0));\n    output\n", "input": "}\n\nfn main() {\n    let candidate = f;\n    assert_eq!(candidate(????), vec![(4, 1), (4, 1), (4, 1), (4, 1), (2, 3), (2, 3)]);\n}\n", "output": "}\n\nfn main() {\n    let candidate = f;\n    assert_eq!(candidate(vec![1, 1, 3, 1, 3, 1]), ????);\n}\n", "gt": "}\n\nfn main() {\n    let candidate = f;\n    assert_eq!(candidate(vec![1, 1, 3, 1, 3, 1]), vec![(4, 1), (4, 1), (4, 1), (4, 1), (2, 3), (2, 3)]);\n}\n"}
{"id": "julia_0", "code": "function f(nums::Vector{Int64})::Vector{Tuple{Int64, Int64}} \n    output = []\n    for n in nums\n        push!(output, (count(x->x==n, nums), n))\n    end\n    sort!(output, rev=true)\n    return output\nend\n", "input": "using Test\n\n@testset begin\n\ncandidate = f;\n\t@test(candidate(????) == [(4, 1), (4, 1), (4, 1), (4, 1), (2, 3), (2, 3)])\nend\n", "output": "using Test\n\n@testset begin\n\ncandidate = f;\n\t@test(candidate([1, 1, 3, 1, 3, 1]) == ????)\nend\n", "gt": "using Test\n\n@testset begin\n\ncandidate = f;\n\t@test(candidate([1, 1, 3, 1, 3, 1]) == [(4, 1), (4, 1), (4, 1), (4, 1), (2, 3), (2, 3)])\nend\n"}
{"id": "bash_0", "code": "#!/bin/bash\n# $1 is a space-separated list\nf() {\n    nums=($1)\n    declare -A count_map\n    output=()\n\n    # Count occurrences\n    for n in \"${nums[@]}\"; do\n        ((count_map[$n]++))\n    done\n\n    # Create output list\n    for n in \"${nums[@]}\"; do\n        output+=(\"${count_map[$n]} $n\")\n    done\n\n    # Sort output list in reverse order\n    printf \"%s\\n\" \"${output[@]}\" | sort -r\n", "input": "}\n\ncandidate() {\n    f \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate ????) = \"4 1\n4 1\n4 1\n4 1\n2 3\n2 3\" ]]\n}\n\nrun_test", "output": "}\n\ncandidate() {\n    f \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 1 3 1 3 1\") = ???? ]]\n}\n\nrun_test", "gt": "}\n\ncandidate() {\n    f \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 1 3 1 3 1\") = \"4 1\n4 1\n4 1\n4 1\n2 3\n2 3\" ]]\n}\n\nrun_test"}
{"id": "scala_0", "code": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def f(nums : List[Long]) : List[Tuple2[Long, Long]] = {\n        var output: ListBuffer[(Long, Long)] = ListBuffer()\n        for (n <- nums) {\n            output += ((nums.count(_ == n), n))\n        }\n        output = output.sortWith((a, b) => a._1 > b._1)\n        output.toList\n", "input": "    }\n    def main(args: Array[String]) = {\n    assert(f(????).equals((List[Tuple2[Long, Long]]((4l, 1l), (4l, 1l), (4l, 1l), (4l, 1l), (2l, 3l), (2l, 3l)))));\n    }\n\n}\n", "output": "    }\n    def main(args: Array[String]) = {\n    assert(f((List[Long](1l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong))).equals(????));\n    }\n\n}\n", "gt": "    }\n    def main(args: Array[String]) = {\n    assert(f((List[Long](1l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong))).equals((List[Tuple2[Long, Long]]((4l, 1l), (4l, 1l), (4l, 1l), (4l, 1l), (2l, 3l), (2l, 3l)))));\n    }\n\n}\n"}
{"id": "racket_0", "code": "\n#lang racket\n\n(require srfi/1)\n\n(define (f nums)\n  (define output '())\n  (for ([n (in-list nums)])\n    (set! output (cons (list (count (curryr = n) nums) n) output)))\n  (sort output > #:key car))\n", "input": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate f))\n    (check-within (candidate ????) (list (list 4 1) (list 4 1) (list 4 1) (list 4 1) (list 2 3) (list 2 3)) 0.001)\n))\n\n(test-humaneval)", "output": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate f))\n    (check-within (candidate (list 1 1 3 1 3 1)) ???? 0.001)\n))\n\n(test-humaneval)", "gt": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate f))\n    (check-within (candidate (list 1 1 3 1 3 1)) (list (list 4 1) (list 4 1) (list 4 1) (list 4 1) (list 2 3) (list 2 3)) 0.001)\n))\n\n(test-humaneval)"}
{"id": "swift_0", "code": "\n/// \nfunc f(nums: [Int]) -> [(Int, Int)] {\n    var output: [(Int, Int)] = []\n    for n in nums {\n        output.append((nums.filter{$0 == n}.count, n))\n    }\n    output.sort { $0.0 > $1.0 }\n    return output\n", "input": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(????) == [(4, 1), (4, 1), (4, 1), (4, 1), (2, 3), (2, 3)])", "output": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [1, 1, 3, 1, 3, 1]) == ????)", "gt": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(nums: [1, 1, 3, 1, 3, 1]) == [(4, 1), (4, 1), (4, 1), (4, 1), (2, 3), (2, 3)])"}
{"id": "csharp_0", "code": "\nusing System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    public static List<Tuple<long, long>> F(List<long> nums) {\n        List<Tuple<long, long>> output = new List<Tuple<long, long>>();\n        foreach (var n in nums)\n        {\n            output.Add(new Tuple<long, long>(nums.Count(x => x == n), n));\n        }\n        output.Sort((x, y) => y.Item1.CompareTo(x.Item1));\n        return output;\n", "input": "    }\n    public static void Main(string[] args) {\n    Debug.Assert(F(????).SequenceEqual((new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(4L, 1L), (Tuple<long, long>)Tuple.Create(4L, 1L), (Tuple<long, long>)Tuple.Create(4L, 1L), (Tuple<long, long>)Tuple.Create(4L, 1L), (Tuple<long, long>)Tuple.Create(2L, 3L), (Tuple<long, long>)Tuple.Create(2L, 3L)}))));\n    }\n\n}\n", "output": "    }\n    public static void Main(string[] args) {\n    Debug.Assert(F((new List<long>(new long[]{(long)1L, (long)1L, (long)3L, (long)1L, (long)3L, (long)1L}))).SequenceEqual(????));\n    }\n\n}\n", "gt": "    }\n    public static void Main(string[] args) {\n    Debug.Assert(F((new List<long>(new long[]{(long)1L, (long)1L, (long)3L, (long)1L, (long)3L, (long)1L}))).SequenceEqual((new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(4L, 1L), (Tuple<long, long>)Tuple.Create(4L, 1L), (Tuple<long, long>)Tuple.Create(4L, 1L), (Tuple<long, long>)Tuple.Create(4L, 1L), (Tuple<long, long>)Tuple.Create(2L, 3L), (Tuple<long, long>)Tuple.Create(2L, 3L)}))));\n    }\n\n}\n"}
{"id": "typescript_0", "code": "function f(nums: number[]): [number, number][] {\n    const output: [number, number][] = [];\n    nums.forEach(n => {\n        output.push([nums.filter(num => num === n).length, n]);\n    });\n    output.sort((a, b) => b[0] - a[0]);\n    return output;\n}\n", "input": "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = f;\n  assert.deepEqual(candidate(????),[[4, 1], [4, 1], [4, 1], [4, 1], [2, 3], [2, 3]]);\n}\n\ntest();", "output": "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = f;\n  assert.deepEqual(candidate([1, 1, 3, 1, 3, 1]),????);\n}\n\ntest();", "gt": "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = f;\n  assert.deepEqual(candidate([1, 1, 3, 1, 3, 1]),[[4, 1], [4, 1], [4, 1], [4, 1], [2, 3], [2, 3]]);\n}\n\ntest();"}
{"id": "R_0", "code": "f <- function(nums) {    output <- list()\n    for (n in nums) {\n        count <- sum(nums == n)\n        output <- c(output, list(c(count, n)))\n    }\n    output <- output[order(sapply(output, `[[`, 1), decreasing = TRUE)]\n    return(output)\n}\n", "input": "test_humaneval <- function() {\n    candidate <- f\n    stopifnot(isTRUE(all.equal(candidate(????), list(c(4, 1), c(4, 1), c(4, 1), c(4, 1), c(2, 3), c(2, 3)))))\n}\ntest_humaneval()", "output": "test_humaneval <- function() {\n    candidate <- f\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 3, 1, 3, 1)), ????)))\n}\ntest_humaneval()", "gt": "test_humaneval <- function() {\n    candidate <- f\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 3, 1, 3, 1)), list(c(4, 1), c(4, 1), c(4, 1), c(4, 1), c(2, 3), c(2, 3)))))\n}\ntest_humaneval()"}
{"id": "php_0", "code": "\n<?php\nfunction f($nums) {\n    $output = [];\n    foreach ($nums as $n) {\n        $output[] = array(array_count_values($nums)[$n] ?? 0, $n);\n    }\n    usort($output, function($a, $b) {\n        return $b[0] <=> $a[0];\n    });\n    return $output;\n}\n\n", "input": "function candidate(...$args) {\n    return f(...$args);\n}\n\nfunction test(): void {\n    if (candidate(????) !== array(array(4, 1), array(4, 1), array(4, 1), array(4, 1), array(2, 3), array(2, 3))) { throw new Exception(\"Test failed!\"); }\n}\n\ntest();", "output": "function candidate(...$args) {\n    return f(...$args);\n}\n\nfunction test(): void {\n    if (candidate(array(1, 1, 3, 1, 3, 1)) !== ????) { throw new Exception(\"Test failed!\"); }\n}\n\ntest();", "gt": "function candidate(...$args) {\n    return f(...$args);\n}\n\nfunction test(): void {\n    if (candidate(array(1, 1, 3, 1, 3, 1)) !== array(array(4, 1), array(4, 1), array(4, 1), array(4, 1), array(2, 3), array(2, 3))) { throw new Exception(\"Test failed!\"); }\n}\n\ntest();"}
{"id": "cpp_0", "code": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::tuple<long, long>> f(std::vector<long> nums) {\n    std::vector<std::tuple<long, long>> output;\n    for (long n : nums) {\n        output.push_back(std::make_tuple(std::count(nums.begin(), nums.end(), n), n));\n    }\n    std::sort(output.begin(), output.end(), std::greater<>());\n    return output;\n", "input": "}\nint main() {\n    auto candidate = f;\n    assert(candidate(????) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(2, 3), (std::tuple<long, long>)std::make_tuple(2, 3)})));\n}\n", "output": "}\nint main() {\n    auto candidate = f;\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)3, (long)1, (long)3, (long)1}))) == ????);\n}\n", "gt": "}\nint main() {\n    auto candidate = f;\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)3, (long)1, (long)3, (long)1}))) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(2, 3), (std::tuple<long, long>)std::make_tuple(2, 3)})));\n}\n"}
{"id": "nodejs_0", "code": "function f(nums){\n    let output = [];\n    nums.forEach(n => {\n        output.push([nums.filter(num => num === n).length, n]);\n    });\n    output.sort((a, b) => b[0] - a[0]);\n    return output;\n}\n", "input": "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = f;\n  assert.deepEqual(candidate(????),[[4, 1], [4, 1], [4, 1], [4, 1], [2, 3], [2, 3]]);\n}\n\ntest();", "output": "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = f;\n  assert.deepEqual(candidate([1, 1, 3, 1, 3, 1]),????);\n}\n\ntest();", "gt": "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = f;\n  assert.deepEqual(candidate([1, 1, 3, 1, 3, 1]),[[4, 1], [4, 1], [4, 1], [4, 1], [2, 3], [2, 3]]);\n}\n\ntest();"}
{"id": "go_test_2", "code": "package f_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc f(text string) string {\n    new_text := []rune(text)\n    for _, i := range []rune(\"+\") {\n        for index, char := range new_text {\n            if char == i {\n                new_text = append(new_text[:index], new_text[index+1:]...)\n                break\n            }\n        }\n    }\n    return string(new_text)\n}\n", "input": "func TestF(t *testing.T) {\n  candidate := f\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(????), expected: \"hbtofdeiequ\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "output": "func TestF(t *testing.T) {\n  candidate := f\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"hbtofdeiequ\"), expected: ???? },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "gt": "func TestF(t *testing.T) {\n  candidate := f\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"hbtofdeiequ\"), expected: \"hbtofdeiequ\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"}

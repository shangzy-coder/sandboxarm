{"canonical_solution": "```python\nimport string\nfrom collections import Counter\n\n\ndef word_count(file_path):\n    try:\n        # 读取文件内容\n        with open(file_path, 'r', encoding='utf-8') as file:\n            content = file.read()\n\n        # 移除标点符号并转换为小写\n        translator = str.maketrans(\"\", \"\", string.punctuation)\n        content = content.translate(translator).lower()\n\n        # 使用 Counter 统计单词出现次数\n        words = content.split()\n        word_counter = Counter(words)\n\n        # 按照出现次数降序排列\n        sorted_word_count = sorted(word_counter.items(), key=lambda x: x[1], reverse=True)\n\n        for word, count in sorted_word_count:\n            print(f\"'{word}': {count}\")\n\n    except FileNotFoundError:\n        print(f\"Error: File '{file_path}' not found.\")\n```", "content": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n创建一个名为`word_count`的函数，该函数接受一个文件路径作为参数，读取文件内容，并统计文件中每个单词出现的次数。函数应返回一个字典，其中键是单词，值是该单词在文件中出现的次数。要求忽略单词的大小写，并移除标点符号。最后，按照单词出现的次数降序排列字典项。如果有多个单词出现次数相同，按照字母顺序升序排列。函数不需要处理文件不存在的情况。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testword_count:\n    def test_word_count_basic_file(self, capfd, tmp_path):\n        file_path = tmp_path / 'test_basic.txt'\n        with open(file_path, 'w', encoding='utf-8') as file:\n            file.write(\"This is a basic test file with some common words.\")\n        word_count(file_path)\n        captured = capfd.readouterr()\n        assert \"'this': 1\\n'is': 1\\n'a': 1\\n'basic': 1\\n'test': 1\\n'file': 1\\n'with': 1\\n'some': 1\\n'common': 1\\n'words': 1\\n\" in captured.out\n\n\n", "id": 0, "labels": "{\"execution_language\":\"python\", \"original_id\":131, \"original_promblem\":\"创建一个名为`word_count`的函数，该函数接受一个文件路径作为参数，读取文件内容，并统计文件中每个单词出现的次数。函数应返回一个字典，其中键是单词，值是该单词在文件中出现的次数。要求忽略单词的大小写，并移除标点符号。最后，按照单词出现的次数降序排列字典项。如果有多个单词出现次数相同，按照字母顺序升序排列。函数不需要处理文件不存在的情况。\", \"programming_language\":\"python\", \"tags\":\"算法和数据结构\"}", "test": "{\"asset\":null, \"code\":\"import string\\nfrom collections import Counter\\n\\n\\nclass Testword_count:\\n    def test_word_count_case_sensitive_file(self, capfd, tmp_path):\\n        file_path = tmp_path / 'test_case_sensitive.txt'\\n        with open(file_path, 'w', encoding='utf-8') as file:\\n            file.write(\\\"Case case CASE\\\")\\n        word_count(file_path)\\n        captured = capfd.readouterr()\\n        assert \\\"'case': 3\\\" in captured.out\\n\\n\\n    def test_word_count_punctuation_file(self, capfd, tmp_path):\\n        file_path = tmp_path / 'test_punctuation.txt'\\n        with open(file_path, 'w', encoding='utf-8') as file:\\n            file.write(\\\"This sentence has some punctuation, like commas and periods.\\\")\\n        word_count(file_path)\\n        captured = capfd.readouterr()\\n        assert \\\"'this': 1\\\\n'sentence': 1\\\\n'has': 1\\\\n'some': 1\\\\n'punctuation': 1\\\\n'like': 1\\\\n'commas': 1\\\\n'and': 1\\\\n'periods': 1\\\\n\\\" in captured.out\\n\\n\\n    def test_word_count_same_word_file(self, capfd, tmp_path):\\n        file_path = tmp_path / 'test_same_word_multiple_times.txt'\\n        with open(file_path, 'w', encoding='utf-8') as file:\\n            file.write(\\\"word word word word word\\\")\\n        word_count(file_path)\\n        captured = capfd.readouterr()\\n        assert \\\"'word': 5\\\" in captured.out\\n\\n    def test_word_count_different_words_file(self, capfd, tmp_path):\\n        file_path = tmp_path / 'test_different_words_same_count.txt'\\n        with open(file_path, 'w', encoding='utf-8') as file:\\n            file.write(\\\"apple banana orange\\\")\\n        word_count(file_path)\\n        captured = capfd.readouterr()\\n        assert \\\"'apple': 1\\\\n'banana': 1\\\\n'orange': 1\\\\n\\\" in captured.out\\n\\n    def test_word_count_nonexistent_file(self, capfd, tmp_path):\\n        file_path = tmp_path / 'nonexistent_file.txt'\\n        word_count(file_path)\\n        captured = capfd.readouterr()\\n        assert \\\"Error: File\\\" in captured.out\\n\\n    def test_word_count_empty_file(self, capfd, tmp_path):\\n        file_path = tmp_path / 'test_empty_file.txt'\\n        open(file_path, 'w', encoding='utf-8').close()  # 创建一个空文件\\n        word_count(file_path)\\n        captured = capfd.readouterr()\\n        assert captured.out.strip() == \\\"\\\"  # 期望输出为空字符串\\n\\n\"}", "__internal_uuid__": "3d4b910f-f91b-4011-a620-9e73cbfb9587"}
{"canonical_solution": "```python\nimport re\n\n\ndef remove_html_tags(s: str) -> str:\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string\")\n\n    if not s:\n        return \"\"\n\n    # 定义新的正则表达式模式\n    tag_pattern = r\"<[^>]*>\"\n    comment_pattern = r\"<!--.*?-->\"\n    doctype_pattern = r\"<!DOCTYPE[^>]*>\"\n\n    # 移除 HTML 注释和 DOCTYPE\n    s = re.sub(comment_pattern, \"\", s)\n    s = re.sub(doctype_pattern, \"\", s)\n\n    # 移除标签\n    s = re.sub(tag_pattern, \"\", s)\n\n    # 返回处理后的字符串\n    return s.strip()\n\n\n\n```", "content": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n定义一个名为 remove_html_tags 的函数，用于从输入的字符串中移除 HTML 标签、注释和文档类型声明。以下是对程序功能和每个步骤的描述：\n\nremove_html_tags 函数：\n\n用途：移除输入字符串中的 HTML 标签、注释和文档类型声明。\n参数：\ns：输入的字符串。\n返回值：\n处理后的字符串，其中移除 HTML 标签、注释和文档类型声明。\n主要过程：\n\n首先，检查输入是否为字符串，如果不是则抛出 ValueError。\n如果输入字符串为空，直接返回空字符串。\n定义三个正则表达式模式：\ntag_pattern：用于匹配 HTML 标签。\ncomment_pattern：用于匹配 HTML 注释。\ndoctype_pattern：用于匹配文档类型声明。\n使用 re.sub 方法，分别移除 HTML 注释、文档类型声明和 HTML 标签。\n返回处理后的字符串，经过处理后的字符串已移除 HTML 注释、文档类型声明和 HTML 标签，同时去除字符串两端的空白。\n该程序通过使用正则表达式模式，对输入字符串进行多次替换操作，从而实现移除 HTML 注释、文档类型声明和 HTML 标签的功能。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testremove_html_tags:\n    def test_basic_tags(self):\n        html_string = \"<p>Hello, <strong>world!</strong></p>\"\n        assert remove_html_tags(html_string) == \"Hello, world!\"\n\n", "id": 1, "labels": "{\"execution_language\":\"python\", \"original_id\":132, \"original_promblem\":\"定义一个名为 remove_html_tags 的函数，用于从输入的字符串中移除 HTML 标签、注释和文档类型声明。以下是对程序功能和每个步骤的描述：\\n\\nremove_html_tags 函数：\\n\\n用途：移除输入字符串中的 HTML 标签、注释和文档类型声明。\\n参数：\\ns：输入的字符串。\\n返回值：\\n处理后的字符串，其中移除 HTML 标签、注释和文档类型声明。\\n主要过程：\\n\\n首先，检查输入是否为字符串，如果不是则抛出 ValueError。\\n如果输入字符串为空，直接返回空字符串。\\n定义三个正则表达式模式：\\ntag_pattern：用于匹配 HTML 标签。\\ncomment_pattern：用于匹配 HTML 注释。\\ndoctype_pattern：用于匹配文档类型声明。\\n使用 re.sub 方法，分别移除 HTML 注释、文档类型声明和 HTML 标签。\\n返回处理后的字符串，经过处理后的字符串已移除 HTML 注释、文档类型声明和 HTML 标签，同时去除字符串两端的空白。\\n该程序通过使用正则表达式模式，对输入字符串进行多次替换操作，从而实现移除 HTML 注释、文档类型声明和 HTML 标签的功能。\", \"programming_language\":\"python\", \"tags\":\"前端开发\"}", "test": "{\"asset\":null, \"code\":\"import re\\n\\n\\nclass Testremove_html_tags:\\n    def test_multiple_tags(self):\\n        html_string = \\\"<h1>Title</h1><p>Paragraph</p>\\\"\\n        assert remove_html_tags(html_string) == \\\"TitleParagraph\\\"\\n\\n    def test_special_characters(self):\\n        html_string = '<a href=\\\"https://example.com\\\">Click here</a>'\\n        assert remove_html_tags(html_string) == \\\"Click here\\\"\\n\\n    def test_comments(self):\\n        html_string = \\\"<p>Hello <!-- Comment -->world!</p>\\\"\\n        assert remove_html_tags(html_string) == \\\"Hello world!\\\"\\n\\n    def test_empty_tags(self):\\n        html_string = \\\"<br/>\\\"\\n        assert remove_html_tags(html_string) == \\\"\\\"\\n\\n    def test_doctype_declaration(self):\\n        html_string = \\\"<!DOCTYPE html><html><body>Hello, world!</body></html>\\\"\\n        assert remove_html_tags(html_string) == \\\"Hello, world!\\\"\\n\\n    def test_empty_string(self):\\n        html_string = \\\"\\\"\\n        assert remove_html_tags(html_string) == \\\"\\\"\\n\\n    def test_nonstring_input(self):\\n        invalid_input = \\\"123\\\"\\n        assert remove_html_tags(invalid_input) == \\\"123\\\"\\n\"}", "__internal_uuid__": "0e179615-7948-4a8d-82e0-96d3cc0edc03"}
{"canonical_solution": "```python\nfrom datetime import datetime\n\nclass Schedule:\n    def __init__(self):\n        self.events = {}\n\n    def add_event(self, event_name, event_date):\n        if event_date in self.events:\n            self.events[event_date].append(event_name)\n        else:\n            self.events[event_date] = [event_name]\n\n    def view_events(self):\n        for event_date, event_names in self.events.items():\n            print(f\"{event_date.strftime('%Y-%m-%d %H:%M')}:\")\n            for event_name in event_names:\n                print(f\"- {event_name}\")\n            print()\n\n    def remove_event(self, event_name, event_date):\n        if event_date in self.events:\n            if event_name in self.events[event_date]:\n                self.events[event_date].remove(event_name)\n                if not self.events[event_date]:\n                    del self.events[event_date]\n                print(f\"已删除事件：{event_name}\")\n                return\n        print(f\"未找到事件'{event_name}'\")\n\n\n```", "content": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个程序，\"实现简易日程管理器：Python类实现事件添加、查看和删除功能\"\n定义一个名为 Schedule 的类，实现简单的日程管理系统。以下是对该代码的描述：\n\nSchedule 类：\n\n用途：表示一个日程管理系统，能够添加、查看和删除事件。\n属性：\nevents：字典，用于存储事件信息，键为事件日期，值为该日期下的事件列表。\n主要方法：\n\n__init__(self)：\n\n初始化方法，创建一个空的事件字典。\nadd_event(self, event_name, event_date)：\n\n添加事件的方法，接收事件名称和日期，将事件添加到相应日期的事件列表中。\n如果日期已存在，则将事件添加到现有列表中，否则创建一个新的列表。\nview_events(self)：\n\n查看所有事件的方法，按日期打印事件列表。\n使用 strftime 方法将日期格式化为\"YYYY-MM-DD HH:MM\"的形式。\nremove_event(self, event_name, event_date)：\n\n删除事件的方法，接收事件名称和日期，从相应日期的事件列表中删除指定事件。\n如果删除后列表为空，同时删除该日期的条目。\n如果未找到指定事件，则输出\"未找到事件'{event_name}'\"\n主要过程：\n\n使用 datetime 模块的 strftime 方法对日期进行格式化。\n添加事件时，检查日期是否已存在，如果存在则追加，否则创建新的日期条目。\n查看事件时，按日期遍历字典，打印每个日期下的事件列表。\n删除事件时，检查指定日期下是否有该事件，如果有则删除，同时检查列表是否为空，若为空则删除该日期的条目。\n该类提供了一种简单的方式来管理日程安排，用户可以添加、查看和删除事件。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass TestSchedule:\n    def test_add_event(self, schedule):\n        # 添加事件\n        event_date = datetime(2023, 12, 20, 18, 0)\n        schedule.add_event(\"生日聚会\", event_date)\n\n        # 断言事件是否添加成功\n        assert event_date in schedule.events\n        assert \"生日聚会\" in schedule.events[event_date]\n\n", "id": 2, "labels": "{\"execution_language\":\"python\", \"original_id\":133, \"original_promblem\":\"编写一个程序，\\\"实现简易日程管理器：Python类实现事件添加、查看和删除功能\\\"\\n定义一个名为 Schedule 的类，实现简单的日程管理系统。以下是对该代码的描述：\\n\\nSchedule 类：\\n\\n用途：表示一个日程管理系统，能够添加、查看和删除事件。\\n属性：\\nevents：字典，用于存储事件信息，键为事件日期，值为该日期下的事件列表。\\n主要方法：\\n\\n__init__(self)：\\n\\n初始化方法，创建一个空的事件字典。\\nadd_event(self, event_name, event_date)：\\n\\n添加事件的方法，接收事件名称和日期，将事件添加到相应日期的事件列表中。\\n如果日期已存在，则将事件添加到现有列表中，否则创建一个新的列表。\\nview_events(self)：\\n\\n查看所有事件的方法，按日期打印事件列表。\\n使用 strftime 方法将日期格式化为\\\"YYYY-MM-DD HH:MM\\\"的形式。\\nremove_event(self, event_name, event_date)：\\n\\n删除事件的方法，接收事件名称和日期，从相应日期的事件列表中删除指定事件。\\n如果删除后列表为空，同时删除该日期的条目。\\n如果未找到指定事件，则输出\\\"未找到事件'{event_name}'\\\"\\n主要过程：\\n\\n使用 datetime 模块的 strftime 方法对日期进行格式化。\\n添加事件时，检查日期是否已存在，如果存在则追加，否则创建新的日期条目。\\n查看事件时，按日期遍历字典，打印每个日期下的事件列表。\\n删除事件时，检查指定日期下是否有该事件，如果有则删除，同时检查列表是否为空，若为空则删除该日期的条目。\\n该类提供了一种简单的方式来管理日程安排，用户可以添加、查看和删除事件。\", \"programming_language\":\"python\", \"tags\":\"软件工程\"}", "test": "{\"asset\":null, \"code\":\"from datetime import datetime\\n\\n\\nclass TestSchedule:\\n    @pytest.fixture\\n    def schedule(self):\\n        return Schedule()\\n\\n    def test_add_event(self, schedule):\\n        # 添加事件\\n        event_date = datetime(2023, 12, 20, 18, 0)\\n        schedule.add_event(\\\"生日聚会\\\", event_date)\\n\\n        # 断言事件是否添加成功\\n        assert event_date in schedule.events\\n        assert \\\"生日聚会\\\" in schedule.events[event_date]\\n\\n    def test_add_duplicate_event(self, schedule):\\n        # 添加重复的事件\\n        event_date = datetime(2023, 12, 20, 18, 0)\\n        schedule.add_event(\\\"生日聚会\\\", event_date)\\n        schedule.add_event(\\\"生日聚会\\\", event_date)\\n\\n        # 断言只添加了一个事件\\n        assert len(schedule.events[event_date]) == 2\\n\\n    def test_view_events(self, schedule, capsys):\\n        # 添加事件\\n        schedule.add_event(\\\"生日聚会\\\", datetime(2023, 12, 20, 18, 0))\\n        schedule.add_event(\\\"项目截止日期\\\", datetime(2023, 12, 25, 23, 59))\\n        schedule.add_event(\\\"面试\\\", datetime(2024, 1, 5, 14, 30))\\n\\n        # 查看事件\\n        schedule.view_events()\\n        captured = capsys.readouterr()\\n\\n        # 断言输出是否正确\\n        assert \\\"2023-12-20 18:00:\\\\n- 生日聚会\\\\n\\\\n\\\" in captured.out\\n        assert \\\"2023-12-25 23:59:\\\\n- 项目截止日期\\\\n\\\\n\\\" in captured.out\\n        assert \\\"2024-01-05 14:30:\\\\n- 面试\\\\n\\\\n\\\" in captured.out\\n\\n    def test_remove_event(self, schedule, capsys):\\n        # 添加事件\\n        event_date = datetime(2023, 12, 20, 18, 0)\\n        schedule.add_event(\\\"生日聚会\\\", event_date)\\n\\n        # 删除事件\\n        schedule.remove_event(\\\"生日聚会\\\", event_date)\\n\\n        # 查看事件\\n        schedule.view_events()\\n        captured = capsys.readouterr()\\n\\n        # 断言事件是否删除成功\\n        assert \\\"2023-12-20 18:00:\\\\n\\\" not in captured.out\\n\\n    def test_remove_nonexistent_event(self, schedule, capsys):\\n        # 添加事件\\n        schedule.add_event(\\\"生日聚会\\\", datetime(2023, 12, 20, 18, 0))\\n\\n        # 删除不存在的事件\\n        schedule.remove_event(\\\"项目截止日期\\\", datetime(2023, 12, 25, 23, 59))\\n\\n        # 查看事件\\n        schedule.view_events()\\n        captured = capsys.readouterr()\\n\\n        # 断言是否输出了相应的错误信息\\n        assert \\\"未找到事件'项目截止日期'\\\" in captured.out\\n\\n    def test_remove_event_multiple_times(self, schedule, capsys):\\n        # 添加事件\\n        event_date = datetime(2023, 12, 20, 18, 0)\\n        schedule.add_event(\\\"生日聚会\\\", event_date)\\n\\n        # 多次删除事件\\n        schedule.remove_event(\\\"生日聚会\\\", event_date)\\n        schedule.remove_event(\\\"生日聚会\\\", event_date)\\n\\n        # 查看事件\\n        schedule.view_events()\\n        captured = capsys.readouterr()\\n\\n        # 断言事件是否只删除了一次\\n        assert \\\"2023-12-20 18:00:\\\\n\\\" not in captured.out\\n\\n    def test_remove_event_with_different_date(self, schedule, capsys):\\n        # 添加事件\\n        event_date1 = datetime(2023, 12, 20, 18, 0)\\n        event_date2 = datetime(2023, 12, 25, 23, 59)\\n        schedule.add_event(\\\"生日聚会\\\", event_date1)\\n        schedule.add_event(\\\"项目截止日期\\\", event_date2)\\n\\n        # 删除不同日期的事件\\n        schedule.remove_event(\\\"生日聚会\\\", event_date2)\\n\\n        # 查看事件\\n        schedule.view_events()\\n        captured = capsys.readouterr()\\n\\n        # 断言事件是否删除成功\\n        assert \\\"2023-12-20 18:00:\\\\n- 生日聚会\\\\n\\\\n\\\" in captured.out\\n        assert \\\"2023-12-25 23:59:\\\\n- 项目截止日期\\\\n\\\\n\\\" in captured.out\\n\\n    def test_remove_event_from_empty_schedule(self, schedule, capsys):\\n        # 删除空日程中的事件\\n        schedule.remove_event(\\\"生日聚会\\\", datetime(2023, 12, 20, 18, 0))\\n\\n        # 查看事件\\n        schedule.view_events()\\n        captured = capsys.readouterr()\\n\\n        # 断言是否输出了相应的错误信息\\n        assert \\\"未找到事件'生日聚会'\\\" in captured.out\"}", "__internal_uuid__": "e46ade7b-ac75-4eb8-91c0-e83ff2756aeb"}
{"canonical_solution": "```python\nclass ListNode:\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n\n\ndef add_two_numbers(l1, l2):\n    carry = 0\n    dummy_head = ListNode()\n    current = dummy_head\n\n    while l1 or l2 or carry:\n        # 获取当前节点的值\n        val1 = l1.value if l1 else 0\n        val2 = l2.value if l2 else 0\n\n        # 计算和以及进位\n        total = val1 + val2 + carry\n        carry, digit = divmod(total, 10)\n\n        # 创建新节点并更新当前节点的next\n        current.next = ListNode(digit)\n        current = current.next\n\n        # 移动到下一个节点\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    return dummy_head.next\n```", "content": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个程序，给定两个用链表表示的整数，其中每个节点包含一个数字。数字存储按照原来整数中相反的顺序，使得第一个数字位于链表的开头。编写一个函数，将这两个整数相加，并以链表形式返回和。ListNode 类表示链表节点，每个节点包含一个值和指向下一个节点的指针。\n\nadd_two_numbers 函数接收两个链表的头节点 l1 和 l2，以及一个进位变量 carry。\n\n使用 dummy_head 创建一个虚拟头节点，作为新链表的起始节点。\n\ncurrent 变量用于迭代构建新链表。\n\n进入循环，直到两个链表和进位都处理完毕。\n\n在每一次循环中，获取当前节点的值，计算和以及进位。\n\n创建新节点，并将其加入新链表。\n\n移动到下一个节点，更新 l1 和 l2。\n\n最终返回新链表的头节点，即 dummy_head.next。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass TestListNode:\n    def test_add_two_numbers_equal_length_no_carry(self):\n        l1 = ListNode(2, ListNode(4, ListNode(3)))\n        l2 = ListNode(5, ListNode(6, ListNode(4)))\n        result = add_two_numbers(l1, l2)\n        assert result.value == 7\n        assert result.next.value == 0\n        assert result.next.next.value == 8\n        assert result.next.next.next is None\n\n", "id": 3, "labels": "{\"execution_language\":\"python\", \"original_id\":134, \"original_promblem\":\"编写一个程序，给定两个用链表表示的整数，其中每个节点包含一个数字。数字存储按照原来整数中相反的顺序，使得第一个数字位于链表的开头。编写一个函数，将这两个整数相加，并以链表形式返回和。ListNode 类表示链表节点，每个节点包含一个值和指向下一个节点的指针。\\n\\nadd_two_numbers 函数接收两个链表的头节点 l1 和 l2，以及一个进位变量 carry。\\n\\n使用 dummy_head 创建一个虚拟头节点，作为新链表的起始节点。\\n\\ncurrent 变量用于迭代构建新链表。\\n\\n进入循环，直到两个链表和进位都处理完毕。\\n\\n在每一次循环中，获取当前节点的值，计算和以及进位。\\n\\n创建新节点，并将其加入新链表。\\n\\n移动到下一个节点，更新 l1 和 l2。\\n\\n最终返回新链表的头节点，即 dummy_head.next。\", \"programming_language\":\"python\", \"tags\":\"算法和数据结构\"}", "test": "{\"asset\":null, \"code\":\"\\n\\nclass TestListNode:\\n    def test_add_two_numbers_both_empty(self):\\n        l1 = None\\n        l2 = None\\n        assert add_two_numbers(l1, l2) is None\\n\\n    def test_add_two_numbers_equal_length_with_carry(self):\\n        l1 = ListNode(9, ListNode(9, ListNode(9)))\\n        l2 = ListNode(1)\\n        result = add_two_numbers(l1, l2)\\n        assert result.value == 0\\n        assert result.next.value == 0\\n        assert result.next.next.value == 0\\n        assert result.next.next.next.value == 1\\n        assert result.next.next.next.next is None\\n\\n    def test_add_two_numbers_unequal_length_no_carry(self):\\n        l1 = ListNode(2, ListNode(4, ListNode(3)))\\n        l2 = ListNode(5, ListNode(6))\\n        result = add_two_numbers(l1, l2)\\n        assert result.value == 7\\n        assert result.next.value == 0\\n        assert result.next.next.value == 4\\n        assert result.next.next.next is None\\n\\n    def test_add_two_numbers_unequal_length_with_carry(self):\\n        l1 = ListNode(9, ListNode(9, ListNode(9)))\\n        l2 = ListNode(1, ListNode(1))\\n        result = add_two_numbers(l1, l2)\\n        assert result.value == 0\\n        assert result.next.value == 1\\n        assert result.next.next.value == 0\\n        assert result.next.next.next.value == 1\\n        assert result.next.next.next.next is None\\n\\n    def test_add_two_numbers_result_has_extra_digit(self):\\n        l1 = ListNode(1)\\n        l2 = ListNode(9, ListNode(9, ListNode(9)))\\n        result = add_two_numbers(l1, l2)\\n        assert result.value == 0\\n        assert result.next.value == 0\\n        assert result.next.next.value == 0\\n        assert result.next.next.next.value == 1\\n        assert result.next.next.next.next is None\\n\\n    def test_add_two_numbers_one_empty_(self):\\n        l1 = ListNode(1, ListNode(2, ListNode(3)))\\n        l2 = None\\n        result = add_two_numbers(l1, l2)\\n\\n        # Traverse both linked lists and compare values\\n        while l1 is not None and result is not None:\\n            assert l1.value == result.value\\n            l1 = l1.next\\n            result = result.next\\n\\n        # Make sure both linked lists reached the end\\n        assert l1 is None and result is None\\n\\n\"}", "__internal_uuid__": "bc340b33-729f-435e-ba48-2743e62db2ae"}
{"canonical_solution": "```python\nfrom typing import List\nimport xml.etree.ElementTree as ET\n\ndef parse_xml(file_path: str, tag_name: str) -> List[str]:\n\n    try:\n        root = ET.parse(file_path).getroot()\n    except ET.ParseError:\n        return []\n    data_list = []\n    for element in root.findall(tag_name):\n        data_list.append(element.text)\n    return data_list\n\n```", "content": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n实现一个Python程序，用于解析给定的XML文件并提取特定标签中的数据，并返回一个包含所有数据的列表。在这个任务中，我们需要编写一个Python程序，该程序可以解析给定的XML文件，并从中提取指定标签中的数据。XML是一种常用的标记语言，用于存储和传输数据。parse_xml 函数接受两个参数：file_path 表示 XML 文件的路径，tag_name 表示要提取的 XML 标签名称。\n\n在函数内部，首先尝试使用 ET.parse(file_path) 解析 XML 文件并获取根节点。如果解析失败（可能是因为文件格式错误），则捕获 ET.ParseError 异常并返回一个空列表。\n\n如果解析成功，初始化一个空列表 data_list，用于存储提取的文本内容。\n\n使用 root.findall(tag_name) 遍历根节点下所有指定标签名的子元素。\n\n对于每个符合条件的子元素，将其文本内容（element.text）添加到 data_list 中。\n\n最终，返回包含提取文本的列表 data_list。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass TestXmlParser:\n    def teardown_method(self, method):\n        os.remove(self.xml_file)\n\n", "id": 4, "labels": "{\"execution_language\":\"python\", \"original_id\":135, \"original_promblem\":\"实现一个Python程序，用于解析给定的XML文件并提取特定标签中的数据，并返回一个包含所有数据的列表。在这个任务中，我们需要编写一个Python程序，该程序可以解析给定的XML文件，并从中提取指定标签中的数据。XML是一种常用的标记语言，用于存储和传输数据。parse_xml 函数接受两个参数：file_path 表示 XML 文件的路径，tag_name 表示要提取的 XML 标签名称。\\n\\n在函数内部，首先尝试使用 ET.parse(file_path) 解析 XML 文件并获取根节点。如果解析失败（可能是因为文件格式错误），则捕获 ET.ParseError 异常并返回一个空列表。\\n\\n如果解析成功，初始化一个空列表 data_list，用于存储提取的文本内容。\\n\\n使用 root.findall(tag_name) 遍历根节点下所有指定标签名的子元素。\\n\\n对于每个符合条件的子元素，将其文本内容（element.text）添加到 data_list 中。\\n\\n最终，返回包含提取文本的列表 data_list。\", \"programming_language\":\"python\", \"tags\":\"前端开发\"}", "test": "{\"asset\":null, \"code\":\"\\n\\nclass TestXmlParser:\\n    def test_parse_xml(self):\\n        expected_result = ['John', 'Jane']\\n        assert parse_xml(self.xml_file, 'name') == expected_result\\n\\n    def test_parse_xml_nonexistent_tag(self):\\n        expected_result = []\\n        assert parse_xml(self.xml_file, 'nonexistent_tag') == expected_result\\n\\n    def test_parse_xml_missing_root_element(self):\\n        with open(self.xml_file, 'w') as f:\\n            f.write('<name>John</name>\\\\n')\\n            f.write('<age>25</age>\\\\n')\\n        expected_result = []\\n        assert parse_xml(self.xml_file, 'name') == expected_result\\n\\n    def test_parse_xml_no_tag_name(self):\\n        expected_result = []\\n        assert parse_xml(self.xml_file, '') == expected_result\\n\\n    def test_parse_xml_invalid_file_format(self):\\n        with open(self.xml_file, 'w') as f:\\n            f.write('This is not an XML file.')\\n        expected_result = []\\n        assert parse_xml(self.xml_file, 'name') == expected_result\\n\\n    def test_parse_xml_multiple_tags(self):\\n        expected_result = ['25', '30']\\n        assert parse_xml(self.xml_file, 'age') == expected_result\\n\\n    def test_parse_xml_duplicate_tags(self):\\n        with open(self.xml_file, 'w') as f:\\n            f.write('<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\\\n')\\n            f.write('<root>\\\\n')\\n            f.write('  <name>John</name>\\\\n')\\n            f.write('  <name>Jane</name>\\\\n')\\n            f.write('</root>')\\n        expected_result = ['John', 'Jane']\\n        assert parse_xml(self.xml_file, 'name') == expected_result\\n\\n    def setup_method(self, method):\\n        self.xml_file = 'test.xml'\\n        with open(self.xml_file, 'w') as f:\\n            f.write('<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\\\n')\\n            f.write('<root>\\\\n')\\n            f.write('  <name>John</name>\\\\n')\\n            f.write('  <age>25</age>\\\\n')\\n            f.write('  <name>Jane</name>\\\\n')\\n            f.write('  <age>30</age>\\\\n')\\n            f.write('</root>')\"}", "__internal_uuid__": "c1f8e5bd-4fdc-4c49-9f90-193868b05140"}
{"canonical_solution": "```python\nimport re\n\n\ndef is_valid_variable_name(name):\n    \"\"\"\n    判断字符串是否是有效的 JavaScript 变量名\n    \"\"\"\n    if len(name) > 255:\n        return False\n    if not re.match(r'^[a-zA-Z_$][a-zA-Z0-9_$]*$', name):\n        return False\n    return True\n\n```", "content": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个程序，判断字符串是否是有效的 JavaScript 变量名\n\n编写一个 Python 函数，该函数接受一个字符串作为输入，判断该字符串是否是有效的 JavaScript 变量名。如果是有效的变量名，则返回 True，否则返回 False。\n\n一个有效的 JavaScript 变量名满足以下条件：\n\n变量名只能包含字母、数字、下划线和美元符号（$）。\n变量名的第一个字符必须是字母、下划线或美元符号。\n变量名的长度不能超过 255 个字符。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testis_valid_variable_name:\n    def test_is_valid_variable_name(self):\n        assert is_valid_variable_name('foo') == True\n\n", "id": 5, "labels": "{\"execution_language\":\"python\", \"original_id\":136, \"original_promblem\":\"编写一个程序，判断字符串是否是有效的 JavaScript 变量名\\n\\n编写一个 Python 函数，该函数接受一个字符串作为输入，判断该字符串是否是有效的 JavaScript 变量名。如果是有效的变量名，则返回 True，否则返回 False。\\n\\n一个有效的 JavaScript 变量名满足以下条件：\\n\\n变量名只能包含字母、数字、下划线和美元符号（$）。\\n变量名的第一个字符必须是字母、下划线或美元符号。\\n变量名的长度不能超过 255 个字符。\", \"programming_language\":\"python\", \"tags\":\"前端开发\"}", "test": "{\"asset\":null, \"code\":\"import re\\n\\n\\nclass Testis_valid_variable_name:\\n    def test_is_valid_variable_name1(self):\\n        assert is_valid_variable_name('_bar') == True\\n\\n    def test_is_valid_variable_name2(self):\\n        assert is_valid_variable_name('$baz') == True\\n\\n    def test_is_valid_variable_name3(self):\\n        assert is_valid_variable_name('12abc') == False\\n\\n    def test_is_valid_variable_name4(self):\\n        assert is_valid_variable_name('abc12') == True\\n\\n    def test_is_valid_variable_name5(self):\\n        assert is_valid_variable_name('a' * 256) == False\\n\\n    def test_is_valid_variable_name6(self):\\n        assert is_valid_variable_name(' ') == False\\n\\n    def test_is_valid_variable_name7(self):\\n        assert is_valid_variable_name('foo bar') == False\\n\\n\"}", "__internal_uuid__": "6b3f6251-9ac6-41aa-a171-6d620b226805"}
{"canonical_solution": "```python\nclass Order:\n    def __init__(self, order_id):\n        self.order_id = order_id\n        self.items = []\n        self.total_price = 0.0\n        self.status = \"未支付\"\n\n    def add_item(self, item_name, item_price):\n        if not isinstance(item_price, (int, float)) or item_price <= 0:\n            return \"商品价格必须是正数\"\n\n        item = {\"name\": item_name, \"price\": item_price}\n        self.items.append(item)\n\n    def remove_item(self, item_name):\n        for item in self.items:\n            if item[\"name\"] == item_name:\n                self.items.remove(item)\n                break\n        else:\n            return \"该商品不存在于订单中\"\n\n    def calculate_total_price(self):\n        self.total_price = sum(item[\"price\"] for item in self.items)\n\n    def pay_order(self):\n        if not self.items:\n            return \"订单中没有商品\"\n        self.status = \"已支付\"\n\n    def cancel_order(self):\n        self.status = \"已取消\"\n\n    def view_order(self):\n        print(\"订单编号：\", self.order_id)\n        print(\"商品列表：\")\n        for item in self.items:\n            print(\"- {}: ￥{}\".format(item[\"name\"], item[\"price\"]))\n        print(\"总价格：￥{}\".format(self.total_price))\n        print(\"状态：\", self.status)\n```", "content": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n实现一个简单的电子商务订单系统。\n\n要求：\n\n实现一个 Order 类，具有以下属性：\norder_id：订单编号，类型为字符串。\nitems：订单中的商品列表，每个商品是一个字典，包含商品名称和价格。\ntotal_price：订单的总价格，类型为浮点数。\nstatus：订单的状态，类型为字符串，初始状态为 \"未支付\"。\n实现以下方法：\nadd_item(item_name, item_price)：向订单中添加商品，参数为商品名称和价格。\nremove_item(item_name)：从订单中移除指定商品，参数为商品名称。\ncalculate_total_price()：计算订单的总价格，并更新 total_price 属性。\npay_order()：支付订单，将订单的状态更新为 \"已支付\"。\ncancel_order()：取消订单，将订单的状态更新为 \"已取消\"。\nview_order()：输出订单的详细信息，包括订单编号、商品列表、总价格和状态, 遵循以下格式：\n订单编号： 20231218\n商品列表：\n- 商品1: ￥10.5\n- 商品2: ￥20.3\n总价格：￥30.8\n状态： 未支付\n\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass TestOrder:\n    def test_add_item(self):\n        order = Order(\"20231218\")\n        order.add_item(\"商品1\", 10.5)\n        assert len(order.items) == 1\n        assert order.items[0][\"name\"] == \"商品1\"\n        assert order.items[0][\"price\"] == 10.5\n\n", "id": 6, "labels": "{\"execution_language\":\"python\", \"original_id\":137, \"original_promblem\":\"实现一个简单的电子商务订单系统。\\n\\n要求：\\n\\n实现一个 Order 类，具有以下属性：\\norder_id：订单编号，类型为字符串。\\nitems：订单中的商品列表，每个商品是一个字典，包含商品名称和价格。\\ntotal_price：订单的总价格，类型为浮点数。\\nstatus：订单的状态，类型为字符串，初始状态为 \\\"未支付\\\"。\\n实现以下方法：\\nadd_item(item_name, item_price)：向订单中添加商品，参数为商品名称和价格。\\nremove_item(item_name)：从订单中移除指定商品，参数为商品名称。\\ncalculate_total_price()：计算订单的总价格，并更新 total_price 属性。\\npay_order()：支付订单，将订单的状态更新为 \\\"已支付\\\"。\\ncancel_order()：取消订单，将订单的状态更新为 \\\"已取消\\\"。\\nview_order()：输出订单的详细信息，包括订单编号、商品列表、总价格和状态, 遵循以下格式：\\n订单编号： 20231218\\n商品列表：\\n- 商品1: ￥10.5\\n- 商品2: ￥20.3\\n总价格：￥30.8\\n状态： 未支付\\n\", \"programming_language\":\"python\", \"tags\":\"软件工程\"}", "test": "{\"asset\":null, \"code\":\"\\n\\nclass TestOrder:\\n    def test_remove_item(self):\\n        order = Order(\\\"20231218\\\")\\n        order.add_item(\\\"商品1\\\", 10.5)\\n        order.remove_item(\\\"商品1\\\")\\n        assert len(order.items) == 0\\n\\n    def test_calculate_total_price(self):\\n        order = Order(\\\"20231218\\\")\\n        order.add_item(\\\"商品1\\\", 10.5)\\n        order.add_item(\\\"商品2\\\", 20.3)\\n        order.calculate_total_price()\\n        assert order.total_price == 30.8\\n\\n    def test_remove_item_(self):\\n        order = Order(\\\"20231218\\\")\\n        order.add_item(\\\"商品1\\\", 10.5)\\n        order.remove_item(\\\"商品1\\\")\\n        assert len(order.items) == 0\\n\\n    def test_pay_order(self):\\n        order = Order(\\\"20231218\\\")\\n        order.pay_order()\\n        assert order.status == \\\"未支付\\\"\\n\\n    def test_pay_order_(self):\\n        order = Order(\\\"20231210\\\")\\n        assert order.status == \\\"未支付\\\"\\n\\n    def test_cancel_order(self):\\n        order = Order(\\\"20231218\\\")\\n        order.cancel_order()\\n        assert order.status == \\\"已取消\\\"\\n\\n    def test_view_order(self, capsys):\\n        order = Order(\\\"20231218\\\")\\n        order.add_item(\\\"商品1\\\", 10.5)\\n        order.add_item(\\\"商品2\\\", 20.3)\\n        order.calculate_total_price()\\n        order.view_order()\\n        captured = capsys.readouterr()\\n        expected_output = (\\n            \\\"订单编号： 20231218\\\\n\\\"\\n            \\\"商品列表：\\\\n\\\"\\n            \\\"- 商品1: ￥10.5\\\\n\\\"\\n            \\\"- 商品2: ￥20.3\\\\n\\\"\\n            \\\"总价格：￥30.8\\\\n\\\"\\n            \\\"状态： 未支付\\\\n\\\"\\n        )\\n        assert captured.out == expected_output\\n\"}", "__internal_uuid__": "87c65d98-3873-44e0-aa8c-7374a38a63be"}
{"canonical_solution": "```python\ndef is_valid_sequence(s):\n    # 判断字符串长度是否在 2 到 10 之间\n    if len(s) < 2 or len(s) > 10:\n        return False\n\n        # 判断字符串中的字符是否都是小写字母\n    for char in s:\n        if not char.islower():\n            return False\n\n            # 判断字符串中是否出现连续的重复字符\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            return False\n\n            # 判断左右两部分是否都是回文字符串或递增序列\n    left, right = s[:len(s) // 2], s[len(s) // 2:]\n    if left == right[::-1] or sorted(left) == sorted(right):\n        return True\n    else:\n        return False\n```", "content": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n写一个程序，程序内容是给定一个只包含小写字母的字符串 s，请编写一个函数 is_valid_sequence(s)，判断该字符串是否满足以下条件：\n字符串 s 的长度在 2 到 10 之间（包含 2 和 10）。\n字符串 s 中的每个字符都必须是小写字母。\n字符串 s 中不能出现连续的重复字符，即相邻的字符不能相同。\n如果将字符串 s 划分为左右两部分，左部分和右部分必须满足以下条件之一：\n左部分和右部分都是回文字符串。\n左部分和右部分都是递增序列（即每个字符的 ASCII 值都比前一个字符大）。is_valid_sequence 函数接受一个字符串 s 作为参数。\n\n首先检查字符串长度是否在 2 到 10 之间，如果不在这个范围内，返回 False。\n\n然后，检查字符串中的字符是否都是小写字母，如果存在非小写字母的字符，返回 False。\n\n接着，检查字符串中是否出现连续的重复字符，如果有，返回 False。\n\n最后，判断字符串是否可以分为左右两部分，且这两部分中要么是回文字符串，要么是递增序列。如果满足这个条件，返回 True；否则，返回 False。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testis_valid_sequence:\n    def test_is_valid_sequence_case1(self):\n        assert is_valid_sequence(\"abba\") == False\n\n", "id": 7, "labels": "{\"execution_language\":\"python\", \"original_id\":138, \"original_promblem\":\"写一个程序，程序内容是给定一个只包含小写字母的字符串 s，请编写一个函数 is_valid_sequence(s)，判断该字符串是否满足以下条件：\\n字符串 s 的长度在 2 到 10 之间（包含 2 和 10）。\\n字符串 s 中的每个字符都必须是小写字母。\\n字符串 s 中不能出现连续的重复字符，即相邻的字符不能相同。\\n如果将字符串 s 划分为左右两部分，左部分和右部分必须满足以下条件之一：\\n左部分和右部分都是回文字符串。\\n左部分和右部分都是递增序列（即每个字符的 ASCII 值都比前一个字符大）。is_valid_sequence 函数接受一个字符串 s 作为参数。\\n\\n首先检查字符串长度是否在 2 到 10 之间，如果不在这个范围内，返回 False。\\n\\n然后，检查字符串中的字符是否都是小写字母，如果存在非小写字母的字符，返回 False。\\n\\n接着，检查字符串中是否出现连续的重复字符，如果有，返回 False。\\n\\n最后，判断字符串是否可以分为左右两部分，且这两部分中要么是回文字符串，要么是递增序列。如果满足这个条件，返回 True；否则，返回 False。\", \"programming_language\":\"python\", \"tags\":\"算法和数据结构\"}", "test": "{\"asset\":null, \"code\":\"\\nclass Testis_valid_sequence:\\n    def test_is_valid_sequence_case2(self):\\n        assert is_valid_sequence(\\\"abcd\\\") == False\\n\\n    def test_is_valid_sequence_case3(self):\\n        assert is_valid_sequence(\\\"a\\\") == False\\n\\n    def test_is_valid_sequence_case4(self):\\n        assert is_valid_sequence(\\\"abcdefghij\\\") == False\\n\\n    def test_is_valid_sequence_case5(self):\\n        assert is_valid_sequence(\\\"Abba\\\") == False\\n\\n    def test_is_valid_sequence_case6(self):\\n        assert is_valid_sequence(\\\"abbb\\\") == False\\n\\n    def test_is_valid_sequence_case7(self):\\n        assert is_valid_sequence(\\\"abcde\\\") == False\\n\\n    def test_is_valid_sequence_case8(self):\\n        assert is_valid_sequence(\\\"\\\") == False\"}", "__internal_uuid__": "f16a4c07-93fc-4fda-aecb-c6cb7d5181af"}
{"canonical_solution": "```python\nimport math\n\nclass RouteSimulator:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.move_history = []\n\n    def move(self, distance, angle_degrees):\n        # 将角度转换为弧度\n        angle_radians = math.radians(angle_degrees)\n\n        # 计算新的位置\n        new_x = self.x + distance * math.cos(angle_radians)\n        new_y = self.y + distance * math.sin(angle_radians)\n\n        # 更新位置\n        self.x, self.y = new_x, new_y\n\n        # 记录移动历史\n        self.move_history.append({'distance': distance, 'angle_degrees': angle_degrees, 'position': (new_x, new_y)})\n\n    def calculate_distance(self, x1, y1, x2, y2):\n        # 计算两点之间的距离\n        return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\n    def print_current_position(self):\n        print(f\"当前位置：({self.x:.2f}, {self.y:.2f})\")\n\n    def print_move_history(self):\n        print(\"移动历史：\")\n        for move in self.move_history:\n            distance = move['distance']\n            angle_degrees = move['angle_degrees']\n            position = move['position']\n            print(f\"距离: {distance:.2f}, 角度: {angle_degrees:.2f}, 位置: ({position[0]:.2f}, {position[1]:.2f})\")\n\n```", "content": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写程序，定义一个名为 RouteSimulator 的类，用于模拟在平面上移动的路径。以下是对代码的中文描述：\n\n初始化方法 (__init__)：\n\n在初始化过程中，设置了起始位置的 x 和 y 坐标，并初始化了一个移动历史列表 move_history 用于记录每次移动的距离、角度和新的位置。\n移动方法 (move)：\n\n接受两个参数：distance 表示移动的距离，angle_degrees 表示移动的方向角度。\n将角度转换为弧度，并使用三角函数计算新的位置坐标。\n更新当前位置为新的位置，同时将移动历史记录添加到列表中。\n计算距离方法 (calculate_distance)：\n\n接受四个参数：两个点的 x 和 y 坐标。\n使用欧几里得距离公式计算两点之间的距离。\n打印当前位置方法 (print_current_position)：\n\n打印当前位置的 x 和 y 坐标。输出格式为\"当前位置：(x, y)\"\n打印移动历史方法 (print_move_history)：\n\n打印移动历史，包括每次移动的距离、角度和新的位置。输出的数字保留两位小数且输出格式为：\n移动历史：\n距离: {distance}, 角度: {angle_degrees}, 位置: {position}\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass TestRouteSimulator:\n    def test_initial_position(self, route_simulator, capfd):\n        route_simulator.print_current_position()\n        captured = capfd.readouterr()\n        assert captured.out.strip() == \"当前位置：(0.00, 0.00)\"\n\n", "id": 8, "labels": "{\"execution_language\":\"python\", \"original_id\":139, \"original_promblem\":\"编写程序，定义一个名为 RouteSimulator 的类，用于模拟在平面上移动的路径。以下是对代码的中文描述：\\n\\n初始化方法 (__init__)：\\n\\n在初始化过程中，设置了起始位置的 x 和 y 坐标，并初始化了一个移动历史列表 move_history 用于记录每次移动的距离、角度和新的位置。\\n移动方法 (move)：\\n\\n接受两个参数：distance 表示移动的距离，angle_degrees 表示移动的方向角度。\\n将角度转换为弧度，并使用三角函数计算新的位置坐标。\\n更新当前位置为新的位置，同时将移动历史记录添加到列表中。\\n计算距离方法 (calculate_distance)：\\n\\n接受四个参数：两个点的 x 和 y 坐标。\\n使用欧几里得距离公式计算两点之间的距离。\\n打印当前位置方法 (print_current_position)：\\n\\n打印当前位置的 x 和 y 坐标。输出格式为\\\"当前位置：(x, y)\\\"\\n打印移动历史方法 (print_move_history)：\\n\\n打印移动历史，包括每次移动的距离、角度和新的位置。输出的数字保留两位小数且输出格式为：\\n移动历史：\\n距离: {distance}, 角度: {angle_degrees}, 位置: {position}\", \"programming_language\":\"python\", \"tags\":\"软件工程\"}", "test": "{\"asset\":null, \"code\":\"import math\\n\\nclass TestRouteSimulator:\\n    def test_move_forward(self, route_simulator, capfd):\\n        route_simulator.move(distance=1, angle_degrees=0)\\n        route_simulator.print_current_position()\\n        captured = capfd.readouterr()\\n        assert captured.out.strip() == \\\"当前位置：(1.00, 0.00)\\\"\\n\\n    def test_move_backward(self, route_simulator, capfd):\\n        route_simulator.move(distance=1, angle_degrees=180)\\n        route_simulator.print_current_position()\\n        captured = capfd.readouterr()\\n        assert captured.out.strip() == \\\"当前位置：(-1.00, 0.00)\\\"\\n\\n    def test_move_diagonal(self, route_simulator, capfd):\\n        route_simulator.move(distance=1, angle_degrees=45)\\n        route_simulator.print_current_position()\\n        captured = capfd.readouterr()\\n        assert captured.out.strip() == f\\\"当前位置：({math.sqrt(0.5):.2f}, {math.sqrt(0.5):.2f})\\\"\\n\\n    def test_move_right(self, route_simulator, capfd):\\n        route_simulator.move(distance=1, angle_degrees=90)\\n        route_simulator.print_current_position()\\n        captured = capfd.readouterr()\\n        assert captured.out.strip() == \\\"当前位置：(0.00, 1.00)\\\"\\n\\n    def test_calculate_distance(self, route_simulator):\\n        distance = route_simulator.calculate_distance(0, 0, 3, 4)\\n        assert distance == 5.0\\n\\n    def test_move_history_empty(self, route_simulator, capfd):\\n        route_simulator.print_move_history()\\n        captured = capfd.readouterr()\\n        assert captured.out.strip() == \\\"移动历史：\\\"\\n\\n    def test_move_history_non_empty(self, route_simulator, capfd):\\n        route_simulator.move(distance=1, angle_degrees=30)\\n        route_simulator.print_move_history()\\n        captured = capfd.readouterr()\\n        assert \\\"距离: 1.00, 角度: 30.00, 位置: (0.87, 0.50)\\\" in captured.out\\n\\n    @pytest.fixture\\n    def route_simulator(self):\\n        return RouteSimulator(x=0, y=0)\\n\\n\"}", "__internal_uuid__": "f3e702df-cadc-48a0-a59b-551fff14611f"}
{"canonical_solution": "```python\ndef utf8_to_ascii(utf8_string):\n    # 验证输入字符串是否为空\n    if not utf8_string:\n        print(\"输入字符串不能为空！\")\n        return None\n\n    result = []\n\n    try:\n        # 遍历输入字符串的每个字符\n        for i in range(len(utf8_string)):\n            if utf8_string[i] == '%' and i + 2 < len(utf8_string) and utf8_string[i + 1:i + 3].isalnum():\n                # 如果遇到以%开头的16进制字符编码，则进行解析\n                hex_str = utf8_string[i + 1:i + 3]\n                ascii_code = int(hex_str, 16)\n                result.append(ascii_code)\n                i += 2\n            else:\n                # 普通的UTF-8字符直接转换为ASCII码\n                ascii_code = ord(utf8_string[i])\n                result.append(ascii_code)\n    except IndexError:\n        print(\"输入字符串格式错误！\")\n        return None\n    except ValueError:\n        print(\"输入字符串包含非法的字符编码！\")\n        return None\n    except Exception as e:\n        print(\"发生未知错误：\", str(e))\n        return None\n\n    return result\n\n\n\n```", "content": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个程序，实现字符串从 UTF-8 编码转换为 ASCII 编码的功能。要求如下：\n\n输入一个字符串（UTF-8 编码）。\n程序将逐个字符读取输入字符串，并将每个字符转换为对应的 ASCII 码。\n将转换后的 ASCII 码逐个打印输出。\n您可以使用适当的编程语言来实现这个功能。请注意，UTF-8 编码中的多字节字符需要进行特殊处理，确保正确转换为对应的 ASCII 码。调用utf8_to_ascii函数之后，将输出一个ASCII码列表，其中每个元素为输入字符串中的一个字符对应的ASCII码。\n\n例如，如果输入字符串为\"Hello World!\"，那么调用utf8_to_ascii函数后，将输出如下ASCII码列表：\n\n[72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]\n其中，第一个元素72对应字符H的ASCII码，第二个元素101对应字符e的ASCII码，以此类推。\n\n这些ASCII码可以进一步用于其他操作，例如加密、转换等。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testutf8_to_ascii:\n    def test_hello_world(self):\n        assert utf8_to_ascii(\"Hello, World!\") == [72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]\n\n", "id": 9, "labels": "{\"execution_language\":\"python\", \"original_id\":140, \"original_promblem\":\"编写一个程序，实现字符串从 UTF-8 编码转换为 ASCII 编码的功能。要求如下：\\n\\n输入一个字符串（UTF-8 编码）。\\n程序将逐个字符读取输入字符串，并将每个字符转换为对应的 ASCII 码。\\n将转换后的 ASCII 码逐个打印输出。\\n您可以使用适当的编程语言来实现这个功能。请注意，UTF-8 编码中的多字节字符需要进行特殊处理，确保正确转换为对应的 ASCII 码。调用utf8_to_ascii函数之后，将输出一个ASCII码列表，其中每个元素为输入字符串中的一个字符对应的ASCII码。\\n\\n例如，如果输入字符串为\\\"Hello World!\\\"，那么调用utf8_to_ascii函数后，将输出如下ASCII码列表：\\n\\n[72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]\\n其中，第一个元素72对应字符H的ASCII码，第二个元素101对应字符e的ASCII码，以此类推。\\n\\n这些ASCII码可以进一步用于其他操作，例如加密、转换等。\", \"programming_language\":\"python\", \"tags\":\"软件工程\"}", "test": "{\"asset\":null, \"code\":\"\\n\\nclass Testutf8_to_ascii:\\n    def test_empty_string(self):\\n        assert utf8_to_ascii(\\\"\\\") == None\\n\\n    def test_invalid_hex_code(self):\\n        assert utf8_to_ascii(\\\"Hello%20Wo%zz\\\") == None\\n\\n    def test_single_character(self):\\n        assert utf8_to_ascii(\\\"A\\\") == [65]\\n\\n    def test_special_characters(self):\\n        assert utf8_to_ascii(\\\"!@#$%^&*()_+-=\\\") == [33, 64, 35, 36, 37, 94, 38, 42, 40, 41, 95, 43, 45, 61]\\n\\n    def test_unicode_characters(self):\\n        assert utf8_to_ascii(\\\"\\\\u2018\\\\u2019\\\\u201c\\\\u201d\\\") == [8216, 8217, 8220, 8221]\\n\\n    def test_long_string(self):\\n        assert utf8_to_ascii(\\\"a\\\" * 1000) == [97] * 1000\\n\\n    def test_invalid_input_type(self):\\n        assert utf8_to_ascii(123) == None\\n\\n    def test_invalid_input_encoding(self):\\n        assert utf8_to_ascii(b\\\"Hello%20World%21\\\") == None\\n\"}", "__internal_uuid__": "b78f13d6-5b73-4766-aa50-76a612a72ffa"}
{"canonical_solution": "```python\nimport re\nimport datetime\n\n\ndef find_dates(text):\n    if not text:\n        return \"输入的文本为空，请提供有效的文本内容\"\n\n    date_patterns = [\n        r\"\\b(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])\\b\",  # YYYY-MM-DD\n        r\"\\b(0[1-9]|1[0-2])/(0[1-9]|[12][0-9]|3[01])/(19|20)?\\d{2}\\b\",  # MM/DD/YYYY or M/D/YYYY\n        r\"\\b(0[1-9]|[12][0-9]|3[01])-(0[1-9]|1[0-2])-(19|20)?\\d{2}\\b\",  # DD-MM-YYYY or D-M-YYYY\n        r\"\\b(0[1-9]|[12][0-9]|3[01])\\s(January|February|March|April|May|June|July|August|September|October|November|December),?\\s(19|20)?\\d{2}\\b\"\n        # DD Month YYYY or D Month YYYY\n    ]\n    dates = []\n    for pattern in date_patterns:\n        dates.extend(re.findall(pattern, text))\n\n    formatted_dates = []\n    for date in dates:\n        if date[0]:  # 如果匹配到了年份\n            year = date[0]\n        else:\n            year = \"20\" + date[3] if date[3] else \"\"  # 如果没有匹配到年份，则根据模式中的分组确定年份\n\n        month = date[1].zfill(2)\n        day = date[2].zfill(2)\n\n        # 检查日期的有效性\n        try:\n            formatted_date = f\"{year}-{month}-{day}\"\n            _ = datetime.datetime.strptime(formatted_date, \"%Y-%m-%d\")\n            formatted_dates.append(formatted_date)\n        except ValueError:\n            pass\n\n    if not formatted_dates:\n        return \"未找到有效日期\"\n\n    return formatted_dates\n\n```", "content": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个程序，实现一个 Python 函数 find_dates(text)，它接受一个字符串 text 作为参数，并返回所有在该字符串中出现的日期。其中，日期应采用标准的年-月-日（YYYY-MM-DD）格式。\n\n要求：\n\n日期必须符合标准的年-月-日（YYYY-MM-DD）格式。\n\n日期中的年份必须是四位数字，月份和日期必须是两位数字。\n\n函数不得使用爬虫或用户输入等外部资源。\n\n函数必须使用正则表达式来识别日期。\n\n函数必须返回所有符合要求的日期，如果没有符合要求的日期，则返回一个空列表。\n\n样例：\n\npython\ntext = \"The event will take place on 2022-01-25 and the deadline is 2022-02-15.\"\nprint(find_dates(text))\n# output: ['2022-01-25', '2022-02-15']\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testfind_dates:\n    def test_case_1(self):\n        text = \"The event will take place on 2022-01-25 and the deadline is 2022-02-15.\"\n        expected_dates = [\"2022-01-25\", \"2022-02-15\"]\n        assert find_dates(text) == expected_dates\n\n", "id": 10, "labels": "{\"execution_language\":\"python\", \"original_id\":141, \"original_promblem\":\"编写一个程序，实现一个 Python 函数 find_dates(text)，它接受一个字符串 text 作为参数，并返回所有在该字符串中出现的日期。其中，日期应采用标准的年-月-日（YYYY-MM-DD）格式。\\n\\n要求：\\n\\n日期必须符合标准的年-月-日（YYYY-MM-DD）格式。\\n\\n日期中的年份必须是四位数字，月份和日期必须是两位数字。\\n\\n函数不得使用爬虫或用户输入等外部资源。\\n\\n函数必须使用正则表达式来识别日期。\\n\\n函数必须返回所有符合要求的日期，如果没有符合要求的日期，则返回一个空列表。\\n\\n样例：\\n\\npython\\ntext = \\\"The event will take place on 2022-01-25 and the deadline is 2022-02-15.\\\"\\nprint(find_dates(text))\\n# output: ['2022-01-25', '2022-02-15']\", \"programming_language\":\"python\", \"tags\":\"软件工程\"}", "test": "{\"asset\":null, \"code\":\"import re\\nimport datetime\\n\\n\\nclass Testfind_dates:\\n    def test_case_2(self):\\n        text = \\\"Another possible date format is 2022-02-15.\\\"\\n        expected_dates = ['2022-02-15']\\n        assert find_dates(text) == expected_dates\\n\\n    def test_case_3(self):\\n        text = \\\"And the third format is 01*01-*024.\\\"\\n        expected_dates = \\\"未找到有效日期\\\"\\n        assert find_dates(text) == expected_dates\\n\\n    def test_case_4(self):\\n        text = \\\"Lastly, we have a date like 1 January 2025.\\\"\\n        expected_dates = '未找到有效日期'\\n        assert find_dates(text) == expected_dates\\n\\n    def test_case_5(self):\\n        text = \\\"Invalid date formats: 2022-13-01, 31/12/2023, 01-01-2024\\\"\\n        expected_dates = \\\"未找到有效日期\\\"\\n        assert find_dates(text) == expected_dates\\n\\n    def test_case_6(self):\\n        text = \\\"No dates in this text.\\\"\\n        expected_dates = \\\"未找到有效日期\\\"\\n        assert find_dates(text) == expected_dates\\n\\n    def test_case_7(self):\\n        text = \\\"The event happened on 2020-12-25 and it was a great success.\\\"\\n        expected_dates = [\\\"2020-12-25\\\"]\\n        assert find_dates(text) == expected_dates\\n\\n    def test_case_8(self):\\n        text = \\\"The due date for submission is 2022-06-30.\\\"\\n        expected_dates = [\\\"2022-06-30\\\"]\\n        assert find_dates(text) == expected_dates\\n\\n\\n\"}", "__internal_uuid__": "85c93dff-3572-4b84-be71-93b43299f91f"}
{"canonical_solution": "```python\nclass Process:\n    def __init__(self, pid, code):\n        self.pid = pid\n        self.code = code\n        self.memory = None\n\ndef allocate_memory(memory_map, process):\n    if process.memory is not None:\n        raise ValueError(\"Process already has memory\")\n\n    for i in range(len(memory_map)):\n        if memory_map[i] == 0:\n            process.memory = i\n            for j in range(len(process.code)):\n                memory_map[i + j] = 1\n            return True\n\n    return False\n\ndef deallocate_memory(memory_map, process):\n    if process.memory is not None:\n        for i in range(len(process.code)):\n            memory_map[process.memory + i] = 0\n        process.memory = None\n\ndef run_processes(processes):\n    for process in processes:\n        print(f\"Running Process {process.pid} with code: {process.code}\")\n\n# 创建一个简单的操作系统\nmemory_map = [0] * 100\nprocesses = []\n\n# 创建两个进程\nprocess1 = Process(pid=1, code=[1, 2, 3])\nprocess2 = Process(pid=2, code=[4, 5, 6])\n\n# 将进程添加到列表\nprocesses.append(process1)\nprocesses.append(process2)\n\n# 分配内存\nallocate_memory(memory_map, process1)\nallocate_memory(memory_map, process2)\n\n# 运行进程\nrun_processes(processes)\n\n# 释放内存\ndeallocate_memory(memory_map, process1)\ndeallocate_memory(memory_map, process2)\n\n```", "content": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个程序,模拟操作系统内存管理的 Python 代码。代码中定义了一个 Process 类，表示一个进程，每个进程有一个唯一的进程标识符（pid）和一段代码（code）。操作系统维护了一个内存映射表 memory_map，用于跟踪内存的分配情况。示例中，两个进程被创建并添加到 processes 列表中。然后，通过调用 allocate_memory 函数，为每个进程分配内存。最后，通过调用 run_processes 函数，模拟运行了所有进程，并通过调用 deallocate_memory 函数释放了进程占用的内存。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass TestProcess:\n    def test_successful_memory_allocation(self):\n        memory_map = [0] * 100\n        process = Process(pid=1, code=[1, 2, 3])\n\n        assert allocate_memory(memory_map, process) == True\n        assert process.memory is not None\n\n\n", "id": 11, "labels": "{\"execution_language\":\"python\", \"original_id\":142, \"original_promblem\":\"编写一个程序,模拟操作系统内存管理的 Python 代码。代码中定义了一个 Process 类，表示一个进程，每个进程有一个唯一的进程标识符（pid）和一段代码（code）。操作系统维护了一个内存映射表 memory_map，用于跟踪内存的分配情况。示例中，两个进程被创建并添加到 processes 列表中。然后，通过调用 allocate_memory 函数，为每个进程分配内存。最后，通过调用 run_processes 函数，模拟运行了所有进程，并通过调用 deallocate_memory 函数释放了进程占用的内存。\", \"programming_language\":\"python\", \"tags\":\"操作系统\"}", "test": "{\"asset\":null, \"code\":\"\\n\\nclass TestProcess:\\n    def test_successful_allocation_multiple_processes(self):\\n        memory_map = [0] * 100\\n        process1 = Process(pid=1, code=[1, 2, 3])\\n        process2 = Process(pid=2, code=[4, 5, 6])\\n\\n        assert allocate_memory(memory_map, process1) == True\\n        assert allocate_memory(memory_map, process2) == True\\n        assert process1.memory is not None\\n        assert process2.memory is not None\\n\\n\\n    def test_failed_memory_allocation(self):\\n        memory_map = [1] * 100  # Memory is already full\\n        process = Process(pid=1, code=[1, 2, 3])\\n\\n        assert allocate_memory(memory_map, process) == False\\n        assert process.memory is None\\n\\n\\n    def test_memory_deallocation(self):\\n        memory_map = [0] * 100\\n        process = Process(pid=1, code=[1, 2, 3])\\n\\n        allocate_memory(memory_map, process)\\n        deallocate_memory(memory_map, process)\\n\\n        assert process.memory is None\\n\\n\\n    def test_run_processes(self):\\n        processes = [\\n            Process(pid=1, code=[1, 2, 3]),\\n            Process(pid=2, code=[4, 5, 6])\\n        ]\\n\\n        run_processes(processes)\\n        # Manual inspection of output\\n\\n\\n    def test_deallocate_unallocated_memory(self):\\n        memory_map = [0] * 100\\n        process = Process(pid=1, code=[1, 2, 3])\\n\\n        deallocate_memory(memory_map, process)\\n\\n        assert process.memory is None\\n\\n\\n    def test_run_empty_processes(self):\\n        empty_processes = []\\n        run_processes(empty_processes)\\n        # Manual inspection of output\\n\\n\\n    def test_allocate_full_memory(self):\\n        full_memory_map = [0] * 100\\n        full_process = Process(pid=1, code=[1] * 100)\\n\\n        assert allocate_memory(full_memory_map, full_process) == True\\n        assert full_process.memory is not None\\n\\n\\n    def test_continuous_allocation_deallocation(self):\\n        continuous_memory_map = [0] * 100\\n        continuous_process = Process(pid=1, code=[1, 2, 3])\\n\\n        assert allocate_memory(continuous_memory_map, continuous_process) == True\\n        assert continuous_process.memory is not None\\n\\n        deallocate_memory(continuous_memory_map, continuous_process)\\n\\n        assert continuous_process.memory is None\\n\"}", "__internal_uuid__": "0cada019-db03-4a8b-bd40-d5369e556634"}
{"canonical_solution": "```python\nimport re\nfrom collections import Counter\nfrom bs4 import BeautifulSoup\n\n\ndef get_top_k_words_from_html(html, k):\n    # 定义需要排除的单词列表\n    exclude_list = ['this','is','are','a', 'an', 'the', 'and', 'or', 'in', 'on', 'at', 'to', 'of', 'for', 'with', 'by', 'from']\n\n    try:\n        # 解析HTML文本\n        soup = BeautifulSoup(html, 'lxml')\n\n        # 获取所有文本内容\n        text = soup.get_text()\n\n        # 将文本转换为小写，并使用正则表达式提取单词\n\n        lower=text.lower()\n        words = re.findall(r'\\b(?<!-)(?!' + '|'.join(exclude_list) + r')\\w+(?<!-)\\b', lower, flags=re.UNICODE)\n\n        # 使用Counter统计单词出现次数\n        word_counts = Counter(words)\n\n        # 获取出现次数最多的前k个单词及其出现次数\n        top_k_words = word_counts.most_common(k)\n\n        return top_k_words\n\n    except Exception as e:\n        print(\"Error occurred:\", str(e))\n        return None\n\n```", "content": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个程序，实现题目描述：\n给定一个包含多个英文句子的 HTML 文本，编写一个函数 get_top_k_words_from_html(html, k)，返回出现次数最多的前 k 个单词及其出现次数。\n\n编写一个函数 get_top_k_words_from_html(html, k)，其中参数 html 为一个包含 HTML 标记的字符串，k 为一个正整数，返回一个列表，包括前 k 个出现次数最多的单词及其出现次数，按出现次数从大到小排列。\n\n示例：\n输入： \"<p>We are the world, we are the children.</p> <p>We are the ones who make a brighter day.</p> <p>So let's start giving.</p>\"\n输出： [('we', 3), ('are', 3), ('the', 3)]\n\n输入： \"<p>The quick brown fox jumps over the lazy dog.</p> <p>The quick brown fox jumps over the lazy dog.</p>\"\n输出： [('the', 4), ('brown', 2), ('quick', 2)]\n\n注意：\n\n单词不区分大小写，即 \"The\" 和 \"the\" 视为同一个单词。\n单词定义为由字母和数字组成的字符串，不包括标点符号。\n返回的列表中应包括所有出现次数相同的前 k 个单词及其出现次数。\n可以使用库来解析 HTML 文本，并使用标准库函数或模块来辅助解决问题。\n请实现函数 get_top_k_words_from_html(html, k) 来解决该题目。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testget_top_k_words_from_html:\n    def test_empty_html(self):\n        html = \"<html><body></body></html>\"\n        assert get_top_k_words_from_html(html, 5) == []\n\n", "id": 12, "labels": "{\"execution_language\":\"python\", \"original_id\":143, \"original_promblem\":\"编写一个程序，实现题目描述：\\n给定一个包含多个英文句子的 HTML 文本，编写一个函数 get_top_k_words_from_html(html, k)，返回出现次数最多的前 k 个单词及其出现次数。\\n\\n编写一个函数 get_top_k_words_from_html(html, k)，其中参数 html 为一个包含 HTML 标记的字符串，k 为一个正整数，返回一个列表，包括前 k 个出现次数最多的单词及其出现次数，按出现次数从大到小排列。\\n\\n示例：\\n输入： \\\"<p>We are the world, we are the children.</p> <p>We are the ones who make a brighter day.</p> <p>So let's start giving.</p>\\\"\\n输出： [('we', 3), ('are', 3), ('the', 3)]\\n\\n输入： \\\"<p>The quick brown fox jumps over the lazy dog.</p> <p>The quick brown fox jumps over the lazy dog.</p>\\\"\\n输出： [('the', 4), ('brown', 2), ('quick', 2)]\\n\\n注意：\\n\\n单词不区分大小写，即 \\\"The\\\" 和 \\\"the\\\" 视为同一个单词。\\n单词定义为由字母和数字组成的字符串，不包括标点符号。\\n返回的列表中应包括所有出现次数相同的前 k 个单词及其出现次数。\\n可以使用库来解析 HTML 文本，并使用标准库函数或模块来辅助解决问题。\\n请实现函数 get_top_k_words_from_html(html, k) 来解决该题目。\", \"programming_language\":\"python\", \"tags\":\"前端开发\"}", "test": "{\"asset\":null, \"code\":\"import re\\nfrom collections import Counter\\nfrom bs4 import BeautifulSoup\\n\\n\\nclass Testget_top_k_words_from_html:\\n    def test_basic_html(self):\\n        html = \\\"<html><body>This is a simple HTML text. Hello world!</body></html>\\\"\\n        assert get_top_k_words_from_html(html, 3) == [('simple', 1), ('html', 1), ('text', 1)]\\n\\n    def test_html_with_tags(self):\\n        html = \\\"<html><body><h1>Title</h1><p> is a paragraph.</p></body></html>\\\"\\n        assert get_top_k_words_from_html(html, 4) == [('title', 1), ('paragraph', 1)]\\n\\n    def test_html_with_special_characters(self):\\n        html = \\\"<html><body>Encoding: &#1632;&#1633;&#1634;</body></html>\\\"\\n        assert get_top_k_words_from_html(html, 3) == [('encoding', 1), ('٠١٢', 1)]\\n\\n    def test_html_with_unicode_characters(self):\\n        html = \\\"<html><body>Unicode: àéîőű</body></html>\\\"\\n        assert get_top_k_words_from_html(html, 4) == [('unicode', 1), ('àéîőű', 1)]\\n\\n    def test_html_with_duplicate_words(self):\\n        html = \\\"<html><body>Repeated words test. This is a test repeated words.</body></html>\\\"\\n        assert get_top_k_words_from_html(html, 4) == [('repeated', 2), ('words', 2), ('test', 2)]\\n\\n    def test_large_html(self):\\n        # Test with a large HTML content\\n        html = \\\"<html><body>\\\" + \\\"word1 \\\" * 1000 + \\\"</body></html>\\\"\\n        assert get_top_k_words_from_html(html, 1) == [('word1', 1000)]\\n\\n\\n    def test_html_with_numbers(self):\\n        html = \\\"<html><body>Numbers: 123 456 789</body></html>\\\"\\n        assert get_top_k_words_from_html(html, 3) == [('numbers', 1), ('123', 1), ('456', 1)]\\n\\n\\n    def test_html_with_unicode_characters_and_numbers(self):\\n        html = \\\"<html><body>Unicode and numbers: àéîőű 12345</body></html>\\\"\\n        assert get_top_k_words_from_html(html, 4) == [('unicode', 1), ('numbers', 1), ('àéîőű', 1), ('12345', 1)]\\n\\n\\n\\n\"}", "__internal_uuid__": "b8e844b0-f98a-4751-87c7-b2c70503e529"}
{"canonical_solution": "```python\nfrom typing import List, Tuple\n\n\ndef extract_temperatures_from_text(text: str) -> Tuple[List[str], List[float]]:\n    cities = []\n    temperatures = []\n    lines = text.strip().split('\\n')\n    for line in lines:\n        city_temperature = line.split('，')\n        if len(city_temperature) == 2:\n            city, temperature = city_temperature\n            temperature = float(temperature.replace('℃', ''))\n            cities.append(city)\n            temperatures.append(temperature)\n        else:\n            return [], []\n    return cities, temperatures\n\ndef calculate_average_temperature(temperatures: List[float]) -> float:\n    total_temperature = sum(temperatures)\n    average_temperature = total_temperature / len(temperatures)\n    return average_temperature\n\ndef find_highest_temperature(cities: List[str], temperatures: List[float]) -> Tuple[float, str]:\n    if not temperatures:\n        return 0, \"无\"\n    index = temperatures.index(max(temperatures))\n    highest_temperature = temperatures[index]\n    city = cities[index]\n    return highest_temperature, city\n\ndef find_lowest_temperature(cities: List[str], temperatures: List[float]) -> Tuple[float, str]:\n    if not temperatures:\n        return 0, \"无\"\n    index = temperatures.index(min(temperatures))\n    lowest_temperature = temperatures[index]\n    city = cities[index]\n    return lowest_temperature, city\n\n\n```", "content": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个程序，完成题目：气象数据分析\n\n编写一个程序，实现对气温数据的分析和处理。\n\n要求：\n\n编写一个函数 extract_temperatures_from_text(text: str) -> List[float]，该函数接收一个文本字符串作为参数，从文本中提取气温数据，并将其以列表的形式返回。文件中每行包含一个气温值，以摄氏度为单位。\n\n编写一个函数 calculate_average_temperature(temperatures: List[float]) -> float，该函数接收一个气温数据列表作为参数，并计算出平均气温，并将其返回。\n\n编写一个函数 find_highest_temperature(temperatures: List[float]) -> float，该函数接收一个气温数据列表作为参数，并找出其中的最高气温，并将其返回。\n\n编写一个函数 find_lowest_temperature(temperatures: List[float]) -> float，该函数接收一个气温数据列表作为参数，并找出其中的最低气温，并将其返回。\n\n使用案例：\n\npython\ntext = \"\"\"\n北京，-4℃\n上海，3℃\n广州，12℃\n重庆，8℃\n\"\"\"\n\ntemperatures = extract_temperatures_from_text(text)\naverage_temp = calculate_average_temperature(temperatures)\nhighest_temp = find_highest_temperature(temperatures)\nlowest_temp = find_lowest_temperature(temperatures)\n\nprint(\"提取的气温数据:\", temperatures)\nprint(\"平均气温:\", average_temp)\nprint(\"最高气温:\", highest_temp)\nprint(\"最低气温:\", lowest_temp)\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testextract_temperatures_from_text:\n    def test_extract_temperatures_from_text_with_temperatures(self):\n        text = \"北京，-4℃\\n上海，3℃\\n广州，12℃\\n重庆，8℃\"\n        cities, temperatures = extract_temperatures_from_text(text)\n        assert cities == [\"北京\", \"上海\", \"广州\", \"重庆\"]\n        assert temperatures == [-4.0, 3.0, 12.0, 8.0]\n\n", "id": 13, "labels": "{\"execution_language\":\"python\", \"original_id\":144, \"original_promblem\":\"编写一个程序，完成题目：气象数据分析\\n\\n编写一个程序，实现对气温数据的分析和处理。\\n\\n要求：\\n\\n编写一个函数 extract_temperatures_from_text(text: str) -> List[float]，该函数接收一个文本字符串作为参数，从文本中提取气温数据，并将其以列表的形式返回。文件中每行包含一个气温值，以摄氏度为单位。\\n\\n编写一个函数 calculate_average_temperature(temperatures: List[float]) -> float，该函数接收一个气温数据列表作为参数，并计算出平均气温，并将其返回。\\n\\n编写一个函数 find_highest_temperature(temperatures: List[float]) -> float，该函数接收一个气温数据列表作为参数，并找出其中的最高气温，并将其返回。\\n\\n编写一个函数 find_lowest_temperature(temperatures: List[float]) -> float，该函数接收一个气温数据列表作为参数，并找出其中的最低气温，并将其返回。\\n\\n使用案例：\\n\\npython\\ntext = \\\"\\\"\\\"\\n北京，-4℃\\n上海，3℃\\n广州，12℃\\n重庆，8℃\\n\\\"\\\"\\\"\\n\\ntemperatures = extract_temperatures_from_text(text)\\naverage_temp = calculate_average_temperature(temperatures)\\nhighest_temp = find_highest_temperature(temperatures)\\nlowest_temp = find_lowest_temperature(temperatures)\\n\\nprint(\\\"提取的气温数据:\\\", temperatures)\\nprint(\\\"平均气温:\\\", average_temp)\\nprint(\\\"最高气温:\\\", highest_temp)\\nprint(\\\"最低气温:\\\", lowest_temp)\", \"programming_language\":\"python\", \"tags\":\"数据科学\"}", "test": "{\"asset\":null, \"code\":\"from typing import List, Tuple\\n\\n\\nclass Testextract_temperatures_from_text:\\n    def test_extract_temperatures_from_text_without_temperatures(self):\\n        text = \\\"北京\\\\n上海\\\\n广州\\\\n重庆\\\"\\n        cities, temperatures = extract_temperatures_from_text(text)\\n        assert cities == []\\n        assert temperatures == []\\n\\n    def test_calculate_average_temperature(self):\\n        temperatures = [10.0, 20.0, 30.0]\\n        assert calculate_average_temperature(temperatures) == 20.0\\n\\n    def test_find_highest_temperature(self):\\n        cities = [\\\"北京\\\", \\\"上海\\\", \\\"广州\\\", \\\"重庆\\\"]\\n        temperatures = [-4.0, 3.0, 12.0, 8.0]\\n        assert find_highest_temperature(cities, temperatures) == (12.0, \\\"广州\\\")\\n\\n    def test_find_lowest_temperature(self):\\n        cities = [\\\"北京\\\", \\\"上海\\\", \\\"广州\\\", \\\"重庆\\\"]\\n        temperatures = [-4.0, 3.0, 12.0, 8.0]\\n        assert find_lowest_temperature(cities, temperatures) == (-4.0, \\\"北京\\\")\\n\\n    def test_extract_temperatures_from_text_with_single_data(self):\\n        text = \\\"北京，-4℃\\\"\\n        cities, temperatures = extract_temperatures_from_text(text)\\n        assert cities == [\\\"北京\\\"]\\n        assert temperatures == [-4.0]\\n\\n    def test_extract_temperatures_from_text_with_cities_only(self):\\n        text = \\\"北京\\\\n上海\\\\n广州\\\\n重庆\\\"\\n        cities, temperatures = extract_temperatures_from_text(text)\\n        assert cities == []\\n        assert temperatures == []\\n\\n    def test_calculate_average_temperature_with_single_temperature(self):\\n        temperatures = [10.0]\\n        assert calculate_average_temperature(temperatures) == 10.0\\n\\n    def test_find_highest_temperature_with_single_temperature(self):\\n        cities = [\\\"北京\\\"]\\n        temperatures = [-4.0]\\n        assert find_highest_temperature(cities, temperatures) == (-4.0, \\\"北京\\\")\\n\\n    def test_find_lowest_temperature_with_single_temperature(self):\\n        cities = [\\\"北京\\\"]\\n        temperatures = [-4.0]\\n        assert find_lowest_temperature(cities, temperatures) == (-4.0, \\\"北京\\\")\\n\\n    def test_extract_temperatures_from_text_with_duplicate_temperatures(self):\\n        text = \\\"北京，-4℃\\\\n上海，3℃\\\\n广州，12℃\\\\n重庆，8℃\\\\n成都，12℃\\\"\\n        cities, temperatures = extract_temperatures_from_text(text)\\n        assert cities == [\\\"北京\\\", \\\"上海\\\", \\\"广州\\\", \\\"重庆\\\", \\\"成都\\\"]\\n        assert temperatures == [-4.0, 3.0, 12.0, 8.0, 12.0]\\n\\n    def test_extract_temperatures_from_text_with_decimal_temperatures(self):\\n        text = \\\"北京，-4.5℃\\\\n上海，3.2℃\\\\n广州，12.7℃\\\\n重庆，8.9℃\\\"\\n        cities, temperatures = extract_temperatures_from_text(text)\\n        assert cities == [\\\"北京\\\", \\\"上海\\\", \\\"广州\\\", \\\"重庆\\\"]\\n        assert temperatures == [-4.5, 3.2, 12.7, 8.9]\\n\\n\"}", "__internal_uuid__": "e8e3b97d-8a0f-411b-b77e-5831d4430382"}
{"canonical_solution": "```python\nimport re\n\n\ndef count_html_tags(html):\n    pattern = r'<\\s*([a-zA-Z]+)[^>]*>|<\\s*/\\s*([a-zA-Z]+)\\s*>'\n    matches = re.findall(pattern, html)\n\n    tag_count = 0\n    nested_tags = []\n    max_nested_depth = 0\n\n    for opening_tag, closing_tag in matches:\n        if opening_tag:\n            nested_tags.append(opening_tag.lower())\n            tag_count += 1\n            max_nested_depth = max(max_nested_depth, len(nested_tags))\n        elif nested_tags and nested_tags[-1] == closing_tag.lower():\n            nested_tags.pop()\n            tag_count += 1\n\n    return tag_count, max_nested_depth\n\n\n\n```", "content": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个程序，一个函数 count_html_tags(html)，该函数接受一个 HTML 字符串作为参数，并返回该字符串中包含的 HTML 标签的数量。\n\n要求：\n\nHTML 标签由尖括号 < 和 > 包围，标签名称位于尖括号内。\n标签名称由小写字母组成，不包含空格或其他特殊字符。\n假设输入的 HTML 字符串是有效的，不需要进行错误处理。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testcount_html_tags:\n    def test_empty_string(self):\n        html = \"\"\n        tag_count, max_nested_depth = count_html_tags(html)\n        assert tag_count == 0\n        assert max_nested_depth == 0\n\n", "id": 14, "labels": "{\"execution_language\":\"python\", \"original_id\":145, \"original_promblem\":\"编写一个程序，一个函数 count_html_tags(html)，该函数接受一个 HTML 字符串作为参数，并返回该字符串中包含的 HTML 标签的数量。\\n\\n要求：\\n\\nHTML 标签由尖括号 < 和 > 包围，标签名称位于尖括号内。\\n标签名称由小写字母组成，不包含空格或其他特殊字符。\\n假设输入的 HTML 字符串是有效的，不需要进行错误处理。\", \"programming_language\":\"python\", \"tags\":\"前端开发\"}", "test": "{\"asset\":null, \"code\":\"import re\\n\\n\\nclass Testcount_html_tags:\\n    def test_single_tag(self):\\n        html = \\\"<div></div>\\\"\\n        tag_count, max_nested_depth = count_html_tags(html)\\n        assert tag_count == 2\\n        assert max_nested_depth == 1\\n\\n    def test_nested_tags(self):\\n        html = \\\"<div><p><span></span></p></div>\\\"\\n        tag_count, max_nested_depth = count_html_tags(html)\\n        assert tag_count == 6\\n        assert max_nested_depth == 3\\n\\n    def test_mismatched_closing_tag(self):\\n        html = \\\"<div></span>\\\"\\n        tag_count, max_nested_depth = count_html_tags(html)\\n        assert tag_count == 1\\n        assert max_nested_depth == 1\\n\\n    def test_case_sensitive(self):\\n        html = \\\"<DIV><P><SPAN></span></P></div>\\\"\\n        tag_count, max_nested_depth = count_html_tags(html)\\n        assert tag_count == 6\\n        assert max_nested_depth == 3\\n\\n    def test_special_characters(self):\\n        html = \\\"<p>This is some text with &lt;strong&gt; tags.</p>\\\"\\n        tag_count, max_nested_depth = count_html_tags(html)\\n        assert tag_count == 2\\n\\n    def test_unbalanced_tags(self):\\n        html = \\\"<div><p></div></p>\\\"\\n        result = count_html_tags(html)\\n        assert result == (3, 2)\"}", "__internal_uuid__": "9c025e7d-97dd-4368-9c62-c0a7ca498141"}
{"canonical_solution": "```python\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\nimport base64\n\n\ndef encrypt(text, key):\n    backend = default_backend()\n    cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=backend)\n    encryptor = cipher.encryptor()\n\n    # 补全文本长度至AES块大小的倍数\n    text = text + ' ' * (16 - len(text) % 16)\n\n    # 加密\n    ciphertext = encryptor.update(text.encode()) + encryptor.finalize()\n    return base64.b64encode(ciphertext).decode()\n\n\ndef decrypt(encrypted_text, key):\n    backend = default_backend()\n    cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=backend)\n    decryptor = cipher.decryptor()\n\n    # 解密\n    ciphertext = base64.b64decode(encrypted_text.encode())\n    decrypted_text = decryptor.update(ciphertext) + decryptor.finalize()\n    return decrypted_text.decode().rstrip()\n\n\ndef save_to_file(data, filename):\n    with open(filename, 'w') as file:\n        file.write(data)\n\n\ndef read_from_file(filename):\n    with open(filename, 'r') as file:\n        return file.read()\n\n\n\ntext_to_encrypt = \"Hello, World!\"\nencryption_key = b'Sixteen byte key'\n\n# # 加密并保存到文件\n# encrypted_text = encrypt(text_to_encrypt, encryption_key)\n# save_to_file(encrypted_text, \"encrypted_data.txt\")\n#\n# # 从文件中读取并解密\n# loaded_encrypted_text = read_from_file(\"encrypted_data.txt\")\n# decrypted_text = decrypt(loaded_encrypted_text, encryption_key)\n\n\n\n```", "content": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个程序，数据加密和解密的脚本，如encrypt 函数： 接受明文文本和密钥作为输入，使用AES算法的ECB模式进行加密。在加密前，会将明文文本的长度补全到AES块大小的倍数。加密结果以Base64编码的形式返回。\n\ndecrypt 函数： 接受密文和密钥作为输入，使用AES算法的ECB模式进行解密。解密后会去除可能添加的空格，然后返回解密后的明文。\n\nsave_to_file 函数： 接受数据和文件名作为输入，将数据写入指定文件。\n\nread_from_file 函数： 接受文件名作为输入，从指定文件中读取数据并返回。\n\n加密与解密演示： 使用示例文本 \"Hello, World!\" 和一个16字节的密钥进行加密。加密后的结果以Base64编码保存到文件 \"encrypted_data.txt\"。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass TestEncryption:\n    def test_encrypt_decrypt_with_fixture(self, encryption_key):\n        original_text = \"Hello, World!\"\n        encrypted_text = encrypt(original_text, encryption_key)\n        decrypted_text = decrypt(encrypted_text, encryption_key)\n        assert original_text == decrypted_text, \"Encryption and decryption failed.\"\n\n", "id": 15, "labels": "{\"execution_language\":\"python\", \"original_id\":146, \"original_promblem\":\"编写一个程序，数据加密和解密的脚本，如encrypt 函数： 接受明文文本和密钥作为输入，使用AES算法的ECB模式进行加密。在加密前，会将明文文本的长度补全到AES块大小的倍数。加密结果以Base64编码的形式返回。\\n\\ndecrypt 函数： 接受密文和密钥作为输入，使用AES算法的ECB模式进行解密。解密后会去除可能添加的空格，然后返回解密后的明文。\\n\\nsave_to_file 函数： 接受数据和文件名作为输入，将数据写入指定文件。\\n\\nread_from_file 函数： 接受文件名作为输入，从指定文件中读取数据并返回。\\n\\n加密与解密演示： 使用示例文本 \\\"Hello, World!\\\" 和一个16字节的密钥进行加密。加密后的结果以Base64编码保存到文件 \\\"encrypted_data.txt\\\"。\", \"programming_language\":\"python\", \"tags\":\"软件工程\"}", "test": "{\"asset\":null, \"code\":\"import os\\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\\nfrom cryptography.hazmat.backends import default_backend\\nimport base64\\n\\n\\nclass TestEncryption:\\n    def test_save_and_read_from_file_with_fixture(self, encryption_key, tmp_path):\\n        original_text = \\\"Testing file save and read functionality.\\\"\\n        encrypted_text = encrypt(original_text, encryption_key)\\n        file_path = tmp_path / \\\"test_file.txt\\\"\\n\\n        # Save encrypted text to file\\n        save_to_file(encrypted_text, file_path)\\n\\n        # Read from file and decrypt\\n        loaded_encrypted_text = read_from_file(file_path)\\n        decrypted_text = decrypt(loaded_encrypted_text, encryption_key)\\n\\n        assert original_text == decrypted_text, \\\"File save and read failed.\\\"\\n\\n    def test_encrypt_empty_string_with_fixture(self, encryption_key):\\n        original_text = \\\"\\\"\\n        encrypted_text = encrypt(original_text, encryption_key)\\n        decrypted_text = decrypt(encrypted_text, encryption_key)\\n        assert original_text == decrypted_text, \\\"Encryption and decryption of empty string failed.\\\"\\n\\n    def test_decrypt_invalid_input_with_fixture(self, encryption_key):\\n        invalid_encrypted_text = \\\"InvalidInput\\\"\\n        with pytest.raises(Exception, match=\\\"The length of the provided data is not a multiple of the block length.\\\"):\\n            decrypt(invalid_encrypted_text, encryption_key)\\n\\n    def test_decrypt_truncated_data_with_fixture(self, encryption_key, tmp_path):\\n        original_text = \\\"Hello, World!\\\"\\n        encrypted_text = encrypt(original_text, encryption_key)\\n\\n        # Truncate the encrypted data\\n        truncated_encrypted_text = encrypted_text[:-5]\\n\\n        file_path = tmp_path / \\\"truncated_data.txt\\\"\\n        save_to_file(truncated_encrypted_text, file_path)\\n\\n\\n    def test_read_from_nonexistent_file_with_fixture(self, encryption_key, tmp_path):\\n        nonexistent_file_path = tmp_path / \\\"nonexistent_file.txt\\\"\\n        with pytest.raises(FileNotFoundError):\\n            read_from_file(nonexistent_file_path)\\n\\n    @pytest.fixture\\n    def encryption_key(self):\\n        return b'Sixteen byte key'\\n\"}", "__internal_uuid__": "9d332025-976e-4a0a-89ba-43a2f3001d51"}
{"canonical_solution": "```python\nimport os\nimport shutil\n\ndef backup_folder(source_folder, target_folder):\n    try:\n        # 检查源文件夹是否存在\n        if not os.path.exists(source_folder):\n            raise Exception(\"Source folder does not exist.\")\n\n        # 检查目标文件夹是否存在，如果不存在则创建\n        if not os.path.exists(target_folder):\n            os.makedirs(target_folder)\n\n        # 遍历源文件夹中的所有文件和子文件夹\n        for root, dirs, files in os.walk(source_folder):\n            # 构建目标文件夹中的相对路径\n            relative_path = os.path.relpath(root, source_folder)\n            target_path = os.path.join(target_folder, relative_path)\n\n            # 创建目标文件夹中的子文件夹\n            if not os.path.exists(target_path):\n                os.makedirs(target_path)\n\n            # 复制源文件夹中的所有文件到目标文件夹中\n            for file in files:\n                source_file = os.path.join(root, file)\n                target_file = os.path.join(target_path, file)\n                shutil.copy2(source_file, target_file)\n\n        print(\"Backup completed successfully.\")\n\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\n```", "content": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个程序，接收一个文件夹路径作为输入，然后将该文件夹下的所有文件备份到指定的目标文件夹中，保留原始文件结构。例如backup_folder函数接收两个参数：源文件夹路径 (source_folder) 和目标文件夹路径 (target_folder)。在执行备份操作前，它会进行一系列检查：\n\n源文件夹检查： 首先，脚本会验证源文件夹是否存在，如果不存在则抛出异常并显示相应的错误消息。\n\n目标文件夹检查： 然后，它会检查目标文件夹是否存在。如果目标文件夹不存在，脚本会创建它。\n\n接下来，使用os.walk函数遍历源文件夹中的所有文件和子文件夹。对于每一个找到的文件和文件夹，脚本会进行以下操作：\n\n构建目标路径： 构建目标文件夹中的相对路径，并在目标文件夹中创建相应的子文件夹。\n\n文件复制： 使用shutil.copy2函数复制文件。该函数会保留文件的元数据，如创建时间和修改时间。\n\n最后，在完成备份后，脚本会输出备份成功的消息。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testbackup_folder:\n    def test_backup_successful(self, setup_test_folders):\n        source_folder, target_folder = setup_test_folders\n        assert source_folder.exists()\n        backup_folder(source_folder, target_folder)\n        assert target_folder.exists()\n\n", "id": 16, "labels": "{\"execution_language\":\"python\", \"original_id\":147, \"original_promblem\":\"编写一个程序，接收一个文件夹路径作为输入，然后将该文件夹下的所有文件备份到指定的目标文件夹中，保留原始文件结构。例如backup_folder函数接收两个参数：源文件夹路径 (source_folder) 和目标文件夹路径 (target_folder)。在执行备份操作前，它会进行一系列检查：\\n\\n源文件夹检查： 首先，脚本会验证源文件夹是否存在，如果不存在则抛出异常并显示相应的错误消息。\\n\\n目标文件夹检查： 然后，它会检查目标文件夹是否存在。如果目标文件夹不存在，脚本会创建它。\\n\\n接下来，使用os.walk函数遍历源文件夹中的所有文件和子文件夹。对于每一个找到的文件和文件夹，脚本会进行以下操作：\\n\\n构建目标路径： 构建目标文件夹中的相对路径，并在目标文件夹中创建相应的子文件夹。\\n\\n文件复制： 使用shutil.copy2函数复制文件。该函数会保留文件的元数据，如创建时间和修改时间。\\n\\n最后，在完成备份后，脚本会输出备份成功的消息。\", \"programming_language\":\"python\", \"tags\":\"操作系统\"}", "test": "{\"asset\":null, \"code\":\"import os\\nimport shutil\\n\\n\\nclass Testbackup_folder:\\n    # 使用 fixture 的方式进行测试\\n    def test_backup_empty_folder(self, tmp_path):\\n        source_folder = tmp_path / \\\"empty_folder\\\"\\n        target_folder = tmp_path / \\\"target_folder_empty\\\"\\n        source_folder.mkdir()\\n        assert source_folder.exists()\\n        backup_folder(source_folder, target_folder)\\n        assert target_folder.exists()\\n        assert not os.listdir(target_folder)\\n\\n    def test_backup_with_subfolders(self, tmp_path):\\n        source_folder = tmp_path / \\\"source_with_subfolders\\\"\\n        target_folder = tmp_path / \\\"target_with_subfolders\\\"\\n        (source_folder / \\\"subfolder\\\").mkdir(parents=True)\\n        assert source_folder.exists()\\n        backup_folder(source_folder, target_folder)\\n        assert target_folder.exists()\\n\\n    def test_backup_existing_target_folder(self, tmp_path):\\n        source_folder = tmp_path / \\\"source_folder\\\"\\n        target_folder = tmp_path / \\\"target_folder\\\"\\n        source_folder.mkdir()\\n        target_folder.mkdir()\\n        assert source_folder.exists()\\n        assert target_folder.exists()\\n        backup_folder(source_folder, target_folder)\\n        assert target_folder.exists()\\n\\n    def test_backup_to_temporary_folder(self, tmp_path):\\n        source_folder = tmp_path / \\\"source_folder\\\"\\n        target_folder = tmp_path / \\\"target_folder_temp\\\"\\n        source_folder.mkdir()\\n        assert source_folder.exists()\\n        backup_folder(source_folder, target_folder)\\n        assert target_folder.exists()\\n\\n    def test_source_folder_contains_files(self, setup_test_folders):\\n        source_folder, target_folder = setup_test_folders\\n        # 在源文件夹中创建一些文件\\n        file1 = source_folder / \\\"file1.txt\\\"\\n        file2 = source_folder / \\\"subfolder\\\" / \\\"file2.txt\\\"\\n        file1.write_text(\\\"这是文件1的内容。\\\")\\n        file2.parent.mkdir(parents=True)\\n        file2.write_text(\\\"这是文件2的内容。\\\")\\n\\n        assert file1.exists()\\n        assert file2.exists()\\n\\n        backup_folder(source_folder, target_folder)\\n\\n        # 检查文件是否在目标文件夹中备份\\n        assert (target_folder / \\\"file1.txt\\\").exists()\\n        assert (target_folder / \\\"subfolder\\\" / \\\"file2.txt\\\").exists()\\n\\n    def test_backup_with_different_file_types(self, setup_test_folders):\\n        source_folder, target_folder = setup_test_folders\\n        # 在源文件夹中创建不同扩展名的文件\\n        file_txt = source_folder / \\\"file.txt\\\"\\n        file_csv = source_folder / \\\"data.csv\\\"\\n        file_py = source_folder / \\\"script.py\\\"\\n\\n        file_txt.write_text(\\\"这是一个文本文件。\\\")\\n        file_csv.write_text(\\\"CSV 数据在这里。\\\")\\n        file_py.write_text(\\\"# Python 脚本内容。\\\")\\n\\n        assert file_txt.exists()\\n        assert file_csv.exists()\\n        assert file_py.exists()\\n\\n        backup_folder(source_folder, target_folder)\\n\\n        # 检查文件是否在目标文件夹中备份\\n        assert (target_folder / \\\"file.txt\\\").exists()\\n        assert (target_folder / \\\"data.csv\\\").exists()\\n        assert (target_folder / \\\"script.py\\\").exists()\\n\\n\\n    @pytest.fixture\\n    def setup_test_folders(self, tmp_path):\\n        source_folder = tmp_path / \\\"source_folder\\\"\\n        target_folder = tmp_path / \\\"target_folder\\\"\\n        source_folder.mkdir()\\n        target_folder.mkdir()\\n        yield source_folder, target_folder\\n\"}", "__internal_uuid__": "1f6ef543-6059-4b0b-b412-f2d0d1903831"}
{"canonical_solution": "```python\nimport os\nimport shutil\n\ndef create_folder(folder_name):\n    if not os.path.exists(folder_name):\n        os.makedirs(folder_name)\n        print(f'Folder {folder_name} created.')\n\ndef create_and_write_file(file_path, content):\n    with open(file_path, 'w', encoding='utf-8') as file:\n        file.write(content)\n        print(f'File {file_path} created and written.')\n\ndef read_and_print_file(file_path):\n    with open(file_path, 'r', encoding='utf-8') as file:\n        content = file.read()\n        print(f'Contents of {file_path}:')\n        print(content)\n\ndef copy_file(source_path, destination_path):\n    shutil.copy(source_path, destination_path)\n    print(f'File {source_path} copied to {destination_path}.')\n\ndef move_file(source_path, destination_path):\n    shutil.move(source_path, destination_path)\n    print(f'File {source_path} moved to {destination_path}.')\n\ndef delete_folder(folder_name):\n    shutil.rmtree(folder_name)\n    print(f'Folder {folder_name} and its contents deleted.')\n\n```", "content": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写Python 程序，用于文件和文件夹操作的程序，包括创建文件夹 (create_folder)、使用 open 函数以写入模式创建文件，并写入指定的内容、使用 open 函数以读取模式打开文件，并读取文件内容、复制文件 (copy_file)、移动文件 (move_file),和删除文件夹及其内容 (delete_folder)。例如,# 导入文件操作相关的模块\nimport os\nimport shutil\n\n# 创建文件夹\ncreate_folder('data')\n\n# 在 data 文件夹中创建并写入文件\ninfo_file_path = os.path.join('data', 'info.txt')\ncreate_and_write_file(info_file_path, \"Hello, this is some information.\")\n\n# 读取并打印文件内容\nread_and_print_file(info_file_path)\n\n# 复制文件为 info_backup.txt\ninfo_backup_path = os.path.join('data', 'info_backup.txt')\ncopy_file(info_file_path, info_backup_path)\n\n# 移动文件到 backup 文件夹中\ncreate_folder('backup')\ninfo_backup_new_path = os.path.join('backup', 'info_backup.txt')\nmove_file(info_backup_path, info_backup_new_path)\n\n# 删除 data 文件夹及其下的所有文件\ndelete_folder('data')\n导入os模块，和shutil模块\n程序创建一个文件夹（data）。\n在该文件夹中创建一个文件（info.txt）并写入一些信息。\n读取并打印文件的内容。\n复制文件为另一个文件（info_backup.txt）。\n移动文件到另一个文件夹（backup）中。\n删除原始文件夹（data）及其下的所有文件。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass TestFile_process:\n    def test_create_folder(self):\n        data_folder = 'data'\n        info_file_path = os.path.join(data_folder, 'info.txt')\n        backup_folder = 'backup'\n        info_backup_path = os.path.join(backup_folder, 'info_backup.txt')\n        create_folder(data_folder)\n        assert os.path.exists(data_folder)\n\n    # 测试用例2: 创建并写入文件\n", "id": 17, "labels": "{\"execution_language\":\"python\", \"original_id\":148, \"original_promblem\":\"编写Python 程序，用于文件和文件夹操作的程序，包括创建文件夹 (create_folder)、使用 open 函数以写入模式创建文件，并写入指定的内容、使用 open 函数以读取模式打开文件，并读取文件内容、复制文件 (copy_file)、移动文件 (move_file),和删除文件夹及其内容 (delete_folder)。例如,# 导入文件操作相关的模块\\nimport os\\nimport shutil\\n\\n# 创建文件夹\\ncreate_folder('data')\\n\\n# 在 data 文件夹中创建并写入文件\\ninfo_file_path = os.path.join('data', 'info.txt')\\ncreate_and_write_file(info_file_path, \\\"Hello, this is some information.\\\")\\n\\n# 读取并打印文件内容\\nread_and_print_file(info_file_path)\\n\\n# 复制文件为 info_backup.txt\\ninfo_backup_path = os.path.join('data', 'info_backup.txt')\\ncopy_file(info_file_path, info_backup_path)\\n\\n# 移动文件到 backup 文件夹中\\ncreate_folder('backup')\\ninfo_backup_new_path = os.path.join('backup', 'info_backup.txt')\\nmove_file(info_backup_path, info_backup_new_path)\\n\\n# 删除 data 文件夹及其下的所有文件\\ndelete_folder('data')\\n导入os模块，和shutil模块\\n程序创建一个文件夹（data）。\\n在该文件夹中创建一个文件（info.txt）并写入一些信息。\\n读取并打印文件的内容。\\n复制文件为另一个文件（info_backup.txt）。\\n移动文件到另一个文件夹（backup）中。\\n删除原始文件夹（data）及其下的所有文件。\", \"programming_language\":\"python\", \"tags\":\"操作系统\"}", "test": "{\"asset\":null, \"code\":\"import os\\nimport shutil\\n\\n\\nclass TestFile_process:\\n    # 测试用例1: 创建文件夹\\n    def test_create_and_write_file(self):\\n        data_folder = 'data'\\n        info_file_path = os.path.join(data_folder, 'info.txt')\\n        backup_folder = 'backup'\\n        info_backup_path = os.path.join(backup_folder, 'info_backup.txt')\\n        create_and_write_file(info_file_path, \\\"Test content\\\")\\n        assert os.path.exists(info_file_path)\\n\\n    # 测试用例3: 读取并打印文件内容\\n    def test_read_and_print_file(self, capsys):\\n        data_folder = 'data'\\n        info_file_path = os.path.join(data_folder, 'info.txt')\\n        backup_folder = 'backup'\\n        info_backup_path = os.path.join(backup_folder, 'info_backup.txt')\\n        read_and_print_file(info_file_path)\\n        captured = capsys.readouterr()\\n        assert \\\"Test content\\\" in captured.out\\n\\n    # 测试用例4: 复制文件\\n    def test_copy_file(self):\\n        data_folder = 'data'\\n        info_file_path = os.path.join(data_folder, 'info.txt')\\n        backup_folder = 'backup'\\n        info_backup_path = os.path.join(backup_folder, 'info_backup.txt')\\n        copy_file(info_file_path, info_backup_path)\\n        assert os.path.exists(info_backup_path)\\n\\n    # 测试用例：尝试移动已删除的文件\\n    def test_move_deleted_file(self):\\n        data_folder = 'data'\\n        info_file_path = os.path.join(data_folder, 'info.txt')\\n        backup_folder = 'backup'\\n        info_backup_path = os.path.join(backup_folder, 'info_backup.txt')\\n        # 创建 data 文件夹\\n        create_folder(data_folder)\\n\\n        # 在 data 文件夹中创建 info.txt 文件\\n        create_and_write_file(info_file_path, \\\"Hello, this is some information.\\\")\\n\\n        # 将文件移动到 backup 文件夹中\\n        shutil.move(info_file_path, backup_folder)\\n\\n        # 使用 os.path.join 构建移动后的文件路径\\n        moved_file_path = os.path.join(backup_folder, os.path.basename(info_file_path))\\n\\n        # 确保文件已成功移动\\n        assert os.path.exists(moved_file_path)\\n        assert not os.path.exists(info_file_path)\\n\\n    # 测试用例6: 删除文件夹\\n    def test_delete_folder(self):\\n        data_folder = 'data'\\n        info_file_path = os.path.join(data_folder, 'info.txt')\\n        backup_folder = 'backup'\\n        info_backup_path = os.path.join(backup_folder, 'info_backup.txt')\\n        delete_folder(data_folder)\\n        assert not os.path.exists(data_folder)\\n\\n    # 测试用例7: 尝试读取已删除的文件\\n    def test_read_deleted_folder(self, capsys):\\n        data_folder = 'data'\\n        info_file_path = os.path.join(data_folder, 'info.txt')\\n        backup_folder = 'backup'\\n        info_backup_path = os.path.join(backup_folder, 'info_backup.txt')\\n        # 删除文件\\n        os.remove(info_file_path)\\n\\n        # 尝试读取已删除的文件\\n        with pytest.raises(FileNotFoundError):\\n            read_and_print_file(info_file_path)\\n\\n        captured = capsys.readouterr()\\n        assert \\\"FileNotFoundError\\\" != str(captured.err)\\n\\n    # 测试用例8: 尝试删除已删除的文件夹\\n    def test_delete_deleted_folder(self):\\n        data_folder = 'data'\\n        info_file_path = os.path.join(data_folder, 'info.txt')\\n        backup_folder = 'backup'\\n        info_backup_path = os.path.join(backup_folder, 'info_backup.txt')\\n        delete_folder(data_folder)\\n        assert not os.path.exists(data_folder)\\n\\n        # 使用 os.path.exists 检查文件夹是否不存在\\n        assert not os.path.exists(data_folder)\\n\\n    # 预先设置测试环境\\n    @pytest.fixture(autouse=True)\\n    def setup_teardown(self):\\n        data_folder = 'data'\\n        info_file_path = os.path.join(data_folder, 'info.txt')\\n        backup_folder = 'backup'\\n        info_backup_path = os.path.join(backup_folder, 'info_backup.txt')\\n        create_folder(data_folder)\\n        create_and_write_file(info_file_path, \\\"Test content\\\")\\n        create_folder(backup_folder)\\n\\n        yield\\n\\n        # 清理测试环境\\n        if os.path.exists(data_folder):\\n            shutil.rmtree(data_folder)\\n        if os.path.exists(backup_folder):\\n            shutil.rmtree(backup_folder)\\n\\n\"}", "__internal_uuid__": "20da8e10-91d0-426e-829a-aa4790969659"}
{"canonical_solution": "```python\nimport re\n\n\ndef extract_phone_numbers(text):\n    # 电话号码的正则表达式模式\n    pattern = re.compile(r'\\(?\\b(\\d{3})\\)?[-.\\s]?(\\d{3})[-.\\s]?(\\d{4})\\b')\n\n    # 使用 finditer 方法提取所有匹配的电话号码\n    matches = pattern.finditer(text)\n\n    # 存储提取到的电话号码\n    phone_numbers = []\n\n    for match in matches:\n        # 获取匹配对象的匹配组\n        groups = match.groups()\n\n        # 格式化提取到的电话号码\n        formatted_number = f\"({groups[0]}) {groups[1]}-{groups[2]}\"\n\n        # 添加到结果列表\n        phone_numbers.append(formatted_number)\n\n    return phone_numbers\n\n\n```", "content": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写Python程序，该程序接受一个文本字符串作为输入，并使用正则表达式模式来提取其中的电话号码。\\n\\n使用 re.compile 创建了一个正则表达式模式，用于匹配电话号码。\n定义了一个名为 extract_phone_numbers 的函数，表达式：\\(? 匹配可选的左括号，\\b 表示单词边界，(\\d{3}) 匹配三个数字作为区号，[-.\\s]? 匹配可选的分隔符（包括破折号、点或空格），(\\d{3}) 匹配三个数字作为中间部分，同样匹配可选的分隔符，(\\d{4}) 匹配四个数字作为结尾，\\b 表示单词边界。\n定义一个finditer 方法，使用 pattern.finditer(text) 调用 finditer 方法，返回一个迭代器，该迭代器包含匹配模式的所有对象。\n提取和格式化电话号码：\n遍历 matches 迭代器中的每个匹配对象。\n对于每个匹配对象，使用 match.groups() 获取匹配组，即区号、中间部分和结尾。\n使用这些组件格式化电话号码为 \"(XXX) YYY-ZZZZ\" 的形式。\n结果存储：\n将格式化的电话号码添加到 phone_numbers 列表中。\n返回包含所有提取电话号码的列表。例如,example_text = \"\"\"\nContact List:\n- Alice: (123) 456-7890\n- Bob: 987-654-3210\n- Charlie: (555) 123-4567\n- David: 123.456.7890\n\"\"\"\n\n# 提取电话号码\nphone_numbers = extract_phone_numbers(example_text)\n\n# 打印提取到的电话号码\nprint(\"Extracted Phone Numbers:\")\nfor number in phone_numbers:\n    print(number)这个示例中，example_text 包含了一些不同格式的电话号码。extract_phone_numbers 函数被调用来提取并格式化这些电话号码，然后提取电话号码，打印出来。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testextract_phone_numbers:\n    def test_valid_format_with_parentheses(self):\n        text = \"联系我们：(123) 456-7890 或者 123-456-7890。\"\n        result = extract_phone_numbers(text)\n        assert result == ['(123) 456-7890', '(123) 456-7890']\n\n", "id": 18, "labels": "{\"execution_language\":\"python\", \"original_id\":149, \"original_promblem\":\"编写Python程序，该程序接受一个文本字符串作为输入，并使用正则表达式模式来提取其中的电话号码。\\\\n\\\\n使用 re.compile 创建了一个正则表达式模式，用于匹配电话号码。\\n定义了一个名为 extract_phone_numbers 的函数，表达式：\\\\(? 匹配可选的左括号，\\\\b 表示单词边界，(\\\\d{3}) 匹配三个数字作为区号，[-.\\\\s]? 匹配可选的分隔符（包括破折号、点或空格），(\\\\d{3}) 匹配三个数字作为中间部分，同样匹配可选的分隔符，(\\\\d{4}) 匹配四个数字作为结尾，\\\\b 表示单词边界。\\n定义一个finditer 方法，使用 pattern.finditer(text) 调用 finditer 方法，返回一个迭代器，该迭代器包含匹配模式的所有对象。\\n提取和格式化电话号码：\\n遍历 matches 迭代器中的每个匹配对象。\\n对于每个匹配对象，使用 match.groups() 获取匹配组，即区号、中间部分和结尾。\\n使用这些组件格式化电话号码为 \\\"(XXX) YYY-ZZZZ\\\" 的形式。\\n结果存储：\\n将格式化的电话号码添加到 phone_numbers 列表中。\\n返回包含所有提取电话号码的列表。例如,example_text = \\\"\\\"\\\"\\nContact List:\\n- Alice: (123) 456-7890\\n- Bob: 987-654-3210\\n- Charlie: (555) 123-4567\\n- David: 123.456.7890\\n\\\"\\\"\\\"\\n\\n# 提取电话号码\\nphone_numbers = extract_phone_numbers(example_text)\\n\\n# 打印提取到的电话号码\\nprint(\\\"Extracted Phone Numbers:\\\")\\nfor number in phone_numbers:\\n    print(number)这个示例中，example_text 包含了一些不同格式的电话号码。extract_phone_numbers 函数被调用来提取并格式化这些电话号码，然后提取电话号码，打印出来。\", \"programming_language\":\"python\", \"tags\":\"软件工程\"}", "test": "{\"asset\":null, \"code\":\"import re\\n\\n\\nclass Testextract_phone_numbers:\\n    def test_valid_format_with_dashes_and_dots(self):\\n        text = \\\"请拨打电话：123.456.7890 或者 987-654-3210。\\\"\\n        result = extract_phone_numbers(text)\\n        assert result == ['(123) 456-7890', '(987) 654-3210']\\n\\n    def test_no_phone_numbers(self):\\n        text = \\\"这段文本中没有电话号码。\\\"\\n        result = extract_phone_numbers(text)\\n        assert result == []\\n\\n    def test_invalid_format_should_not_match(self):\\n        text = \\\"无效的号码 (123) 45-67890 不应匹配。\\\"\\n        result = extract_phone_numbers(text)\\n        assert result == []\\n\\n    def test_another_invalid_format_should_not_match(self):\\n        text = \\\"另一个无效的号码 1234-567-890 不应匹配。\\\"\\n        result = extract_phone_numbers(text)\\n        assert result == []\\n\\n    def test_incomplete_number_should_not_match(self):\\n        text = \\\"不完整的号码 (123) 456 不应匹配。\\\"\\n        result = extract_phone_numbers(text)\\n        assert result == []\\n\\n    def test_valid_number_with_extra_text(self):\\n        text = \\\"有效号码 111-222-3333 附带额外文本。\\\"\\n        result = extract_phone_numbers(text)\\n        assert result == ['(111) 222-3333']\\n\\n    def test_multiple_valid_numbers(self):\\n        text = \\\"多个有效号码：(111) 222-3333 和 444.555.6666。\\\"\\n        result = extract_phone_numbers(text)\\n        assert result == ['(111) 222-3333', '(444) 555-6666']\\n\"}", "__internal_uuid__": "02a80d6c-cd45-4b8f-81a7-822ff6ce4632"}
{"canonical_solution": "```python\nimport numpy as np\nfrom scipy.linalg import eig\n\n\ndef calculate_eigen(matrix, num_largest=5):\n    # 计算特征值和特征向量\n    eigenvalues, eigenvectors = eig(matrix)\n\n    # 找到最大的几个特征值及其对应的索引\n    largest_indices = np.argsort(eigenvalues)[-num_largest:]\n\n    # 提取最大的几个特征值和对应的特征向量\n    largest_eigenvalues = eigenvalues[largest_indices]\n    largest_eigenvectors = eigenvectors[:, largest_indices]\n\n    return largest_eigenvalues, largest_eigenvectors\n\n```", "content": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个名为 find_max_eigenvalues 的 Python 程序，计算一个二位矩阵的最大特征值及对应的特征向量。输入参数包括一个二维数组 matrix 和一个可选参数 `num_largest`（默认值为 5），用于指定要提取的最大特征值的数量。程序返回两个列表，第一个列表为特征值列表，第二个列表为对应的特征向量列表。程序使用 NumPy 和 SciPy 库进行计算。如果输入矩阵为空或格式不正确，程序将抛出 ValueError。例如，对于输入矩阵：[[1, 2, 3], [4, 5, 6], [7, 8, 9]],以及 `num_largest` 设为 2，程序应返回以下结果：特征值列表：[18.8302358, -0.67276795]，对应的特征向量列表：[[-0.40962667, -0.54264865, -0.73330651], [0.43402538, -0.82296167, 0.36654613]]。这里，第一个特征向量 [-0.40962667, -0.54264865, -0.73330651] 对应于最大特征值 18.8302358，而第二个特征向量 [0.43402538, -0.82296167, 0.36654613] 对应于第二大特征值 -0.67276795。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testcalculate_eigen:\n    def test_calculate_eigen_default(self):\n        test_matrix = np.array([[1, 2, 3, 4, 5],\n                                [6, 7, 8, 9, 10],\n                                [11, 12, 13, 14, 15],\n                                [16, 17, 18, 19, 20],\n                                [21, 22, 23, 24, 25]])\n\n        largest_eigenvalues, largest_eigenvectors = calculate_eigen(test_matrix)\n        assert len(largest_eigenvalues) == 5\n        assert largest_eigenvalues[0] < largest_eigenvalues[-1]\n\n", "id": 19, "labels": "{\"execution_language\":\"python\", \"original_id\":150, \"original_promblem\":\"编写一个名为 find_max_eigenvalues 的 Python 程序，计算一个二位矩阵的最大特征值及对应的特征向量。输入参数包括一个二维数组 matrix 和一个可选参数 `num_largest`（默认值为 5），用于指定要提取的最大特征值的数量。程序返回两个列表，第一个列表为特征值列表，第二个列表为对应的特征向量列表。程序使用 NumPy 和 SciPy 库进行计算。如果输入矩阵为空或格式不正确，程序将抛出 ValueError。例如，对于输入矩阵：[[1, 2, 3], [4, 5, 6], [7, 8, 9]],以及 `num_largest` 设为 2，程序应返回以下结果：特征值列表：[18.8302358, -0.67276795]，对应的特征向量列表：[[-0.40962667, -0.54264865, -0.73330651], [0.43402538, -0.82296167, 0.36654613]]。这里，第一个特征向量 [-0.40962667, -0.54264865, -0.73330651] 对应于最大特征值 18.8302358，而第二个特征向量 [0.43402538, -0.82296167, 0.36654613] 对应于第二大特征值 -0.67276795。\", \"programming_language\":\"python\", \"tags\":\"数据科学\"}", "test": "{\"asset\":null, \"code\":\"import numpy as np\\nfrom scipy.linalg import eig\\n\\n\\nclass Testcalculate_eigen:\\n    def test_calculate_eigen_custom(self):\\n        test_matrix = np.array([[1, 2, 3, 4, 5],\\n                                [6, 7, 8, 9, 10],\\n                                [11, 12, 13, 14, 15],\\n                                [16, 17, 18, 19, 20],\\n                                [21, 22, 23, 24, 25]])\\n\\n        largest_eigenvalues, largest_eigenvectors = calculate_eigen(test_matrix, num_largest=3)\\n        assert len(largest_eigenvalues) == 3\\n        assert largest_eigenvalues[0] < largest_eigenvalues[-1]\\n\\n    def test_calculate_eigen_non_square_matrix(self):\\n        non_square_matrix = np.array([[1, 2, 3], [4, 5, 6]])\\n        with pytest.raises(ValueError):\\n            calculate_eigen(non_square_matrix)\\n\\n    def test_calculate_eigen_empty_matrix(self):\\n        empty_matrix = np.array([])\\n        with pytest.raises(ValueError):\\n            calculate_eigen(empty_matrix)\\n\\n    def test_calculate_eigen_large_matrix(self):\\n        large_matrix = np.random.rand(100, 100)\\n        largest_eigenvalues, _ = calculate_eigen(large_matrix, num_largest=10)\\n        assert len(largest_eigenvalues) == 10\\n        assert largest_eigenvalues[0] < largest_eigenvalues[-1]\\n\\n    def test_calculate_eigen_negative_values(self):\\n        negative_matrix = np.array([[1, -2, 3], [-4, 5, -6], [7, -8, 9]])\\n        largest_eigenvalues, _ = calculate_eigen(negative_matrix)\\n        assert np.all(np.real(largest_eigenvalues) != 0)\\n\"}", "__internal_uuid__": "9391d499-430f-4c13-a479-532a9b99dfaf"}